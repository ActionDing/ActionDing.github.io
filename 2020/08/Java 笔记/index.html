<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java 笔记 | ActionDing</title><meta name="keywords" content="Java,笔记"><meta name="author" content="ActionDing"><meta name="copyright" content="ActionDing"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="编程语言核心结构：变量、基本语法、分支、循环、数组等  Java 面向对象的核心逻辑：OOP、封装、继承、多态、接口等  开发Java SE 高级应用程序：异常、集合、I&#x2F;O、多线程、反射机制、网络编程等  实训项目  项目一：讲完流程控制时，可以做。 项目二：讲完面向对象（上），可以做 项目三：讲完异常处理以后，可以做 附加项目一：讲完异常处理以后，可以做 附加项目二：讲完IO流以">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 笔记">
<meta property="og:url" content="https://actionding.github.io/2020/08/Java%20%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="ActionDing">
<meta property="og:description" content="编程语言核心结构：变量、基本语法、分支、循环、数组等  Java 面向对象的核心逻辑：OOP、封装、继承、多态、接口等  开发Java SE 高级应用程序：异常、集合、I&#x2F;O、多线程、反射机制、网络编程等  实训项目  项目一：讲完流程控制时，可以做。 项目二：讲完面向对象（上），可以做 项目三：讲完异常处理以后，可以做 附加项目一：讲完异常处理以后，可以做 附加项目二：讲完IO流以">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png">
<meta property="article:published_time" content="2020-08-04T19:02:00.000Z">
<meta property="article:modified_time" content="2022-03-11T02:02:05.802Z">
<meta property="article:author" content="ActionDing">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="笔记">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png"><link rel="shortcut icon" href="/img/favicon.jpg"><link rel="canonical" href="https://actionding.github.io/2020/08/Java%20%E7%AC%94%E8%AE%B0/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-11 10:02:05'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"><link rel="alternate" href="/atom.xml" title="ActionDing" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://s2.loli.net/2022/03/08/NatumZBRC4zSi8Q.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/musics/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-address-card"></i><span> 关于我</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ActionDing</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 目录</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-heartbeat"></i><span> 娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/musics/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-address-card"></i><span> 关于我</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java 笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-04T19:02:00.000Z" title="发表于 2020-08-05 03:02:00">2020-08-05</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-11T02:02:05.802Z" title="更新于 2022-03-11 10:02:05">2022-03-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/">笔记</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%AC%94%E8%AE%B0/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java 笔记"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p><img src="/.io//image%5CJava%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.png" alt="image-20210202171943966"></p>
<ul>
<li><p>编程语言核心结构：变量、基本语法、分支、循环、数组等</p>
</li>
<li><p>Java 面向对象的核心逻辑：OOP、封装、继承、多态、接口等</p>
</li>
<li><p>开发Java SE 高级应用程序：异常、集合、I&#x2F;O、多线程、反射机制、网络编程等</p>
</li>
<li><p>实训项目</p>
<blockquote>
<p>项目一：讲完流程控制时，可以做。</p>
<p>项目二：讲完面向对象（上），可以做</p>
<p>项目三：讲完异常处理以后，可以做</p>
<p>附加项目一：讲完异常处理以后，可以做</p>
<p>附加项目二：讲完IO流以后，可以做</p>
</blockquote>
</li>
</ul>
<span id="more"></span>

<h2 id="第一部分-Java-基础编程"><a href="#第一部分-Java-基础编程" class="headerlink" title="第一部分 Java 基础编程"></a>第一部分 Java 基础编程</h2><h3 id="第1章-Java-语言概述"><a href="#第1章-Java-语言概述" class="headerlink" title="第1章 Java 语言概述"></a>第1章 Java 语言概述</h3><p>Java 是 SUN (Stanford University Network, 斯坦福大学网络公司) 1995 年推出的一门高级编程语言</p>
<p><a target="_blank" rel="noopener" href="https://www.tiobe.com/tiobe-index/"><strong>TIOBE 指数</strong></a></p>
<h4 id="1-1-Java-简史"><a href="#1-1-Java-简史" class="headerlink" title="1.1 Java 简史"></a>1.1 Java 简史</h4><ul>
<li>1991 年，Green 项目，开发语言最初命名为 Oak ( 橡树 )</li>
<li>1994 年，开发组意识到 Oak 非常适合于互联网</li>
<li>1996 年，发布 JDK 1.0，约 8.3 万个网页应用 Java 技术来制作</li>
<li>1997 年，发布 JDK 1.1 JavaOne 会议召开，创当时全球同类会议规模之最</li>
<li>1998 年，发布 JDK 1.2 ，同年发布企业平台 J2EE</li>
<li>1999 年， Java 分成 J2SE 、 J2EE 和 J2ME JSP&#x2F;Servlet 技术诞生</li>
<li><strong>2004 年，发布里程碑式版本： JDK 1.5 为突出此版本的重要性，更名为 JDK 5.0</strong></li>
<li>2005 年， <code>J2SE --&gt; JavaSE</code>；<code>J2EE --&gt; JavaEE</code>；<code>J2ME --&gt; JavaME</code></li>
<li>2009 年， Oracle 公司收购 SUN，交易价格 74 亿美元</li>
<li>2011 年，发布 JDK 7.0</li>
<li><strong>2014 年，发布 JDK 8.0 ，是继 JDK 5.0 以来变化最大的版本</strong></li>
<li>2017 年，发布 JDK 9.0 ，最大限度实现模块化</li>
<li>2018 年 3 月，发布 JDK 10.0 ，版本号也称为 18.3</li>
<li>2018 年 9 月，发布 JDK 11.0 ，版本号也称为 18.9</li>
<li>2019 年 3 月，发布 JDK 12.0 ，版本号也称为 19.3</li>
<li>2019 年 9 月，发布 JDK 13.0 ，版本号也称为 19.9</li>
<li>2020 年 3 月，发布 JDK 14.0 ，版本号也称为 20.3</li>
</ul>
<h4 id="1-2-Java-技术体系平台"><a href="#1-2-Java-技术体系平台" class="headerlink" title="1.2 Java 技术体系平台"></a>1.2 Java 技术体系平台</h4><ol>
<li><strong>Java SE</strong> (Java Standard Edition): 标准版，支持面向桌面级应用（如Windows 下的应用程序）的 Java 平台，提供了完整的 Java 核心 API ，此版本以前称为 J2SE</li>
<li><strong>Java EE</strong> (Java Enterprise Edition): 企业版，为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如Servlet 、 Jsp 等，主要针对于 Web 应用程序开发。版本以前称为 J2EE</li>
<li><strong>Java ME</strong>  (Java Micro Edition): 小型版，支持Java 程序运行在移动终端（手机、 PDA ）上的平台，对 Java API 有所精简，并加入了针对移动终端的支持，此版本以前称为 J2ME</li>
<li><strong>Java Card</strong>：支持一些Java 小程序（ Applets ）运行在小内存设备（如智能卡）上的平台</li>
</ol>
<h4 id="1-3-应用领域"><a href="#1-3-应用领域" class="headerlink" title="1.3 应用领域"></a>1.3 应用领域</h4><ol>
<li><strong>企业级应用</strong>：主要指复杂的大企业的软件系统、各种类型的网站。Java 的安全机制以及它的跨平台的优势，使它在分布式系统领域开发中有广泛应用。应用领域包括金融、电信、交通、电子商务等。</li>
<li><strong>Android 平台应用</strong>：Android 应用程序使用 Java 语言编写。Android 开发水平的高低很大程度上取决于 Java 语言核心能力是否扎实。</li>
<li><strong>大数据平台开发</strong>：各类框架有 Hadoop、spark、storm、flink 等，就这类技术生态圈来讲，还有各种中间件如 flume、kafka、sqoop 等等 ，这些框架以及工具大多数是用 Java 编写而成，但提供诸如 Java、scala、Python、R 等各种语言 API 供编程。</li>
<li><strong>移动领域应用</strong>：主要表现在消费和嵌入式领域，是指在各种小型设备上的应用，包括手机、 PDA 、机顶盒、汽车通信设备等。</li>
</ol>
<h4 id="1-4-Java语言运行机制"><a href="#1-4-Java语言运行机制" class="headerlink" title="1.4 Java语言运行机制"></a>1.4 Java语言运行机制</h4><p><strong>1）Java语言的特点</strong></p>
<ol>
<li><p>面向对象</p>
<ul>
<li>两个基本概念：类、对象</li>
<li>三大特性：封装、继承、多态</li>
</ul>
</li>
<li><p>健壮性</p>
</li>
<li><p>跨平台性</p>
</li>
</ol>
<p><strong>2）Java两种核心机制</strong></p>
<ol>
<li>① <strong>Java虚拟机</strong>（Java Virtual Machine）<ul>
<li>对于不同的平台，有不同的虚拟机。</li>
<li>Java 虚拟机机制屏蔽了底层运行平台的差别，实现了<strong>“ 一次编译，到处运行“</strong></li>
</ul>
</li>
<li>② <strong>垃圾回收机制</strong>（Garbage Collection）<ul>
<li>不再使用的内存空间应回收–垃圾回收。</li>
<li>垃圾回收在 Java 程序运行过程中自动进行，程序员无法精确控制和干预</li>
</ul>
</li>
</ol>
<p><strong>3） Java语言的环境搭建</strong></p>
<ol>
<li><strong>JDK</strong>（Java Development Kit Java，开发工具包）</li>
<li><strong>JRE</strong>（Java R untime Environment Java，运行环境 ）</li>
<li><strong>JDK、 JRE 、JVM之间的关系</strong><ul>
<li>JDK &#x3D; JRE + 开发工具集（例如 Javac 编译工具 等）</li>
<li>JRE &#x3D; JVM + Java SE 标准类库</li>
</ul>
</li>
</ol>
<h3 id="第2章-第一个Java程序"><a href="#第2章-第一个Java程序" class="headerlink" title="第2章 第一个Java程序"></a>第2章 第一个Java程序</h3><p><strong>知识点</strong>：编译运行过程、三种注释</p>
<h4 id="2-1-打印-Hello-World"><a href="#2-1-打印-Hello-World" class="headerlink" title="2.1 打印 Hello World"></a>2.1 打印 Hello World</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印 Hello World</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1）编译运行过程</strong></p>
<ol>
<li><p>将 Java 代码编写到扩展名为 <code>.java 的文件</code>（<strong>源文件</strong>）中。</p>
</li>
<li><p>通过 javac 命令对该 java 文件进行<strong>编译</strong> 。</p>
</li>
<li><p>通过 java 命令对生成的 class 文件（<strong>字节码文件</strong>）进行<strong>运行</strong> 。</p>
</li>
</ol>
<p><strong>2）具体步骤</strong></p>
<ol>
<li><p>打开记事本，输入以上代码，保存为 <code>HelloWorld.java</code></p>
</li>
<li><p>在保存文件的位置打开命令行，输入<code>javac HelloWorld.java</code>，会生成一个<code>HelloWorld.class</code>文件</p>
</li>
<li><p>命令行继续输入<code>java HelloWorld</code></p>
</li>
</ol>
<h4 id="2-2-注释"><a href="#2-2-注释" class="headerlink" title="2.2 注释"></a>2.2 注释</h4><p><strong>1）单行注释</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注释文字</span></span><br></pre></td></tr></table></figure>

<p><strong>2）多行注释</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">注释文字 </span></span><br><span class="line"><span class="comment">注释文字 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><strong>3）文档注释</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> 指定 java 程序的作者</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 指定源文件的版本</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注释内容可以被 JDK 提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。</p>
</blockquote>
<p><strong>操作方式</strong>：<code>javadoc -d [文件夹名] -author -version [源文件名]</code></p>
<h4 id="2-3-良好的编程风格"><a href="#2-3-良好的编程风格" class="headerlink" title="2.3 良好的编程风格"></a>2.3 良好的编程风格</h4><p><strong>1）正确的注释和注释风格</strong></p>
<ul>
<li><p>使用文档注释来注释整个类或整个方法</p>
</li>
<li><p>如果注释方法中的某一个步骤，使用单行或多行注释</p>
</li>
</ul>
<p><strong>2）正确的缩进和空白</strong></p>
<ul>
<li><p>使用一次 <kbd>Tab</kbd> 操作，实现缩进</p>
</li>
<li><p>运算符两边习惯性各加一个空格</p>
</li>
</ul>
<p><strong>3）块的风格</strong></p>
<ul>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/index.html">Java API</a> 源代码选择了行尾风格</li>
</ul>
<blockquote>
<p>API：Application Programming Interface。习惯上：将语言提供的类库，都称为API</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Java注释的三种方式：</span></span><br><span class="line"><span class="comment">①单行注释</span></span><br><span class="line"><span class="comment">②多行注释</span></span><br><span class="line"><span class="comment">③文档注释（Java特有）</span></span><br><span class="line"><span class="comment">	生成文档：javadoc -d mydoc -author -version HelloJava.java</span></span><br><span class="line"><span class="comment">	mydoc为文档目录</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*****这属于多行注释*****</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> Ding</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*****这属于文档注释*****</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJava</span> &#123;</span><br><span class="line">	<span class="comment">//main方法是程序的入口	*****这属于单行注释*****</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="comment">//打印HelloJava	</span></span><br><span class="line">		System.out.println(<span class="string">&quot;HelloJava&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="附：Tips"><a href="#附：Tips" class="headerlink" title="附：Tips"></a>附：Tips</h4><p><strong>1）常用的 DOS 命令</strong></p>
<ul>
<li><p><code>dir</code>：列出当前目录下的文件以及文件夹</p>
</li>
<li><p><code>md</code>：创建目录</p>
</li>
<li><p><code>rd</code>：删除目录</p>
</li>
<li><p><code>cd [path]</code>：进入指定目录</p>
</li>
<li><p><code>cd..</code>：退回到上级目录</p>
</li>
<li><p><code>cd\</code>：退回到根目录</p>
</li>
<li><p><code>del</code>：删除文件</p>
</li>
<li><p><code>exit</code>：退出dos命令行</p>
</li>
<li><p><code>echo javase&gt;test.txt</code>：新建 test.txt 文件并将 “javase” 写入</p>
<ul>
<li>上下键可以查看历史操作</li>
</ul>
</li>
</ul>
<p><strong>2）文件资源管理器</strong></p>
<ol>
<li><kbd>win</kbd> + <kbd>E</kbd> 打开文件资源管理器</li>
<li>在地址栏输入 <code>cmd</code> 回车即可打开<strong>命令行</strong></li>
<li>在查看工具栏中，打开<code>隐藏/显示</code>中的 <code>文件扩展名</code></li>
</ol>
<h3 id="第3章-变量"><a href="#第3章-变量" class="headerlink" title="第3章 变量"></a>第3章 变量</h3><p><strong>知识点</strong>：关键字、标识符、变量、自动类型转换、强制类型转换</p>
<h4 id="3-1-关键字与保留字"><a href="#3-1-关键字与保留字" class="headerlink" title="3.1 关键字与保留字"></a>3.1 关键字与保留字</h4><p>**1）关键字 (keyword)**：被 Java 语言赋予了特殊含义，用做专门用途的字符串（单词）</p>
<ul>
<li><strong>特点</strong>：关键字中所有字母都为<strong>小写</strong></li>
<li><strong><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html">官方地址</a></strong></li>
</ul>
<p>**2）保留字 (reserved word)**：现有 Java 版本尚未使用,但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字</p>
<ul>
<li><strong>goto</strong> 、 <strong>const</strong></li>
<li>命名标识符时要避免使用这些保留字</li>
</ul>
<h4 id="3-2-标识符-Identifier"><a href="#3-2-标识符-Identifier" class="headerlink" title="3.2 标识符 (Identifier)"></a>3.2 标识符 (Identifier)</h4><p><strong>1）定义</strong>：Java 对各种变量、方法和类等要素命名时使用的字符序列称为<strong>标识符</strong></p>
<blockquote>
<p>凡是自己可以起名字的地方都叫<strong>标识符</strong>，如：包名、类名、接口名、变量名、方法名、常量名</p>
</blockquote>
<p><strong>2）规则</strong></p>
<ul>
<li>由 26 个英文字母大小写， 0-9 或 $ 组成</li>
<li>数字不可以开头。</li>
<li>不可以使用关键字和保留字，但能包含关键字和保留字。</li>
<li>Java 中严格区分大小写，长度无限制。</li>
<li>标识符不能包含空格。</li>
</ul>
<p><strong>3）命名规范</strong></p>
<ul>
<li><p>包名：<code>xxxyyyzzz</code></p>
</li>
<li><p>类名、接口名：<code>XxxYyyZzz</code></p>
</li>
<li><p>变量名、方法名：<code>xxxYyyZzz</code></p>
</li>
<li><p>常量名：<code>XXX_YYY_ZZZ</code></p>
<p><strong>在起名字时，为了提高阅读性，要尽量意义，“见名知意”。</strong></p>
</li>
</ul>
<h4 id="3-3-变量"><a href="#3-3-变量" class="headerlink" title="3.3 变量"></a>3.3 变量</h4><p><strong>1）定义（声明）变量</strong></p>
<ul>
<li><p>方式一：<code>数据类型  变量名 = 变量值;</code></p>
</li>
<li><p>方式二：<code>数据类型  变量名;</code><br>                <code>变量名 = 变量值;</code></p>
</li>
</ul>
<blockquote>
<p>变量必须先声明，后使用</p>
<p>变量都定义在其<strong>作用域</strong>内，同一个作用域内，不可以声明两个同名的变量</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VariableTest</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//变量的定义</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">myAge</span> <span class="operator">=</span> <span class="number">22</span>;</span><br><span class="line">		<span class="comment">//变量的使用</span></span><br><span class="line">		System.out.println(myAge);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//变量的声明</span></span><br><span class="line">		<span class="type">int</span> myNumber;</span><br><span class="line">		<span class="comment">//System.out.println(myNnmber);//赋值后才能使用</span></span><br><span class="line">		<span class="comment">//变量的赋值</span></span><br><span class="line">		myNumber = <span class="number">1001</span>;</span><br><span class="line">		System.out.println(myNumber);</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span> <span class="params">()</span>&#123;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">//作用域不同，可以定义同名变量</span></span><br><span class="line">			<span class="comment">//变量的定义</span></span><br><span class="line">			<span class="type">int</span> <span class="variable">myAge</span> <span class="operator">=</span> <span class="number">22</span>;</span><br><span class="line">			<span class="comment">//变量的使用</span></span><br><span class="line">			System.out.println(myAge);</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2）变量的分类</strong></p>
<p><strong>① 按数据类型分类</strong></p>
<p>按数据类型分为<strong>基本数据类型（primitive type）</strong>和<strong>引用数据类型（reference type）</strong></p>
<ol>
<li><p>基本数据类型又分为数值型、<strong>字符型（char）</strong>、<strong>布尔型（boolean）</strong></p>
<ul>
<li>数值型又分为<strong>整数类型（byte、short、int、long）</strong>和<strong>浮点数类型（float、double）</strong></li>
</ul>
</li>
<li><p>引用数据类型又分为<strong>类（class）</strong>、<strong>接口（interface）</strong>和<strong>数组（[]）</strong></p>
</li>
</ol>
<blockquote>
<p><strong>字符串属于类</strong></p>
</blockquote>
<p><strong>② 按声明的位置分类</strong></p>
<p>按声明的位置分为<strong>成员变量</strong>和<strong>局部变量</strong></p>
<ol>
<li>成员变量又分为<strong>实例变量</strong>（不以static修饰）和<strong>类变量</strong>（以static修饰）</li>
<li>局部变量又分为<strong>形参</strong>（方法、构造器中定义的变量）、<strong>方法局部变量</strong>（在方法内定义）和<strong>代码块局部变量</strong>（在代码块内定义）</li>
</ol>
<p><strong>3）基本数据类型</strong></p>
<p><strong>① 整型</strong></p>
<table>
<thead>
<tr>
<th align="center">byte</th>
<th align="center">short</th>
<th align="center">int</th>
<th align="center">long</th>
</tr>
</thead>
<tbody><tr>
<td align="center">1字节</td>
<td align="center">2字节</td>
<td align="center">4字节</td>
<td align="center">8字节</td>
</tr>
</tbody></table>
<p><strong>说明</strong></p>
<ol>
<li>byte范围：-128 ~ 127</li>
<li>声明long型变量，必须以”l”或”L”结尾</li>
<li>通常，定义整型变量时，使用int型。</li>
<li>整型的常量，默认类型是：int型</li>
</ol>
<p><strong>② 浮点型</strong></p>
<table>
<thead>
<tr>
<th align="center">float</th>
<th align="center">double</th>
</tr>
</thead>
<tbody><tr>
<td align="center">4字节</td>
<td align="center">8字节</td>
</tr>
</tbody></table>
<p><strong>说明</strong></p>
<ol>
<li>浮点型，表示带小数点的数值</li>
<li>float表示数值的范围比long还大</li>
<li>定义float类型变量时，变量要以”f”或”F”结尾</li>
<li>通常，定义浮点型变量时，使用double型。</li>
<li>浮点型的常量，默认类型为：double</li>
</ol>
<p><strong>③ 字符型</strong></p>
<table>
<thead>
<tr>
<th align="left">char</th>
</tr>
</thead>
<tbody><tr>
<td align="left">定义char型变量，通常使用一对’’,内部只能写一个字符</td>
</tr>
<tr>
<td align="left">表示方式：1. 声明一个字符 2. 转义字符 3. 直接使用 Unicode 值来表示字符型常量</td>
</tr>
</tbody></table>
<p><strong>④ 布尔型</strong></p>
<table>
<thead>
<tr>
<th align="left">boolean</th>
</tr>
</thead>
<tbody><tr>
<td align="left">只能取两个值之一：true 、 false</td>
</tr>
<tr>
<td align="left">常常在条件判断、循环结构中使用</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VariableTest1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//基本数据类型</span></span><br><span class="line">		<span class="comment">//整型：byte 1字节 -128 ~ 127</span></span><br><span class="line">		<span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">		<span class="comment">//byte b2 = 128;</span></span><br><span class="line">		System.out.println(b1);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//整型：short 2字节</span></span><br><span class="line">		<span class="comment">//整型：int 4字节</span></span><br><span class="line">		<span class="comment">//整型：long 8字节 以&#x27;l&#x27;或&#x27;L&#x27;结尾</span></span><br><span class="line">		</span><br><span class="line">		<span class="comment">//通常，定义整型变量时，使用int型</span></span><br><span class="line"></span><br><span class="line">		<span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">123456789098765432L</span>;</span><br><span class="line">		<span class="comment">//long l2 = 987654321012345678;</span></span><br><span class="line">		System.out.println(l1);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//浮点型：float 4字节 以&#x27;f&#x27;或&#x27;F&#x27;结尾</span></span><br><span class="line">		<span class="comment">//浮点型：double 8字节</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">// 通常，定义浮点型变量时，使用double型</span></span><br><span class="line"></span><br><span class="line">		<span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">123.45f</span>;</span><br><span class="line">		<span class="comment">//float f2 = 678.90;</span></span><br><span class="line">		System.out.println(f1);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//字符型：char 1字符=2字节 用一对单引号&#x27;&#x27;</span></span><br><span class="line">		<span class="comment">//表示方式：</span></span><br><span class="line">		<span class="comment">//	1.声明一个字符 </span></span><br><span class="line">		<span class="comment">//	2.转义字符 </span></span><br><span class="line">		<span class="comment">//	3.直接使用 Unicode 值来表示字符型常量</span></span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">		<span class="comment">//char c2 = &#x27;ab&#x27;;</span></span><br><span class="line">		System.out.println(c1);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">		<span class="type">char</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="string">&#x27;の&#x27;</span>;</span><br><span class="line">		<span class="type">char</span> <span class="variable">c5</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">		System.out.println(c3);</span><br><span class="line">		System.out.println(c4);</span><br><span class="line">		System.out.println(c5);</span><br><span class="line"></span><br><span class="line">		<span class="type">char</span> <span class="variable">c6</span> <span class="operator">=</span> <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">		<span class="type">char</span> <span class="variable">c7</span> <span class="operator">=</span> <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line">		<span class="type">char</span> <span class="variable">c8</span> <span class="operator">=</span> <span class="string">&#x27;\u1001&#x27;</span>;</span><br><span class="line">		System.out.println(<span class="string">&quot;***&quot;</span> + c6 + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;***&quot;</span> + c7 + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">		System.out.println(c8);</span><br><span class="line"></span><br><span class="line">		<span class="comment">//布尔型：boolean true/false </span></span><br><span class="line">		<span class="comment">//常常在条件判断、循环结构中使用</span></span><br><span class="line"></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">isMale</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">		System.out.println(isMale);</span><br><span class="line"></span><br><span class="line">		<span class="type">boolean</span> <span class="variable">isMarried</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">if</span> (isMarried)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Go home&quot;</span>);</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;Go party&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-4-自动类型转换"><a href="#3-4-自动类型转换" class="headerlink" title="3.4 自动类型转换"></a>3.4 自动类型转换</h4><ul>
<li><p>当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型：**<code>byte 、char 、short --&gt; int --&gt; long --&gt; float --&gt; double </code>**（此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量）</p>
</li>
<li><p><strong>特别的</strong>：当 byte、char、short 三种类型的变量做运算时，结果为int型</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VariableTest2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">		<span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">129</span>;</span><br><span class="line"></span><br><span class="line">		<span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> b1 + i1;</span><br><span class="line">		<span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> b1 + i1;</span><br><span class="line">		<span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> b1 + i1;</span><br><span class="line">		System.out.println(i2);</span><br><span class="line">		System.out.println(l);</span><br><span class="line">		System.out.println(f);</span><br><span class="line"></span><br><span class="line">		<span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">		<span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> s1;</span><br><span class="line">		System.out.println(d1);<span class="comment">//123.0</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">//***************特别地*********************</span></span><br><span class="line">		<span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;<span class="comment">//97</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i4</span> <span class="operator">=</span> c1 + i3;</span><br><span class="line">		System.out.println(i4);</span><br><span class="line"></span><br><span class="line">		<span class="type">short</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">//char c3 = c1 + b2;//编译不通过</span></span><br><span class="line">		<span class="comment">//short s3 = b2 + s2;//编译不通过</span></span><br><span class="line">		<span class="comment">//short s4 = b1 + b2;//编译不通过</span></span><br><span class="line">		<span class="comment">//****************************************</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-5-强制类型转换"><a href="#3-5-强制类型转换" class="headerlink" title="3.5 强制类型转换"></a>3.5 强制类型转换</h4><ul>
<li><strong>强转符</strong>：()</li>
<li><strong>注意</strong>：强制类型转换，可能导致精度损失。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VariableTest3</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">12.9</span>;</span><br><span class="line">		<span class="comment">//精度损失举例1</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> (<span class="type">int</span>)d1;<span class="comment">//截断操作</span></span><br><span class="line">		System.out.println(i1);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//没有精度损失</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line">		<span class="type">short</span> <span class="variable">s2</span> <span class="operator">=</span> (<span class="type">short</span>)l1;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">//精度损失举例2</span></span><br><span class="line">		<span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line">		<span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)i2;</span><br><span class="line">		System.out.println(b);<span class="comment">//-128</span></span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第4章-运算符"><a href="#第4章-运算符" class="headerlink" title="第4章 运算符"></a>第4章 运算符</h3><p><strong>知识点</strong>：算数运算符、赋值运算符、比较运算符、逻辑运算符、位运算符、三元运算符</p>
<h4 id="4-1-算术运算符"><a href="#4-1-算术运算符" class="headerlink" title="4.1 算术运算符"></a>4.1 算术运算符</h4><table>
<thead>
<tr>
<th align="center"><code>+</code></th>
<th align="center"><code>-</code></th>
<th align="center"><code>+</code></th>
<th align="center"><code>-</code></th>
<th align="center"><code>*</code></th>
<th align="center"><code>/</code></th>
<th align="center"><code>%</code></th>
<th align="center"><code>++</code></th>
<th align="center"><code>--</code></th>
<th align="center"><code>++</code></th>
<th align="center"><code>--</code></th>
<th align="center"><code>+</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">正号</td>
<td align="center">负号</td>
<td align="center">加</td>
<td align="center">减</td>
<td align="center">乘</td>
<td align="center">除</td>
<td align="center">取余</td>
<td align="center">前自增</td>
<td align="center">前自减</td>
<td align="center">后自增</td>
<td align="center">后自减</td>
<td align="center">字符串连接</td>
</tr>
</tbody></table>
<p><strong>1）自增</strong></p>
<ul>
<li>(前)++：先自增1，后运算</li>
<li>(后)++：先运算，后自增1</li>
</ul>
<p><strong>2）自减</strong></p>
<ul>
<li>(前)–：先自减1，后运算</li>
<li>(后)–：先运算，后自减1</li>
</ul>
<p><strong>3）连接符</strong>：+（只能使用在String与其他数据类型变量之间使用）</p>
<h4 id="4-2-赋值运算符"><a href="#4-2-赋值运算符" class="headerlink" title="4.2 赋值运算符"></a>4.2 赋值运算符</h4><ul>
<li><code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code></li>
<li><strong>注意</strong>：运算的结果不会改变变量本身的数据类型</li>
</ul>
<blockquote>
<p>开发中，如果希望变量实现+2的操作，有几种方法？(前提：int num &#x3D; 10;)<br>方式一：num &#x3D; num + 2;<br>方式二：num +&#x3D; 2; (推荐)</p>
</blockquote>
<blockquote>
<p>开发中，如果希望变量实现+1的操作，有几种方法？(前提：int num &#x3D; 10;)<br>方式一：num &#x3D; num + 1;<br>方式二：num +&#x3D; 1;<br>方式三：num++; (推荐)</p>
</blockquote>
<h4 id="4-3-比较运算符"><a href="#4-3-比较运算符" class="headerlink" title="4.3 比较运算符"></a>4.3 比较运算符</h4><ul>
<li><p>也叫<strong>关系运算符</strong>，比较运算符运算的结果都是 boolean 型</p>
</li>
<li><p><code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>、<code>instanceof</code></p>
</li>
</ul>
<hr>
<ol>
<li><p>&lt;、&gt;&#x3D;、&lt;&#x3D; :只能使用在数值类型的数据之间。</p>
</li>
<li><p>&#x3D;&#x3D; 和 !&#x3D;: 不仅可以使用在数值类型数据之间，还可以使用在其他引用类型变量之间。</p>
</li>
</ol>
<h4 id="4-4-逻辑运算符"><a href="#4-4-逻辑运算符" class="headerlink" title="4.4 逻辑运算符"></a>4.4 逻辑运算符</h4><table>
<thead>
<tr>
<th align="center"><code>&amp;</code></th>
<th align="center"><code>&amp;&amp;</code></th>
<th align="center"><code>|</code></th>
<th align="center"><code>||</code></th>
<th align="center"><code>!</code></th>
<th align="center"><code>^</code></th>
</tr>
</thead>
<tbody><tr>
<td align="center">逻辑与</td>
<td align="center">短路与</td>
<td align="center">逻辑或</td>
<td align="center">短路或</td>
<td align="center">逻辑非</td>
<td align="center">逻辑异或</td>
</tr>
</tbody></table>
<ul>
<li>逻辑运算符操作的都是 boolean 类型的变量，而且结果也是 boolean 类型</li>
</ul>
<h4 id="4-5-位运算符"><a href="#4-5-位运算符" class="headerlink" title="4.5 位运算符"></a>4.5 位运算符</h4><p>| <code>&lt;&lt;</code> | <code>&gt;&gt;</code> |   <code>&gt;&gt;&gt;</code>    |  <code>&amp;</code>   |  <code>|</code>   |   <code>^</code>    |   <code>~</code>    |<br>| :–: | :–: | :——–: | :—-: | :—-: | :——: | :——: |<br>| 左移 | 右移 | 无符号右移 | 与运算 | 或运算 | 异或运算 | 取反运算 |</p>
<ul>
<li><p>位运算是直接对整数的二进制进行的运算，操作的都是整型的数据（<strong>注</strong>：无<code>&lt;&lt;&lt;</code>）</p>
</li>
<li><p>&lt;&lt;：在一定范围内，每向左移1位，相当于 * 2</p>
</li>
<li><p>&gt;&gt;：在一定范围内，每向右移1位，相当于 &#x2F; 2</p>
</li>
</ul>
<h4 id="4-6-三元运算符"><a href="#4-6-三元运算符" class="headerlink" title="4.6 三元运算符"></a>4.6 三元运算符</h4><ul>
<li><strong>格式</strong>：<code>(条件表达式)?表达式 1 : 表达式 2;</code></li>
</ul>
<ol>
<li><p>条件表达式的结果为 <strong>boolean</strong> 类型 </p>
</li>
<li><p>根据条件表达式真或假，决定执行表达式1，还是表达式2</p>
<ul>
<li>如果表达式为 true，则执行表达式1。</li>
<li>如果表达式为 false，则执行表达式2。</li>
</ul>
</li>
<li><p>表达式1 和表达式2 要求是一致的。</p>
</li>
<li><p>三元运算符可以嵌套使用</p>
</li>
<li><p>凡是可以使用三元运算符的地方，都可以改写为 if-else；反之，不成立。</p>
</li>
<li><p>如果程序既可以使用三元运算符，又可以使用 if-else 结构，那么优先选择三元运算符。（原因：简洁、执行效率高。）</p>
</li>
</ol>
<h3 id="第5章-流程控制"><a href="#第5章-流程控制" class="headerlink" title="第5章 流程控制"></a>第5章 流程控制</h3><p><strong>知识点</strong></p>
<ol>
<li><p>顺序结构</p>
</li>
<li><p>分支结构：if-else 条件判断结构、switch-case 选择结构</p>
</li>
<li><p>循环结构：for 循环结构、while 循环结构、do-while 循环结构、嵌套循环</p>
</li>
</ol>
<h4 id="5-1-if-else-条件判断结构"><a href="#5-1-if-else-条件判断结构" class="headerlink" title="5.1 if-else 条件判断结构"></a>5.1 if-else 条件判断结构</h4><p><strong>1）三种形式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">	执行表达式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种：二选一</span></span><br><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">	执行表达式<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	执行表达式<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种：n选一</span></span><br><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">	执行表达式<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">	执行表达式<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">	执行表达式<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">	执行表达式n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>产生<strong>随机数</strong>：使用 Math.random() → [0.0 - 1.0)</p>
</li>
<li><p>公式：[a,b] → (int)(Math.random() * (b - a + 1) ) + a</p>
</li>
</ul>
<p><strong>2）说明</strong></p>
<ol>
<li><p>else 结构是可选的。</p>
</li>
<li><p>针对于条件表达式：</p>
<ul>
<li>如果多个条件表达式之间是“互斥”关系(或没有交集的关系)，哪个判断和执行语句声明顺序无所谓</li>
<li>如果多个条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将哪个结构先声明</li>
<li>如果多个条件表达式之间有包含的关系，通常情况下，需要将范围小声明在范围大的前面。否则，范围小的就没机会执行了</li>
</ul>
</li>
<li><p>if-else 结构是可以相互嵌套的。</p>
</li>
<li><p>如果 if-else 结构中的执行语句只有一行时，对应的一对{}可以省略的。但是，不建议大家省略。</p>
</li>
</ol>
<h4 id="5-2-switch-case-选择结构"><a href="#5-2-switch-case-选择结构" class="headerlink" title="5.2 switch-case 选择结构"></a>5.2 switch-case 选择结构</h4><p><strong>1）格式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">	执行语句<span class="number">1</span>;</span><br><span class="line">	<span class="comment">//break;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">	执行语句<span class="number">2</span>;</span><br><span class="line">	<span class="comment">//break;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">	执行语句n;</span><br><span class="line">	<span class="comment">//break;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2）说明</strong></p>
<ol>
<li><p>根据 switch 表达式中的值，依次匹配各个 case 中的常量。一旦匹配成功，则进入相应 case 结构中，调用其执行语句。当调用完执行语句以后，则仍然继续向下执行其他 case 结构中的执行语句，直到遇到 break 关键字或此 switch-case 结构末尾结束为止。</p>
</li>
<li><p><code>break</code>：可以使用在 switch-case 结构中，表示一旦执行到此关键字，就跳出 switch-case 结构</p>
</li>
<li><p><strong>switch 结构中的表达式，只能是如下的6种数据类型之一：<code>byte 、short、char、int、枚举类型(JDK5.0新增)、String 类型(JDK7.0新增)</code></strong></p>
</li>
<li><p>case 之后只能声明常量。不能声明范围。</p>
</li>
<li><p>break 关键字是可选的。</p>
</li>
<li><p><code>default</code>：相当于 if-else 结构中的else；default 结构是可选的，而且位置是灵活的。</p>
</li>
</ol>
<p><strong>注意</strong></p>
<ul>
<li><p>凡是可以使用 switch-case 的结构，都可以转换为 if-else。反之，不成立。</p>
</li>
<li><p>我们写分支结构时，当发现既可以使用 switch-case,（同时，switch 中表达式的取值情况不太多），又可以使用 if-els e时，我们优先选择使用 switch-case。原因：switch-case 执行效率稍高。</p>
</li>
<li><p>如果 switch-case 结构中的多个 case 的执行语句相同，则可以考虑进行合并。</p>
</li>
</ul>
<h4 id="5-3-for-循环结构"><a href="#5-3-for-循环结构" class="headerlink" title="5.3 for  循环结构"></a>5.3 for  循环结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (①; ②; ④) &#123;</span><br><span class="line">	③</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行过程</strong>：① - ② - ③ - ④ - ② - ③ - ④ - … - ②</p>
<h4 id="5-4-while-循环结构"><a href="#5-4-while-循环结构" class="headerlink" title="5.4 while 循环结构"></a>5.4 while 循环结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①</span><br><span class="line"><span class="keyword">while</span> (②) &#123;</span><br><span class="line">	③;</span><br><span class="line">	④;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>执行过程</strong>：① - ② - ③ - ④ - ② - ③ - ④ - … - ②</p>
<ul>
<li>写while循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环！</li>
<li>我们写程序，要避免出现死循环。</li>
<li>for 循环和 while 循环是可以相互转换的！</li>
</ul>
<hr>
<p><strong>for 循环和 while 循环总结：</strong></p>
<ul>
<li><p>开发中，基本上我们都会从 for、while 中进行选择，实现循环结构。</p>
</li>
<li><p>for 循环和 while 循环是可以相互转换的！ </p>
</li>
<li><p>我们写程序，要避免出现死循环。</p>
</li>
<li><p><strong>区别</strong>：for 循环和 while 循环的初始化条件部分的作用范围不同。</p>
</li>
</ul>
<h4 id="5-5-do-while"><a href="#5-5-do-while" class="headerlink" title="5.5 do-while"></a>5.5 do-while</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">	③;</span><br><span class="line">	④;</span><br><span class="line">&#125;<span class="keyword">while</span>(②);</span><br></pre></td></tr></table></figure>

<p><strong>执行过程</strong>：① - ③ - ④ - ② - ③ - ④ - … - ②</p>
<ul>
<li>do-while 循环至少会执行一次循环体！</li>
<li>开发中，使用 for 和 while 更多一些。较少使用 do-while</li>
</ul>
<h4 id="5-6-嵌套循环"><a href="#5-6-嵌套循环" class="headerlink" title="5.6 嵌套循环"></a>5.6 嵌套循环</h4><p><strong>1）嵌套循环</strong>：将一个循环结构 A 声明在另一个循环结构 B 的循环体中,就构成了嵌套循环</p>
<ul>
<li><strong>外层循环</strong>：循环结构 B</li>
<li><strong>内层循环</strong>：循环结构 A</li>
</ul>
<p><strong>2）说明</strong></p>
<ul>
<li><p>内层循环结构遍历一遍，只相当于外层循环循环体执行了一次</p>
</li>
<li><p>假设外层循环需要执行 m 次，内层循环需要执行 n 次。此时内层循环的循环体一共执行了 m×n 次</p>
</li>
<li><p>外层循环控制行数，内层循环控制列数</p>
</li>
</ul>
<h4 id="5-7-break-和-continue-关键字"><a href="#5-7-break-和-continue-关键字" class="headerlink" title="5.7 break 和 continue 关键字"></a>5.7 break 和 continue 关键字</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">使用范围</th>
<th align="center">循环中的作用</th>
<th align="center">相同点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">break</td>
<td align="center">switch-case、循环结构中</td>
<td align="center">结束当前循环</td>
<td align="center">关键字后面不能声明执行语句</td>
</tr>
<tr>
<td align="center">continue</td>
<td align="center">循环结构中</td>
<td align="center">结束当次循环</td>
<td align="center">关键字后面不能声明执行语句</td>
</tr>
</tbody></table>
<ul>
<li><p><strong>“无限循环”结构</strong>：<code>while(true);</code> 或 <code>for(;;)</code></p>
</li>
<li><p>如何结束一个循环结构？</p>
<ul>
<li>方式一：当循环条件是false时</li>
<li>方式二：在循环体中，执行break</li>
</ul>
</li>
<li><p><strong>循环结构的四要素</strong>：① 初始化条件；② 循环条件（boolean类型）；③ 循环体；④ 迭代条件</p>
</li>
<li><p><strong>说明</strong>：通常情况下，循环结束都是因为②中循环条件返回 <code>false </code>了。</p>
</li>
</ul>
<h3 id="第6章-数组（Array）"><a href="#第6章-数组（Array）" class="headerlink" title="第6章 数组（Array）"></a>第6章 数组（Array）</h3><p><strong>知识点</strong>：数组、一维数组、二维数组</p>
<h4 id="6-1-数组的概念"><a href="#6-1-数组的概念" class="headerlink" title="6.1 数组的概念"></a>6.1 数组的概念</h4><p><strong>1）数组的理解</strong>：数组是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。</p>
<p><strong>2）相关的概念</strong></p>
<ul>
<li><p>数组名</p>
</li>
<li><p>元素</p>
</li>
<li><p>索引：角标、下标、</p>
</li>
<li><p>数组的长度：元素的个数</p>
</li>
</ul>
<p><strong>3）数组的特点</strong></p>
<ul>
<li><p>数组是有序排列的</p>
</li>
<li><p>数组属于<strong>引用数据类型</strong>的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型</p>
</li>
<li><p>创建数组对象会在内存中开辟一整块连续的空间</p>
</li>
<li><p>数组的长度一旦确定，就不能修改</p>
</li>
</ul>
<p><strong>4）数组的分类</strong></p>
<ul>
<li><p>按照维数：一维数组、二维数组……</p>
</li>
<li><p>按照数组元素的类型：基本数据类型元素的数组、引用数据类型元素的数组</p>
</li>
</ul>
<h4 id="6-2-一维数组"><a href="#6-2-一维数组" class="headerlink" title="6.2 一维数组"></a>6.2 一维数组</h4><p><strong>1）声明与初始化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ids;<span class="comment">// 声明</span></span><br><span class="line"><span class="comment">// ① 静态初始化:数组的初始化和数组元素的赋值操作同时进行</span></span><br><span class="line">ids = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>&#125;;</span><br><span class="line"><span class="comment">// ② 动态初始化:数组的初始化和数组元素的赋值操作分开进行</span></span><br><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>[] arr4 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">// 类型推断</span></span><br></pre></td></tr></table></figure>

<p><strong>2）调用数组的指定位置的元素</strong>（通过角标的方式调用）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names[<span class="number">0</span>] = <span class="string">&quot;王铭&quot;</span>;</span><br><span class="line">names[<span class="number">1</span>] = <span class="string">&quot;王赫&quot;</span>;</span><br><span class="line">names[<span class="number">2</span>] = <span class="string">&quot;张学良&quot;</span>;</span><br><span class="line">names[<span class="number">3</span>] = <span class="string">&quot;孙居龙&quot;</span>;</span><br><span class="line">names[<span class="number">4</span>] = <span class="string">&quot;王宏志&quot;</span>;</span><br></pre></td></tr></table></figure>

<p><strong>3）数组的长度</strong></p>
<ul>
<li>数组一旦初始化，其长度就是确定的，就不可修改。使用<code>.length</code><strong>属性</strong>获取数组的长度。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(names.length);<span class="comment">//5</span></span><br></pre></td></tr></table></figure>

<p><strong>4）遍历数组</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; names.length; i++) &#123;</span><br><span class="line">	System.out.println(names[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5）数组元素的默认初始化值</strong> </p>
<table>
<thead>
<tr>
<th align="center">数据类型</th>
<th align="center">整型</th>
<th align="center">浮点型</th>
<th align="center">字符型</th>
<th align="center">布尔型</th>
<th align="center">引用数据类型</th>
</tr>
</thead>
<tbody><tr>
<td align="center">默认初始化值</td>
<td align="center">0</td>
<td align="center">0.0</td>
<td align="center">0 或 ‘\u0000’</td>
<td align="center">false</td>
<td align="center">null</td>
</tr>
</tbody></table>
<h4 id="6-3-二维数组"><a href="#6-3-二维数组" class="headerlink" title="6.3 二维数组"></a>6.3 二维数组</h4><p><strong>1）理解二维数组</strong>：一个一维数组A的元素如果还是一个一维数组类型的，则，此数组A称为二维数组</p>
<p><strong>2）声明与初始化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr1;<span class="comment">// 声明</span></span><br><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line">arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,&#123;<span class="number">4</span>, <span class="number">5</span>&#125;,&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// 动态初始化1</span></span><br><span class="line">String[][] arr2 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 动态初始化2</span></span><br><span class="line">String[][] arr3 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>][];</span><br><span class="line"><span class="type">int</span>[] arr4[] = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>&#125;,&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;;<span class="comment">// 也是正确的写法</span></span><br><span class="line"><span class="type">int</span>[] arr5[] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,&#123;<span class="number">4</span>, <span class="number">5</span>&#125;,&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;;<span class="comment">// 类型推断</span></span><br></pre></td></tr></table></figure>

<p><strong>3）调用数组的指定位置的元素</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(arr1[<span class="number">0</span>][<span class="number">1</span>]);<span class="comment">// 2</span></span><br><span class="line">System.out.println(arr2[<span class="number">1</span>][<span class="number">1</span>]);<span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">arr3[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>];</span><br><span class="line">System.out.println(arr3[<span class="number">1</span>][<span class="number">0</span>]);<span class="comment">// null</span></span><br><span class="line">System.out.println(arr3[<span class="number">0</span>]);<span class="comment">// null</span></span><br></pre></td></tr></table></figure>

<p><strong>4）数组的长度</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(arr4.length);<span class="comment">// 3</span></span><br><span class="line">System.out.println(arr4[<span class="number">0</span>].length);<span class="comment">// 3</span></span><br><span class="line">System.out.println(arr4[<span class="number">1</span>].length);<span class="comment">// 4</span></span><br></pre></td></tr></table></figure>

<p><strong>5）遍历二维数组元素</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr4.length; i++)&#123;			</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arr4[i].length;j++) &#123;</span><br><span class="line">        System.out.print(arr4[i][j] + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6）默认初始化值</strong>：二维数组分为外层数组的元素，内层数组的元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 外层元素：arr[0],arr[1]等</span></span><br><span class="line"><span class="comment">// 内层元素：arr[0][0],arr[1][2]等</span></span><br></pre></td></tr></table></figure>

<p><strong>初始化方式一</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure>

<ul>
<li><p>外层元素的初始化值为：<strong>地址值</strong></p>
</li>
<li><p>内层元素的初始化值为：与一维数组初始化情况相同</p>
</li>
</ul>
<p><strong>初始化方式二</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][];</span><br></pre></td></tr></table></figure>

<ul>
<li><p>外层元素的初始化值为：<strong>null</strong></p>
</li>
<li><p>内层元素的初始化值为：不能调用，否则报错。</p>
</li>
</ul>
<h4 id="6-4-数组的常见算法"><a href="#6-4-数组的常见算法" class="headerlink" title="6.4 数组的常见算法"></a>6.4 数组的常见算法</h4><p><strong>1）数组的创建与元素赋值</strong></p>
<ul>
<li>杨辉三角（二维数组）、回形数（二维数组）、6个数，1-30之间随机生成且不重复。</li>
</ul>
<p><strong>2）对于数值型的数组</strong></p>
<ul>
<li>最大值、最小值、总和、平均数</li>
</ul>
<p><strong>3）数组的赋值与复制</strong></p>
<ul>
<li><strong>赋值</strong>：两个变量指向同一个数组的地址，修改一个数组的元素，另一个也跟着修改。</li>
<li><strong>复制</strong>：两个独立的数组，数组的元素相同。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1,arr2;</span><br><span class="line">arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">arr2 = arr1;</span><br><span class="line"><span class="comment">//复制</span></span><br><span class="line">arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr2.length; i++) &#123;</span><br><span class="line">	arr2[i] = arr1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4）反转</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">		arr[i] = arr[arr.length - i -<span class="number">1</span>];</span><br><span class="line">		arr[arr.length - i -<span class="number">1</span>] = temp;</span><br><span class="line">	&#125;		</span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = arr.length - <span class="number">1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">		arr[i] = arr[j];</span><br><span class="line">		arr[j] = temp;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p><strong>5）查找</strong></p>
<p><strong>① 线性查找</strong> </p>
<ul>
<li><p><strong>实现思路</strong>：通过遍历的方式，一个一个的数据进行比较、查找</p>
</li>
<li><p><strong>适用性</strong>：具有普遍适用性。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;	</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;			</span><br><span class="line">	<span class="keyword">if</span> (dest.equals(arr[i])) &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;找到了指定的元素，位置为：&quot;</span> + i);</span><br><span class="line">		isFlag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;			</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isFlag) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;很遗憾，没有找到的啦！&quot;</span>);			</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>② 二分法查找</strong></p>
<ul>
<li><strong>实现思路</strong>：每次比较中间值，折半的方式检索</li>
<li><strong>适用性</strong>：数组必须有序</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 初始的首索引</span></span><br><span class="line"><span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;<span class="comment">// 初始的末索引</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (head &lt;= end) &#123;	</span><br><span class="line">	<span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (head + end) / <span class="number">2</span>;	</span><br><span class="line">	<span class="keyword">if</span> (dest == arr[middle]) &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;找到了指定的元素，位置为：&quot;</span> + middle);</span><br><span class="line">		isFlag = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[middle] &gt; dest1) &#123;</span><br><span class="line">		end = middle - <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;<span class="comment">//arr[middle] &lt; dest1</span></span><br><span class="line">		head = middle + <span class="number">1</span>;</span><br><span class="line">	&#125;			</span><br><span class="line">&#125;		</span><br><span class="line"><span class="keyword">if</span> (isFlag) &#123;</span><br><span class="line">	System.out.println(<span class="string">&quot;很遗憾，没有找到的啦！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>6）排序</strong></p>
<table>
<thead>
<tr>
<th align="center">排序算法</th>
<th align="center">平均时间复杂度</th>
<th align="center">最好情况</th>
<th align="center">最坏情况</th>
<th align="center">空间复杂度</th>
<th align="center">排序方式</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冒泡排序</td>
<td align="center">O(n^2^)</td>
<td align="center">O(n)</td>
<td align="center">O(n^2^)</td>
<td align="center">O(1)</td>
<td align="center">In-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">选择排序</td>
<td align="center">O(n^2^)</td>
<td align="center">O(n^2^)</td>
<td align="center">O(n^2^)</td>
<td align="center">O(1)</td>
<td align="center">In-place</td>
<td align="center">数组不稳定、链表稳定</td>
</tr>
<tr>
<td align="center">插入排序</td>
<td align="center">O(n^2^)</td>
<td align="center">O(n)</td>
<td align="center">O(n^2^)</td>
<td align="center">O(1)</td>
<td align="center">In-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">O(n log n)</td>
<td align="center">O(n log n)</td>
<td align="center">O(n^2^)</td>
<td align="center">O(log n)</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">O(n log n)</td>
<td align="center">O(n log n)</td>
<td align="center">O(n log<del>2</del>n)</td>
<td align="center">O(1)</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">O(n log n)</td>
<td align="center">O(n log n)</td>
<td align="center">O(n log<del>2</del>n)</td>
<td align="center">O(n)</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">O(n log n)</td>
<td align="center">O(n log^2^ n)</td>
<td align="center">O(n log^2^ n)</td>
<td align="center">O(1)</td>
<td align="center">In-place</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">计数排序</td>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">O(k)</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">桶排序</td>
<td align="center">O(n+k)</td>
<td align="center">O(n+k)</td>
<td align="center">O(n)</td>
<td align="center">O(n+k)</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">O(n×k)</td>
<td align="center">O(n×k)</td>
<td align="center">O(n×k)</td>
<td align="center">O(n+k)</td>
<td align="center">Out-place</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<p><strong>① 冒泡排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;			</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;			</span><br><span class="line">		<span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">			arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">			arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;			</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>② 快速排序</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span> <span class="params">(<span class="type">int</span>[] data, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> data[i];</span><br><span class="line">		data[i] = data[j];</span><br><span class="line">		data[j] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">subSort</span> <span class="params">(<span class="type">int</span>[] data, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line">			<span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> data[start];</span><br><span class="line">			<span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> start;</span><br><span class="line">			<span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> end + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">				<span class="keyword">while</span> (low &lt; end &amp;&amp; data[++low] - base &lt;= <span class="number">0</span>)&#123;&#125;</span><br><span class="line">				<span class="keyword">while</span> (high &gt; start &amp;&amp; data[--high] - base &gt;= <span class="number">0</span>)&#123;&#125;</span><br><span class="line">				<span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">					swap(data, low, high);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			swap(data, start, high);	</span><br><span class="line">			subSort(data, start, high - <span class="number">1</span>);<span class="comment">// 递归调用</span></span><br><span class="line">			subSort(data, high + <span class="number">1</span>, end);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;   </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] data)</span>&#123;</span><br><span class="line">		subSort(data,<span class="number">0</span>,data.length-<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-5-Arrays-工具类"><a href="#6-5-Arrays-工具类" class="headerlink" title="6.5 Arrays 工具类"></a>6.5 Arrays 工具类</h4><ul>
<li><p>Arrays 定义在 <code>java.util</code> 包下，提供了很多操作数组的方法</p>
</li>
<li><p>导包：<code>import java.util.Arrays;</code></p>
</li>
</ul>
<p>**1）equals()**：<code>boolean equals(int[] a,int[] b)</code>: 判断两个数组是否相等</p>
<p>**2）toString()**：<code>String toString(int[] a)</code>: 输出数组信息</p>
<p>**3）fill()**：<code>void fill(int[] a,int val)</code>: 将指定值填充到数组之中</p>
<p>**4）sort()**：<code>void sort(int[] a)</code>: 对数组进行排序</p>
<p>**5）binarySearch()**：<code>int binarySearch(int[] a,int key)</code>: 二分查找</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.boolean equals(int[] a,int[] b): 判断两个数组是否相等。</span></span><br><span class="line"><span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEquals</span> <span class="operator">=</span> Arrays.equals(arr1, arr2);</span><br><span class="line">System.out.println(isEquals);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.String toString(int[] a): 输出数组信息。</span></span><br><span class="line">System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.void fill(int[] a,int val): 将指定值填充到数组之中。</span></span><br><span class="line">Arrays.fill(arr1, <span class="number">10</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.void sort(int[] a): 对数组进行排序。</span></span><br><span class="line">Arrays.sort(arr2);</span><br><span class="line">System.out.println(Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.int binarySearch(int[] a,int key)</span></span><br><span class="line"><span class="type">int</span>[] arr3 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">98</span>, -<span class="number">34</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">54</span>, <span class="number">66</span>, <span class="number">79</span>, <span class="number">105</span>, <span class="number">210</span>, <span class="number">333</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr3, <span class="number">210</span>);</span><br><span class="line"><span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(index);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;未找到&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-6-数组的常见异常"><a href="#6-6-数组的常见异常" class="headerlink" title="6.6 数组的常见异常"></a>6.6 数组的常见异常</h4><p><strong>1）数组角标越界异常</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//System.out.println(arr[-2]);//ArrayIndexOutOfBoundsException</span></span><br></pre></td></tr></table></figure>

<p><strong>2）空指针异常</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一：</span></span><br><span class="line"><span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">arr1 = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// System.out.println(arr1[0]);// NullPointerExceptio</span></span><br><span class="line"><span class="comment">//情况二：</span></span><br><span class="line"><span class="type">int</span>[][] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][];</span><br><span class="line"><span class="comment">// System.out.println(arr2[0][0]);// NullPointerException</span></span><br></pre></td></tr></table></figure>

<h3 id="第7章-面向对象-（OOP）"><a href="#第7章-面向对象-（OOP）" class="headerlink" title="第7章 面向对象 （OOP）"></a>第7章 面向对象 （OOP）</h3><h4 id="7-1-类和对象"><a href="#7-1-类和对象" class="headerlink" title="7.1 类和对象"></a>7.1 类和对象</h4><p><strong>1）面向对象与面向过程</strong></p>
<ul>
<li><p>面向过程编程（Procedure Oriented Programming）：强调的是<strong>功能行为</strong>，以函数为最小单位，考虑<strong>怎么做</strong></p>
</li>
<li><p>面向对象编程（Object Oriented Programming）：强调具备了功能的<strong>对象</strong>，以类&#x2F;对象为最小单位，考虑<strong>谁来做</strong></p>
</li>
</ul>
<p><strong>2）面向对象的三大特征</strong>：封装（Encapsulation）、继承（Inheritance）、多态（Polymorphism）</p>
<p><strong>3）面向对象中两个重要的概念</strong></p>
<ul>
<li><p>类（Class）：对一类事物的描述，是抽象的、概念上的定义</p>
</li>
<li><p>对象（Object）：是实际存在的该类事物的每个个体，因而也称为实例（instance）</p>
</li>
</ul>
<p><strong>二者的关系</strong>：对象，是由类 new 出来的，派生出来的。</p>
<p><strong>“万事万物皆对象”</strong></p>
<ul>
<li><p>面向对象程序设计的重点是类的设计。设计类，就是设计类的成员</p>
</li>
<li><p>创建类的对象 &#x3D; 类的实例化 &#x3D; 实例化类</p>
</li>
<li><p><strong>匿名对象</strong>是指创建的对象，没显式的赋给一个变量名。匿名对象只能调用一次</p>
</li>
</ul>
<p><strong>4）类的成员</strong>：属性、方法、构造器；代码块、内部类</p>
<h4 id="7-2-类的属性（Field）"><a href="#7-2-类的属性（Field）" class="headerlink" title="7.2 类的属性（Field）"></a>7.2 类的属性（Field）</h4><p>对应类中的<strong>成员变量</strong>，属性 &#x3D; 成员变量 &#x3D; field &#x3D; 域、字段</p>
<p><strong>※ 属性与局部变量的对比</strong></p>
<p><strong>1）相同点</strong></p>
<ul>
<li><pre><code>    定义变量的**格式**：数据类型  变量名 = 变量值
</code></pre>
</li>
<li><pre><code>    先声明，后使用
</code></pre>
</li>
<li><pre><code>    变量都其对应的作用域
</code></pre>
</li>
</ul>
<p><strong>2）不同点</strong></p>
<p>① 在类中声明的位置的不同</p>
<ul>
<li><pre><code>    属性：直接定义在类的一对 &#123;&#125; 内
</code></pre>
</li>
<li><pre><code>    局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量
</code></pre>
</li>
</ul>
<p>② 关于权限修饰符的不同</p>
<ul>
<li><pre><code>    属性：可以在声明属性时，指明其权限，使用权限修饰符。
</code></pre>
<ul>
<li><pre><code>        常用的权限修饰符：private、public、缺省、protected  ---&gt; 封装性
</code></pre>
</li>
</ul>
</li>
<li><pre><code>    局部变量：不可以使用权限修饰符。
</code></pre>
</li>
</ul>
<p>③ 默认初始化值的情况：</p>
<ul>
<li><pre><code>    属性：类的属性，根据其类型，都默认初始化值。
</code></pre>
<ul>
<li><pre><code>        整型（byte、short、int、long：0）
</code></pre>
</li>
<li><pre><code>        浮点型（float、double：0.0）
</code></pre>
</li>
<li><pre><code>        字符型（char：0  （或&#39;\u0000&#39;））
</code></pre>
</li>
<li><pre><code>        布尔型（boolean：false）
</code></pre>
</li>
<li><pre><code>        引用数据类型（类、数组、接口：null）
</code></pre>
</li>
</ul>
</li>
<li><pre><code>    局部变量：没默认初始化值。
</code></pre>
<ul>
<li><pre><code>     意味着，在调用局部变量之前，一定要显式赋值。
</code></pre>
</li>
<li><pre><code>     特别地：形参在调用时，我们赋值即可。
</code></pre>
</li>
</ul>
</li>
</ul>
<p>④ 在内存中加载的位置：</p>
<ul>
<li><pre><code>    属性：加载到**堆**空间中（非static）
</code></pre>
</li>
<li><pre><code>    局部变量：加载到**栈**空间
</code></pre>
</li>
</ul>
<h4 id="7-3-类的方法（Method）"><a href="#7-3-类的方法（Method）" class="headerlink" title="7.3 类的方法（Method）"></a>7.3 类的方法（Method）</h4><p>描述类应该具的功能，方法 &#x3D; 成员方法 &#x3D; 函数 &#x3D; method</p>
<p><strong>方法的声明</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">	方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>1）权限修饰符</strong></p>
<ul>
<li><p>默认方法的权限修饰符先都使用 public</p>
</li>
<li><p>Java 规定的4种权限修饰符：private、public、缺省、protected（封装性再细说）</p>
</li>
</ul>
<p><strong>2）返回值类型</strong></p>
<ul>
<li><p>如果方法返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用 return 关键字来返回指定类型的变量或常量：“return 数据”。</p>
</li>
<li><p>如果方法没返回值，则方法声明时，使用 void 来表示。通常，没返回值的方法中，就不需要使用return.但是，如果使用的话，只能 “return;” 表示结束此方法的意思。</p>
</li>
</ul>
<p><strong>3）方法名</strong>：属于标识符，遵循标识符的规则和规范。（“见名知意”）</p>
<p>*<em>4） 形参列表</em>***：方法可以声明0个，1个，或多个形参。</p>
<ul>
<li><strong>格式</strong>：数据类型1 形参1, 数据类型2 形参2, …</li>
</ul>
<p>*<em>5）方法体</em>***：方法功能的体现。     </p>
<hr>
<p><strong>※ 方法的重载</strong></p>
<ul>
<li><p>在同一个类中，允许存在一个以上的<strong>同名方法</strong>，只要它们的参数个数或者参数类型不同即可</p>
</li>
<li><p><strong>“两同一不同”</strong></p>
<ol>
<li>同一个类、相同方法名</li>
<li>参数列表不同：参数个数不同，参数类型不同</li>
</ol>
</li>
<li><p>严格按照定义判断（两同一不同），跟方法的权限修饰符、返回值类型、形参变量名、方法体都没关系！</p>
</li>
</ul>
<p><strong>※ 可变个数形参的方法</strong></p>
<ol>
<li><p>可变个数形参的格式：数据类型 … 变量名</p>
</li>
<li><p>当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个，2个…</p>
</li>
<li><p>可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</p>
</li>
<li><p>可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存</p>
</li>
<li><p>可变个数形参在方法的形参中，必须声明在末尾</p>
</li>
<li><p>可变个数形参在方法的形参中，最多只能声明一个可变形参</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> 	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;show(String)&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String ... strs)</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;show(String ... strs)&quot;</span>);</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; strs.length;i++)&#123;</span><br><span class="line">			System.out.println(strs[i]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//不能与上一个方法同时存在</span></span><br><span class="line"><span class="comment">//	public void show(String[] strs)&#123;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//	&#125;</span></span><br></pre></td></tr></table></figure>

<p><strong>※ Java的值传递机制</strong></p>
<p>① 值传递规则</p>
<ul>
<li><p>如果变量是<strong>基本数据类型</strong>，此时赋值的是变量所保存的<strong>数据值</strong></p>
</li>
<li><p>如果变量是<strong>引用数据类型</strong>，此时赋值的是变量所保存的<strong>数据的地址值</strong></p>
</li>
</ul>
<p>② 形参和实参</p>
<ul>
<li><p>形参：方法定义时，声明的小括号内的参数</p>
</li>
<li><p>实参：方法调用时，实际传递给形参的数据</p>
</li>
</ul>
<p>③ Java 中参数传递机制：值传递</p>
<ul>
<li><p>如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值</p>
</li>
<li><p>如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值</p>
</li>
</ul>
<p><strong>※ 递归方法</strong>：一个方法体内调用自身</p>
<ul>
<li><p>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制</p>
</li>
<li><p>递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1：计算1-n之间所自然数的和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span> &#123;<span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n + getSum(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 例2：计算1-n之间所自然数的乘积:n!</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * getSum1(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;	</span><br><span class="line"><span class="comment">//例3：已知一个数列：f(0) = 1,f(1) = 4,f(n+2)=2*f(n+1) + f(n),</span></span><br><span class="line"><span class="comment">//其中n是大于0的整数，求f(10)的值。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//			return f(n + 2) - 2 * f(n + 1);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例4：斐波那契数列</span></span><br><span class="line"><span class="comment">//例5：汉诺塔问题</span></span><br><span class="line"><span class="comment">//例6：快排</span></span><br></pre></td></tr></table></figure>

<p><strong>※ 方法的重写</strong>（override 或 overwrite）：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作</p>
<ul>
<li>重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法</li>
<li>子类中的叫重写的方法，父类中的叫被重写的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符  返回值类型  方法名(形参列表) <span class="keyword">throws</span> 异常的类型&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>① 子类重写的方法的方法名和形参列表与父类被重写的方法的<strong>方法名和形参列表相同</strong></p>
<p>② 子类重写的方法的权限修饰符<strong>不小于</strong>父类被重写的方法的权限修饰符（特殊情况：子类不能重写父类中声明为 private 权限的方法）</p>
<p>③ 返回值类型</p>
<ul>
<li><p>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</p>
</li>
<li><p>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</p>
</li>
<li><p>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)</p>
</li>
</ul>
<p>④ 子类重写的方法抛出的异常类型<strong>不大于</strong>父类被重写的方法抛出的异常类型</p>
<p>⑤ 子类和父类中的同名同参数的方法要么都声明为非 static 的（考虑重写），要么都声明为 static 的（不是重写)。</p>
<hr>
<p><strong>面试题</strong></p>
<p><strong>区分方法的重写和重载？</strong>（① 二者的概念；② 重载和重写的具体规则；③ 重载：不表现为多态性；重写：表现为多态性。）</p>
<ul>
<li><strong>重载</strong>，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。所以，对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；而对于<strong>多态</strong>，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。 引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”</li>
</ul>
<h4 id="7-4-类的构造器（Constructor）"><a href="#7-4-类的构造器（Constructor）" class="headerlink" title="7.4 类的构造器（Constructor）"></a>7.4 类的构造器（Constructor）</h4><p>构造器（构造方法）的作用：① 创建对象；② 初始化对象的信息</p>
<ol>
<li><p>如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器</p>
</li>
<li><p>定义构造器的格式：<code>权限修饰符  类名(形参列表)&#123;&#125;</code></p>
</li>
<li><p>一个类中定义的多个构造器，彼此构成<strong>重载</strong></p>
</li>
<li><p>一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器</p>
</li>
<li><p>一个类中，至少会有一个构造器。</p>
</li>
</ol>
<p><strong>属性赋值的先后顺序</strong>：① 默认初始化；② 显式初始化；③ 构造器中初始化；④ 通过”对象.方法” 或 “对象.属性”的方式，赋值</p>
<p>所谓<strong>JavaBean</strong>，是指符合如下标准的 Java 类：① 类是公共的；② 一个无参的公共的构造器；③ 属性有对应的 get、set 方法</p>
<h4 id="7-5-封装性（Encapsulation）"><a href="#7-5-封装性（Encapsulation）" class="headerlink" title="7.5 封装性（Encapsulation）"></a>7.5 封装性（Encapsulation）</h4><p><strong>1）为什么要引入封装性？</strong></p>
<p>① 我们程序设计追求<strong>“高内聚，低耦合”</strong></p>
<ul>
<li><p>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉</p>
</li>
<li><p>低耦合 ：仅对外暴露少量的方法用于使用</p>
</li>
</ul>
<p>② 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想</p>
<p><strong>2）封装性思想具体的代码体现</strong></p>
<ul>
<li><p>体现一：将类的属性 xxx 私化（private），同时，提供公共的（public）方法来获取（getXxx）和设置（setXxx）此属性的值</p>
</li>
<li><p>体现二：不对外暴露的私有的方法</p>
</li>
<li><p>体现三：单例模式（将构造器私有化）</p>
</li>
<li><p>体现四：如果不希望类在包外被调用，可以将类设置为缺省的</p>
</li>
</ul>
<p><strong>3）Java 规定的四种权限修饰符</strong></p>
<p>① 权限从小到大顺序为：private &lt;  缺省 &lt; protected &lt; public</p>
<p>② 具体的修饰范围：</p>
<table>
<thead>
<tr>
<th align="center">修饰符</th>
<th align="center">类内部</th>
<th align="center">同一个包</th>
<th align="center">不同包的子类</th>
<th align="center">同一个工程</th>
</tr>
</thead>
<tbody><tr>
<td align="center">private</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">（缺省）</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">protected</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">public</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p>③ 权限修饰符可用来修饰的结构</p>
<ul>
<li>4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类</li>
<li>修饰类的话，只能使用：缺省、public</li>
</ul>
<h4 id="7-6-继承性（Inheritance）"><a href="#7-6-继承性（Inheritance）" class="headerlink" title="7.6 继承性（Inheritance）"></a>7.6 继承性（Inheritance）</h4><p><strong>1）为什么要有类的继承性（继承性的好处）</strong></p>
<ol>
<li><p>减少了代码的冗余，提高了代码的复用性</p>
</li>
<li><p>便于功能的扩展</p>
</li>
<li><p>为之后多态性的使用，提供了前提</p>
</li>
</ol>
<p><strong>2）继承性的格式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A:子类、派生类、subclass</span></span><br><span class="line"><span class="comment">// B:父类、超类、基类、superclass</span></span><br><span class="line"><span class="comment">// extends 关键字：延展、扩展</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3）子类继承父类以后有哪些不同？</strong></p>
<ul>
<li><p>体现：一旦子类 A 继承父类 B 以后，子类 A 中就获取了父类 B 中声明的<strong>所有的</strong>属性和方法</p>
</li>
<li><p>特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已</p>
</li>
<li><p>子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。子类和父类的关系，不同于子集和集合的关系。（extends：延展、扩展）</p>
</li>
</ul>
<p><strong>4）Java 中继承性的说明</strong></p>
<ol>
<li><p>一个类可以被多个子类继承</p>
</li>
<li><p>Java 中类的单继承性，即一个类只能有一个（直接）父类</p>
</li>
<li><p>子父类是相对的概念</p>
</li>
<li><p>子类直接继承的父类，称为：直接父类；间接继承的父类称为：间接父类</p>
</li>
<li><p>子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法</p>
</li>
</ol>
<p><strong>5）java.lang.Object 类的理解</strong></p>
<ol>
<li><p>如果我们没显式的声明一个类的父类的话，则此类继承于 java.lang.Object 类</p>
</li>
<li><p>所有的 Java 类（除 java.lang.Object 类之外）都直接或间接的继承于 java.lang.Object 类</p>
</li>
<li><p>意味着，所有的 Java 类具有 java.lang.Object 类声明的功能</p>
</li>
</ol>
<h4 id="7-7-多态性（Polymorphism）"><a href="#7-7-多态性（Polymorphism）" class="headerlink" title="7.7 多态性（Polymorphism）"></a>7.7 多态性（Polymorphism）</h4><p>多态性可以理解为一个事物的多种形态，对象的<strong>多态性</strong>就是指<strong>父类的引用指向子类的对象</strong>（或子类的对象赋给父类的引用）</p>
<p><strong>1）多态性的使用 – 虚拟方法调用</strong></p>
<ul>
<li><p>有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法</p>
</li>
<li><p>总结：编译，看左边；运行，看右边</p>
</li>
<li><p><strong>注意点</strong>：对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</p>
</li>
<li><p>多态是编译时行为还是运行时行为？答：运行时行为</p>
</li>
</ul>
<p><strong>2）多态性的使用前提</strong>：① 类的继承关系 ；② 方法的重写</p>
<p><strong>3）向上转型</strong>：多态</p>
<p><strong>4）向下转型</strong></p>
<p>① 为什么使用向下转型</p>
<ul>
<li>有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。使用向下转型才能调用子类特的属性和方法</li>
</ul>
<p>② 如何实现向下转型</p>
<ul>
<li>使用强制类型转换符：()</li>
</ul>
<p><strong>使用时的注意点：</strong></p>
<ol>
<li><p>使用强转时，可能出现 ClassCastException 的异常</p>
</li>
<li><p>为了避免在向下转型时出现 ClassCastException 的异常，我们在向下转型之前，先进行 instanceof 的判断，一旦返回 true，就进行向下转型。如果返回false，不进行向下转型</p>
</li>
</ol>
<p><strong>5）instanceof 的使用</strong></p>
<ul>
<li><p>a instanceof A：<strong>判断对象 a 是否是类 A 的实例</strong>。如果是，返回 true；如果不是，返回 false</p>
</li>
<li><p>如果 a instanceof A 返回 true，则 a instanceof B 也返回 true。其中，类 B 是类 A 的父类</p>
</li>
<li><p>要求 a 所属的类与类 A <strong>必须</strong>是子类和父类的关系，否则编译错误</p>
</li>
</ul>
<hr>
<p><strong>面试题</strong></p>
<p>谈谈你对多态性的理解？</p>
<ul>
<li><p>实现代码的通用性</p>
</li>
<li><p>Object 类中定义的<code>public boolean equals(Object obj)&#123;&#125;</code></p>
</li>
<li><p>JDBC：使用java程序操作(获取数据库连接、CRUD)数据库(MySQL、Oracle、DB2、SQL Server)</p>
</li>
<li><p>抽象类、接口的使用肯定体现了多态性。（抽象类、接口不能实例化）</p>
</li>
</ul>
<h4 id="7-8-Object-类的使用"><a href="#7-8-Object-类的使用" class="headerlink" title="7.8 Object 类的使用"></a>7.8 Object 类的使用</h4><p><strong>1）java.lang.Object 类的说明</strong></p>
<ol>
<li><p>Object 类是所有 Java 类的根父类</p>
</li>
<li><p>如果在类的声明中未使用 extends 关键字指明其父类，则默认父类为 java.lang.Object 类 </p>
</li>
<li><p>Object 类中的功能（属性、方法）就具通用性</p>
<ul>
<li><strong>属性</strong>：无</li>
<li><strong>方法</strong>：equals()、toString() 、getClass()、hashCode() 、clone()、finalize()；wait() 、 notify()、notifyAll()</li>
</ul>
</li>
<li><p>Object类只声明了一个空参的构造器</p>
</li>
</ol>
<p><strong>2）equals() 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Object 类中 equals() 的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">	<span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同。即两个引用是否指向同一个对象实体</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>equals() 是一个方法，而非运算符</p>
</li>
<li><p>只能适用于引用数据类型</p>
</li>
<li><p>像 String、Date、File、包装类等都重写了 Object 类中的 equals() 方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同</p>
</li>
<li><p>通常情况下，我们自定义的类如果使用 equals() 的话，也通常是比较两个对象的”实体内容”是否相同。那么，我们就需要对 Object 类中的 equals() 进行重（重写的原则：比较两个对象的实体内容是否相同）</p>
</li>
</ul>
<p>**如何重写equals()**：开发中自动生成的</p>
<p><strong>回顾 &#x3D;&#x3D; 运算符的使用：</strong></p>
<ol>
<li><p>可以使用在基本数据类型变量和引用数据类型变量中</p>
</li>
<li><p>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）</p>
<p>如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</p>
<p><strong>注意： &#x3D;&#x3D; 符号使用时，必须保证符号左右两边的变量类型一致</strong></p>
</li>
</ol>
<p><strong>3）toString() 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object 类中 toString() 的定义</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>当我们输出一个对象的引用时，实际上就是调用当前对象的 toString() </li>
<li>像 String、Date、File、包装类等都重写了 Object 类中的 toString() 方法， 使得在调用对象的 toString() 时，返回”实体内容”信息</li>
<li>自定义类也可以重写 toString()方 法，当调用此方法时，返回对象的”实体内容”</li>
</ul>
<p>**如何重写toString()**：开发中如何实现：自动生成的</p>
<h4 id="7-9-代码块和内部类"><a href="#7-9-代码块和内部类" class="headerlink" title="7.9 代码块和内部类"></a>7.9 代码块和内部类</h4><p><strong>1）代码块</strong></p>
<ul>
<li><strong>作用</strong>：用来初始化类、对象的信息</li>
<li><strong>分类</strong>：代码块要是使用修饰符，只能使用 static，所以分为<strong>静态代码块</strong>和<strong>非静态代码块</strong></li>
</ul>
<p><strong>静态代码块</strong></p>
<ul>
<li><p>内部可以有输出语句</p>
</li>
<li><p>随着类的加载而执行,而且只执行一次</p>
</li>
<li><p>作用：初始化类的信息</p>
</li>
<li><p>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</p>
</li>
<li><p><em>静态代码块的执行要优先于非静态代码块的执行</em></p>
</li>
<li><p><em>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</em></p>
</li>
</ul>
<p><strong>非静态代码块</strong></p>
<ul>
<li><p>内部可以有输出语句</p>
</li>
<li><p>随着对象的创建而执行</p>
</li>
<li><p>每创建一个对象，就执行一次非静态代码块</p>
</li>
<li><p>作用：可以在创建对象时，对对象的属性等进行初始化</p>
</li>
<li><p>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</p>
</li>
<li><p>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</p>
</li>
</ul>
<p>实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序：<strong>由父及子，静态先行</strong></p>
<p>执行的先后顺序：①默认初始化；②显式初始化&#x2F;⑤在代码块中赋值；③构造器中初始化；④有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值；</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Root</span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Root</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Root的无参数的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mid</span> <span class="keyword">extends</span> <span class="title class_">Root</span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Mid</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的无参数的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Mid</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>();</span><br><span class="line">		System.out.println(<span class="string">&quot;Mid的带参数构造器，其参数值：&quot;</span></span><br><span class="line">			+ msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Mid</span>&#123;</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的静态初始化块&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的普通初始化块&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">Leaf</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;Leaf的构造器&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeafTest</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Leaf</span>(); </span><br><span class="line">		System.out.println(<span class="string">&quot;================================&quot;</span>);</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Leaf</span>();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Root的静态初始化块</span><br><span class="line">Mid的静态初始化块</span><br><span class="line">Leaf的静态初始化块</span><br><span class="line">Root的普通初始化块</span><br><span class="line">Root的无参数的构造器</span><br><span class="line">Mid的普通初始化块</span><br><span class="line">Mid的无参数的构造器</span><br><span class="line">Mid的带参数构造器，其参数值：尚硅谷</span><br><span class="line">Leaf的普通初始化块</span><br><span class="line">Leaf的构造器</span><br><span class="line">================================</span><br><span class="line">Root的普通初始化块</span><br><span class="line">Root的无参数的构造器</span><br><span class="line">Mid的普通初始化块</span><br><span class="line">Mid的无参数的构造器</span><br><span class="line">Mid的带参数构造器，其参数值：尚硅谷</span><br><span class="line">Leaf的普通初始化块</span><br><span class="line">Leaf的构造器</span><br></pre></td></tr></table></figure>

<p><strong>2）内部类</strong></p>
<ul>
<li><p><strong>定义</strong>：Java 中允许将一个类 A 声明在另一个类 B 中，则类 A 就是<strong>内部类</strong>，类 B 称为<strong>外部类</strong>。</p>
</li>
<li><p><strong>分类</strong>：<strong>成员内部类</strong>（静态、非静态 ）和 <strong>局部内部类</strong>(方法内、代码块内、构造器内)。</p>
</li>
<li><p>一方面，作为<strong>外部类的成员</strong>：① 调用外部类的结构；② 可以被 static 修饰；③ 可以被 4 种不同的权限修饰。另一方面，作为<strong>一个类</strong>：① 类内可以定义属性、方法、构造器等；② 可以被 final 修饰，表示此类不能被继承。言外之意，不使用 final，就可以被继承；③ 可以被 abstract 修饰。</p>
</li>
</ul>
<p><strong>成员内部类</strong></p>
<p>① 如何创建成员内部类的对象？(静态的 &amp; 非静态的)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建静态的 Dog 内部类的实例（静态的成员内部类）</span></span><br><span class="line">Person.<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>.Dog();</span><br><span class="line"><span class="comment">// 创建非静态的 Bird 内部类的实例（非静态的成员内部类）</span></span><br><span class="line"><span class="comment">// Person.Bird bird = new Person.Bird();//错误的</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">Person.<span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> p.<span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br></pre></td></tr></table></figure>

<p>② 如何在成员内部类中调用外部类的结构？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">	<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小明&quot;</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">	<span class="comment">// 非静态成员内部类</span></span><br><span class="line">	<span class="keyword">class</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;杜鹃&quot;</span>;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String name)</span>&#123;</span><br><span class="line">			System.out.println(name);<span class="comment">// 方法的形参</span></span><br><span class="line">			System.out.println(<span class="built_in">this</span>.name);<span class="comment">// 内部类的属性</span></span><br><span class="line">			System.out.println(Person.<span class="built_in">this</span>.name);<span class="comment">// 外部类的属性</span></span><br><span class="line">		<span class="comment">// Person.this.eat();</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>局部内部类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个实现了Comparable 接口的类的对象</span></span><br><span class="line"><span class="keyword">public</span> Comparable <span class="title function_">getComparable</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个实现了Comparable接口的类:局部内部类</span></span><br><span class="line">    <span class="comment">// 方式一：</span></span><br><span class="line">    <span class="comment">//		class MyComparable implements Comparable&#123;</span></span><br><span class="line">    <span class="comment">//			@Override</span></span><br><span class="line">    <span class="comment">//			public int compareTo(Object o) &#123;</span></span><br><span class="line">    <span class="comment">//				return 0;</span></span><br><span class="line">    <span class="comment">//			&#125;			</span></span><br><span class="line">    <span class="comment">//		&#125;		</span></span><br><span class="line">    <span class="comment">//		return new MyComparable();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二：</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Comparable</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;	</span><br><span class="line">    &#125;;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>注意</strong>：在局部内部类的<strong>方法</strong>中如果调用局部内部类所声明的<strong>方法</strong>中的<strong>局部变量</strong>的话，要求此局部变量声明为 final 的。</p>
<ul>
<li>jdk 7 及之前版本：要求此局部变量显式的声明为 final 的</li>
<li>jdk 8 及之后的版本：可以省略 final 的声明</li>
</ul>
<p><strong>总结</strong>：成员内部类和局部内部类，在编译以后，都会生成字节码文件</p>
<p><strong>格式</strong></p>
<ul>
<li><code>成员内部类：外部类$内部类名.class</code></li>
<li><code>局部内部类：外部类$数字 内部类名.class</code></li>
</ul>
<h4 id="7-9-关键字"><a href="#7-9-关键字" class="headerlink" title="7.9 关键字"></a>7.9 关键字</h4><h5 id="7-9-1-return"><a href="#7-9-1-return" class="headerlink" title="7.9.1 return"></a>7.9.1 return</h5><ul>
<li><p>使用范围：使用在方法体中</p>
</li>
<li><p>作用：</p>
<ul>
<li>结束方法</li>
<li>针对于返回值类型的方法，使用”return 数据”方法返回所要的数据</li>
</ul>
</li>
<li><p><strong>注意</strong>：return 关键字后面不可以声明执行语句</p>
</li>
</ul>
<h5 id="7-9-2-this"><a href="#7-9-2-this" class="headerlink" title="7.9.2 this"></a>7.9.2 this</h5><ul>
<li><p>this 理解为：<strong>当前对象</strong> 或 <strong>当前正在创建的对象</strong></p>
</li>
<li><p>可以调用的结构：属性、方法；构造器</p>
</li>
</ul>
<p><strong>this 调用属性、方法：</strong></p>
<ul>
<li>在类的方法中，我们可以使用<code>this.属性</code>或<code>this.方法</code>的方式，调用<strong>当前对象</strong>属性或方法。但是，通常情况下，我们都择省略<code>this.</code>。</li>
<li>特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用<code>this.变量</code>的方式，表明此变量是属性，而非形参</li>
</ul>
<p><strong>this 调用构造器：</strong></p>
<ul>
<li>在类的构造器中，我们可以使用<code>this.属性</code>或<code>this.方法</code>的方式，调用当前<strong>正在创建的对象</strong>属性或方法。但是，通常情况下，我们都择省略<code>this.</code>。</li>
<li>特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用<code>this.变量</code>的方式，表明此变量是属性，而非形参</li>
</ul>
<p><strong>※ 注意</strong></p>
<ul>
<li><p>我们在类的构造器中，可以显式的使用”this(形参列表)”方式，调用本类中指定的其他构造器</p>
</li>
<li><p>构造器中不能通过<code>this(形参列表)</code>方式调用自己</p>
</li>
<li><p>如果一个类中有n个构造器，则最多有 n - 1构造器中使用了<code>this(形参列表)</code></p>
</li>
<li><p>规定：<code>this(形参列表)</code>必须声明在当前构造器的<strong>首行</strong></p>
</li>
<li><p>构造器内部，<strong>最多只能声明一个</strong><code>this(形参列表)</code>，用来调用其他的构造器</p>
</li>
</ul>
<h5 id="7-9-3-package"><a href="#7-9-3-package" class="headerlink" title="7.9.3 package"></a>7.9.3 package</h5><ul>
<li><p>为了更好的实现项目中类的管理，提供包的概念</p>
</li>
<li><p>使用 package 声明类或接口所属的包，声明在源文件的首行</p>
</li>
<li><p>包，属于标识符，遵循标识符的命名规则、规范（xxxyyyzzz）、“见名知意”</p>
</li>
<li><p>每”.”一次，就代表一层文件目录。</p>
</li>
</ul>
<p><strong>举例：MVC设计模式</strong></p>
<p><img src="/.io//MVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" alt="MVC设计模式"></p>
<p><strong>JDK中的主要包介绍</strong></p>
<ol>
<li>java.lang：包含一些 Java 语言的核心类，如 String、Math、Integer、System 和 Thread，提供常用功能</li>
<li>java.net：包含执行与网络相关的操作的类和接口</li>
<li>java.io：包含能提供多种输入&#x2F;输出功能的类</li>
<li>java.uti：包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。</li>
<li>java.text：包含了一些java格式化相关的类</li>
<li>java.sql：包含了 Java 进行 JDBC 数据库编程的相关类&#x2F;接口</li>
<li>java.awt：包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面（GUl）</li>
</ol>
<h5 id="7-9-4-import"><a href="#7-9-4-import" class="headerlink" title="7.9.4 import"></a>7.9.4 import</h5><ul>
<li><p>在源文件中显式的使用 import 结构导入指定包下的类、接口</p>
</li>
<li><p>声明在包的声明和类的声明之间</p>
</li>
<li><p>如果需要导入多个结构，则并列写出即可</p>
</li>
<li><p>可以使用 “xxx.*” 的方式，表示可以导入 xxx 包下的所结构</p>
</li>
<li><p>如果使用的类或接口是 java.lang 包下定义的，则可以省略 import 结构</p>
</li>
<li><p>如果使用的类或接口是本包下定义的，则可以省略import结构</p>
</li>
<li><p>如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示。</p>
</li>
<li><p>使用 “xxx.*” 方式表明可以调用 xxx 包下的所有结构。但是如果使用的是 xxx 子包下的结构，则仍需要显式导入</p>
</li>
<li><p><code>import static</code>：导入指定类或接口中的静态结构（属性或方法）</p>
</li>
</ul>
<h5 id="7-9-5-super"><a href="#7-9-5-super" class="headerlink" title="7.9.5 super"></a>7.9.5 super</h5><ul>
<li><p>super 关键字可以理解为：父类的</p>
</li>
<li><p><strong>可以用来调用的结构</strong>：属性、方法、构造器</p>
</li>
</ul>
<p><strong>super 调用属性、方法</strong></p>
<ul>
<li><p>我们可以在子类的方法或构造器中。通过使用”super.属性”或”super.方法”的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略”super.”</p>
</li>
<li><p>特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性</p>
</li>
<li><p>特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”super.方法”的方式，表明调用的是父类中被重写的方法</p>
</li>
</ul>
<p><strong>super 调用构造器</strong></p>
<ul>
<li><p>我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器</p>
</li>
<li><p>“super(形参列表)”的使用，必须声明在子类构造器的首行！</p>
</li>
<li><p>我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二选一，不能同时出现</p>
</li>
<li><p>在构造器的首行，没显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器：super()</p>
</li>
<li><p>在类的多个构造器中，至少一个类的构造器中使用了”super(形参列表)”，调用父类中的构造器</p>
</li>
</ul>
<p><strong>子类对象实例化全过程</strong></p>
<p>1）从结果上看：继承性</p>
<ul>
<li>子类继承父类以后，就获取了父类中声明的属性或方法。创建子类的对象，在堆空间中，就会加载所父类中声明的属性</li>
</ul>
<p>2）从过程上看</p>
<p>当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，……，直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑进行调用</p>
<blockquote>
<p>强调说明：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。</p>
</blockquote>
<h5 id="7-9-6-static"><a href="#7-9-6-static" class="headerlink" title="7.9.6 static"></a>7.9.6 static</h5><p><strong>可以用来修饰的结构</strong>：主要用来修饰类的内部结构（属性、方法、代码块、内部类）</p>
<p><strong>※ 属性</strong>按是否使用 static 修饰可分为： <strong>静态属性（类变量）</strong> 和<strong>非静态属性（实例变量）</strong></p>
<ul>
<li>类变量：我们创建了类的多个对象，多个对象共享同一个类变量。当通过某一个对象修改类变量时，会导致其他对象调用此类变量时，是修改过了的</li>
<li>实例变量：我们创建了类的多个对象，每个对象都独立的拥一套类中的实例变量。当修改其中一个对象中的实例变量时，不会导致其他对象中同样的实例变量的修改。</li>
</ul>
<hr>
<ul>
<li><p>静态属性随着类的加载而加载。可以通过”类.静态属性”的方式进行调用</p>
</li>
<li><p>静态属性的加载要早于对象的创建</p>
</li>
<li><p>由于类只会加载一次，则静态属性在内存中也只会存在一份：存在方法区的静态域中</p>
</li>
<li><p>静态属性举例：System.out; Math.PI;</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">类变量</th>
<th align="center">实例变量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">对象</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p><strong>※ 静态方法（类方法）和非静态方法</strong></p>
<ul>
<li><p>静态方法随着类的加载而加载，可以通过”类.静态方法”的方式进行调用</p>
</li>
<li><p>静态方法中，只能调用静态的方法或属性</p>
</li>
<li><p>非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</p>
</li>
</ul>
<hr>
<ul>
<li>在静态的方法内，不能使用 this 关键字、super 关键字</li>
<li>关于静态属性和静态方法的使用，大家都从生命周期的角度去理解</li>
</ul>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">静态方法</th>
<th align="center">非静态方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类</td>
<td align="center">√</td>
<td align="center">×</td>
</tr>
<tr>
<td align="center">对象</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
</tbody></table>
<p><strong>如何判定属性和方法是否应该使用 static 关键字</strong></p>
<p>① 关于属性</p>
<ul>
<li><p>属性是可以被多个对象所共享的，不会随着对象的不同而不同的</p>
</li>
<li><p>类中的常量也常常声明为 static</p>
</li>
</ul>
<p>② 关于方法</p>
<ul>
<li><p>操作静态属性的方法，通常设置为 static 的</p>
</li>
<li><p>工具类中的方法，习惯上声明为 static 的。 比如：Math、Arrays、Collections</p>
</li>
</ul>
<p><strong>使用举例</strong></p>
<ul>
<li><p>举例一：Arrays、Math、Collections 等工具类</p>
</li>
<li><p>举例二：单例模式</p>
</li>
</ul>
<h5 id="7-9-7-final"><a href="#7-9-7-final" class="headerlink" title="7.9.7 final"></a>7.9.7 final</h5><p><strong>可以用来修饰结构</strong>：类、方法、变量</p>
<p><strong>final 用来修饰一个类</strong>：此类不能被其他类所继承。</p>
<ul>
<li>比如：String类、System类、StringBuffer类</li>
</ul>
<p><strong>final 用来修饰方法</strong>：表明此方法不可以被重写</p>
<ul>
<li>比如：Object 类中getClass();</li>
</ul>
<p><strong>final 用来修饰变量</strong>：此时的”变量”就称为是一个常量</p>
<ul>
<li><p>final 修饰属性：必须被赋值，可以考虑赋值的位置有显式初始化、代码块中初始化、构造器中初始化</p>
</li>
<li><p>final 修饰局部变量：尤其是使用 final 修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</p>
</li>
<li><p>static final 用来修饰属性：全局常量</p>
</li>
</ul>
<h5 id="7-9-8-abstract"><a href="#7-9-8-abstract" class="headerlink" title="7.9.8 abstract"></a>7.9.8 abstract</h5><p><strong>可以用来修饰结构</strong>：类、方法</p>
<p><strong>abstract修饰类：抽象类</strong></p>
<ul>
<li><p>此类<strong>不能实例化</strong></p>
</li>
<li><p>抽象类中<strong>一定有构造器</strong>，便于子类实例化时调用（涉及：子类对象实例化的全过程）</p>
</li>
<li><p>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作（抽象类的使用前提：继承性）</p>
</li>
</ul>
<p><strong>abstract修饰方法：抽象方法</strong></p>
<ul>
<li><p>抽象方法只有方法的声明，没方法体</p>
</li>
<li><p>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</p>
</li>
<li><p>若子类重写了父类中的所的抽象方法后，此子类方可实例化</p>
</li>
<li><p>若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</p>
</li>
</ul>
<p><strong>注意点</strong></p>
<ul>
<li><p>abstract 不能用来修饰：属性、构造器等结构</p>
</li>
<li><p>abstract 不能用来修饰私有方法、静态方法、final 的方法、final 的类</p>
</li>
</ul>
<h5 id="7-9-9-interface"><a href="#7-9-9-interface" class="headerlink" title="7.9.9 interface"></a>7.9.9 interface</h5><ul>
<li><p>接口使用 <code>interface</code> 来定义</p>
</li>
<li><p>Java中，接口和类是<strong>并列</strong>的两个结构</p>
</li>
</ul>
<p>如何<strong>定义接口</strong>：定义接口中的成员</p>
<ol>
<li>JDK 7及以前：只能定义全局常量和抽象方法<ul>
<li>全局常量：public static final 的。但是书写时，可以省略不写</li>
<li>抽象方法：public abstract 的</li>
</ul>
</li>
<li>JDK 8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略）</li>
</ol>
<hr>
<ol>
<li><p>接口中不能定义构造器的！意味着接口不可以实例化</p>
</li>
<li><p>Java 开发中，接口通过让类去实现（implements）的方式来使用</p>
<ul>
<li>如果实现类覆盖了接口中的所抽象方法，则此实现类就可以实例化</li>
<li>如果实现类没覆盖接口中所的抽象方法，则此实现类仍为一个抽象类</li>
</ul>
</li>
<li><p>Java类可以实现多个接口（弥补了Java单继承性的局限性）</p>
<ul>
<li>格式：<code>class AA extends BB implements CC,DD,EE</code></li>
</ul>
</li>
<li><p>接口与接口之间可以继承，而且可以多继承</p>
</li>
<li><p>接口的具体使用，体现多态性</p>
</li>
<li><p>接口，实际上可以看做是一种规范</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferData</span><span class="params">(USB usb)</span>&#123;<span class="comment">//USB usb = new Flash();</span></span><br><span class="line">		usb.start();		</span><br><span class="line">		System.out.println(<span class="string">&quot;具体传输数据的细节&quot;</span>);		</span><br><span class="line">		usb.stop();</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span>&#123;</span><br><span class="line">	<span class="comment">//常量：定义了长、宽、最大最小的传输速度等	</span></span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line">	<span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flash</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;U盘开启工作&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;U盘结束工作&quot;</span>);</span><br><span class="line">	&#125;	</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;打印机开启工作&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;打印机结束工作&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>接口使用上也满足多态性</p>
</li>
<li><p>接口，实际上就是定义了一种规范</p>
</li>
<li><p>开发中，体会面向接口编程！</p>
</li>
</ul>
<p><img src="/.io//%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B.png" alt="image-20200910163721358"></p>
<p>​                                                    我们在应用程序中，调用的结构都是 JDBC 中定义的接口，不会出现具体某一个数据库厂商的 API</p>
<p><strong>Java8 中关于接口的新规范</strong></p>
<ol>
<li><p>接口中定义的静态方法，只能通过接口来调用</p>
</li>
<li><p>通过实现类的对象，可以调用接口中的默认方法</p>
<ul>
<li>如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</li>
</ul>
</li>
<li><p>如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。（<strong>类优先原则</strong>）</p>
</li>
<li><p>如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么在实现类没重写此方法的情况下，报错。（ <strong>接口冲突</strong>）这就需要我们必须在实现类中重写此方法</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在子类（或实现类）的方法中调用父类、接口中被重写的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>&#123;</span><br><span class="line">    method3();<span class="comment">//调用自己定义的重写的方法</span></span><br><span class="line">    <span class="built_in">super</span>.method3();<span class="comment">//调用的是父类中声明的</span></span><br><span class="line">    <span class="comment">//调用接口中的默认方法</span></span><br><span class="line">    CompareA.<span class="built_in">super</span>.method3();</span><br><span class="line">    CompareB.<span class="built_in">super</span>.method3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>面试题</strong></p>
<p>抽象类和接口的异同？</p>
<ul>
<li><p>相同点：不能实例化；都可以包含抽象方法的</p>
</li>
<li><p>不同点：</p>
<ul>
<li>把抽象类和接口（Java7，Java8，Java9）的定义、内部结构解释说明</li>
<li>类：单继承性    接口：多继承      类与接口：多实现</li>
</ul>
</li>
</ul>
<h4 id="7-10-其他"><a href="#7-10-其他" class="headerlink" title="7.10 其他"></a>7.10 其他</h4><p><strong>1）Java 中的 JUnit 单元测试</strong></p>
<ol>
<li><p>在当前工程 - 右键选择：build path - add libraries - JUnit 4 - 下一步</p>
</li>
<li><p>创建 Java 类，进行单元测试。</p>
<ul>
<li>此时的 Java 类要求：① 此类是 public 的  ② 此类提供公共的无参的构造器</li>
</ul>
</li>
<li><p>此类中声明单元测试方法</p>
<ul>
<li>此时的单元测试方法：方法的权限是 public，没返回值，没形参</li>
</ul>
</li>
<li><p>此单元测试方法上需要声明注解：@Test，并在单元测试类中导入：import org.junit.Test;</p>
</li>
<li><p>声明好单元测试方法以后，就可以在方法体内测试相关的代码。</p>
</li>
<li><p>写完代码以后，左键双击单元测试方法名，右键：run as - JUnit Test</p>
</li>
</ol>
<hr>
<ul>
<li>如果执行结果没任何异常：绿条</li>
<li>如果执行结果出现异常：红条</li>
</ul>
<p><strong>2）包装类的使用</strong></p>
<ul>
<li>为了使基本数据类型的变量具有类的特征，引入包装类。</li>
</ul>
<table>
<thead>
<tr>
<th align="center">基本数据类型</th>
<th align="center">包装类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center"><strong>int</strong></td>
<td align="center"><strong>Integer</strong></td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
<tr>
<td align="center"><strong>char</strong></td>
<td align="center"><strong>Character</strong></td>
</tr>
</tbody></table>
<ul>
<li>Number 类为 Byte、Short、Integer、Long、Float、Double 类的父类</li>
</ul>
<p><strong>基本数据类型、包装类、String 类型间的转换</strong></p>
<p><img src="/.io//%E7%B1%BB%E5%9E%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png" alt="类型间的转换"></p>
<ul>
<li><code>基本数据类型&lt;---&gt;包装类</code>：JDK 5.0 新特性：自动装箱 与 自动拆箱</li>
<li><code>基本数据类型、包装类 --&gt; String</code>：调用 String 重载的 valueOf(Xxx xxx)</li>
<li><code>String --&gt; 基本数据类型、包装类</code>：调用包装类的 parseXxx(String s)</li>
<li><strong>注意</strong>：转换时，可能会报 NumberFormatException</li>
</ul>
<p><strong>2）设计模式</strong>（这里介绍了单例模式、模板方法模式、代理模式和工厂模式）</p>
<ul>
<li><strong>设计模式</strong>是<strong>在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式</strong> 。 设计模免去我们自己再思考和摸索 。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。“套路”</li>
<li><strong>常用的设计模式</strong><ul>
<li><strong>创建型模式</strong>，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式</li>
<li><strong>结构型模式</strong>，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式</li>
<li><strong>行为型模式</strong>，共11种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</li>
</ul>
</li>
</ul>
<p><strong>① 单例模式</strong>：所谓<strong>类的单例设计模式</strong>，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line">	<span class="comment">//1.私化类的构造器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;	</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//2.内部创建类的对象</span></span><br><span class="line">	<span class="comment">//4.要求此对象也必须声明为静态的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();	</span><br><span class="line">	<span class="comment">//3.提供公共的静态的方法，返回类的对象</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式2：使用了静态代码块</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line">	<span class="comment">//1.私化类的构造器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Order</span><span class="params">()</span>&#123;		</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line">	<span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Order</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;	</span><br><span class="line">	<span class="keyword">static</span>&#123;</span><br><span class="line">		instance = <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line"> &#125;</span><br><span class="line">	<span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line">	<span class="comment">//1.私化类的构造器</span></span><br><span class="line">	<span class="keyword">private</span> <span class="title function_">Order</span><span class="params">()</span>&#123;</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line">	<span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Order</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">	<span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title function_">getInstance</span><span class="params">()</span>&#123;		</span><br><span class="line">		<span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;			</span><br><span class="line">			instance = <span class="keyword">new</span> <span class="title class_">Order</span>();		</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> instance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>两种方式的对比</strong></p>
<ul>
<li>饿汉式    <ul>
<li>坏处：对象加载时间过长。</li>
<li>好处：饿汉式是线程安全的</li>
</ul>
</li>
<li>懒汉式<ul>
<li>好处：延迟对象的创建。</li>
<li>目前的写法坏处：线程不安全。—&gt;到多线程内容时，再修改</li>
</ul>
</li>
</ul>
<p><strong>② 模板方法模式</strong>：在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span>&#123;</span><br><span class="line">	<span class="comment">// 计算某段代码执行所需要花费的时间</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">spendTime</span><span class="params">()</span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();		</span><br><span class="line">		<span class="built_in">this</span>.code();<span class="comment">// 不确定的部分、易变的部分		</span></span><br><span class="line">		<span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">		</span><br><span class="line">		System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubTemplate</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= <span class="number">1000</span>;i++)&#123;</span><br><span class="line">			<span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">			<span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;j &lt;= Math.sqrt(i);j++)&#123;				</span><br><span class="line">				<span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">					isFlag = <span class="literal">false</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">				System.out.println(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong> – 模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有：</p>
<ul>
<li><p>数据库访问的封装</p>
</li>
<li><p>Junit 单元测试</p>
</li>
<li><p>JavaWeb 的 Servlet 中关于 doGet&#x2F;doPost 方法调用</p>
</li>
<li><p>Hibernate 中模板程序</p>
</li>
<li><p>Spring 中 JDBCTemlate、Hibernate Template 等</p>
</li>
</ul>
<p><strong>③ 代理模式</strong>是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">NetWork</span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> <span class="keyword">implements</span> <span class="title class_">NetWork</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;真实的服务器访问网络&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyServer</span> <span class="keyword">implements</span> <span class="title class_">NetWork</span>&#123;	</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> NetWork work;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">ProxyServer</span><span class="params">(NetWork work)</span>&#123;</span><br><span class="line">		<span class="built_in">this</span>.work = work;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;联网之前的检查工作&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span> &#123;</span><br><span class="line">		check();</span><br><span class="line">		</span><br><span class="line">		work.browse();		</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>应用场景</strong></p>
<ul>
<li><p>安全代理：屏蔽对真实角色的直接访问</p>
</li>
<li><p>远程代理：通过代理类处理远程方法调用（RMl）</p>
</li>
<li><p>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</p>
</li>
<li><p>比如：你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有 100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用 proxy 来进行大图片的打开。</p>
</li>
</ul>
<p><strong>分类</strong></p>
<ul>
<li><p>静态代理（静态定义代理类）</p>
</li>
<li><p>动态代理（动态生成代理类），JDK 自带的动态代理，需要反射等知识</p>
</li>
</ul>
<p><strong>④ 工厂模式</strong>：实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的</p>
<ul>
<li>简单工厂模式：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）</li>
<li>工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品)</li>
<li>抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族)</li>
</ul>
<h3 id="第8章-异常处理"><a href="#第8章-异常处理" class="headerlink" title="第8章 异常处理"></a>第8章 异常处理</h3><p><strong>知识点</strong>：异常的体系结构、异常处理、手动抛出异常、自定义异常类</p>
<h4 id="8-1-异常的体系结构"><a href="#8-1-异常的体系结构" class="headerlink" title="8.1 异常的体系结构"></a>8.1 异常的体系结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Throwable</span><br><span class="line"> 	|-----java.lang.Error: 一般不编写针对性的代码进行处理</span><br><span class="line"> 	|-----java.lang.Exception: 可以进行异常的处理</span><br><span class="line">		|------编译时异常(checked)</span><br><span class="line">		|------运行时异常(unchecked, RuntimeException)</span><br></pre></td></tr></table></figure>

<p><strong>1）分类</strong></p>
<p>从程序执行过程看分为<strong>编译时异常</strong>和<strong>运行时异常</strong></p>
<ul>
<li><p>编译时异常：执行<code>javac.exe</code>命名时，可能出现的异常</p>
</li>
<li><p>运行时异常：执行<code>java.exe</code>命名时，出现的异常</p>
</li>
</ul>
<p><strong>2）常见的异常类型</strong></p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NullPointerException 空指针异常</span><br><span class="line">ArrayIndexOutOfBoundsException 数组角标越界异常</span><br><span class="line">ClassCastException 类型转换异常</span><br><span class="line">NumberFormatException 数字格式异常</span><br><span class="line">InputMismatchException 输入类型不匹配异常</span><br><span class="line">ArithmeticException 算数异常</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常见的异常类型，请举例说明：</span></span><br><span class="line"><span class="comment">//******************以下是运行时异常***************************</span></span><br><span class="line">	<span class="comment">// ArithmeticException</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">		System.out.println(a / b);</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">// InputMismatchException</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line">		<span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">		System.out.println(score);</span><br><span class="line">		</span><br><span class="line">		scanner.close();</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//NumberFormatException</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">		str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">		<span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);		</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//ClassCastException</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)obj;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">		<span class="comment">//ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">//		int[] arr = new int[10];</span></span><br><span class="line"><span class="comment">//		System.out.println(arr[10]);</span></span><br><span class="line">		<span class="comment">//StringIndexOutOfBoundsException</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">		System.out.println(str.charAt(<span class="number">3</span>));</span><br><span class="line">	&#125;	</span><br><span class="line">	<span class="comment">//NullPointerException</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">		</span><br><span class="line"><span class="comment">//		int[] arr = null;</span></span><br><span class="line"><span class="comment">//		System.out.println(arr[3]);</span></span><br><span class="line">		</span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">		str = <span class="literal">null</span>;</span><br><span class="line">		System.out.println(str.charAt(<span class="number">0</span>));		</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//******************以下是编译时异常***************************</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//		File file = new File(&quot;hello.txt&quot;);</span></span><br><span class="line"><span class="comment">//		FileInputStream fis = new FileInputStream(file);</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		int data = fis.read();</span></span><br><span class="line"><span class="comment">//		while(data != -1)&#123;</span></span><br><span class="line"><span class="comment">//			System.out.print((char)data);</span></span><br><span class="line"><span class="comment">//			data = fis.read();</span></span><br><span class="line"><span class="comment">//		&#125;</span></span><br><span class="line"><span class="comment">//		</span></span><br><span class="line"><span class="comment">//		fis.close();	</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-2-异常处理"><a href="#8-2-异常处理" class="headerlink" title="8.2 异常处理"></a>8.2 异常处理</h4><p><strong>1）Java异常处理的抓抛模型</strong></p>
<p><strong>过程一：”抛”</strong></p>
<ul>
<li><p>程序在正常执行的过程中，<strong>一旦</strong>出现异常，就会在异常代码处<strong>生成一个对应异常类的对象</strong>，并将此对象抛出。<strong>一旦</strong>抛出对象以后，其后的代码就不再执行</p>
</li>
<li><p>关于异常对象的产生：</p>
<ul>
<li>系统自动生成的异常对象</li>
<li>手动的生成一个异常对象，并抛出（throw）</li>
</ul>
</li>
</ul>
<p><strong>过程二：”抓”</strong></p>
<ul>
<li>可以理解为异常的处理方式：<ol>
<li>try-catch-finally  </li>
<li>throws</li>
</ol>
</li>
</ul>
<p><strong>2）异常处理方式一</strong>：try-catch-finally</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法格式</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的方式1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的方式2</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的方式3</span></span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>finally</code> 是可选的。</p>
</li>
<li><p>使用 <code>try</code> 将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去 <code>catch</code> 中进行匹配</p>
</li>
<li><p>一旦 <code>try</code> 中的异常对象匹配到某一个 <code>catch</code> 时，就进入 <code>catch</code> 中进行异常的处理。一旦处理完成，就跳出当前的 <code>try-catch</code> 结构（在没写 <code>finally</code> 的情况），继续执行其后的代码</p>
</li>
<li><p><code>catch</code> 中的异常类型如果没子父类关系，则谁声明在上，谁声明在下无所谓；<code>catch</code> 中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，将会报错</p>
</li>
<li><p>常用的异常对象处理的方式：① String  getMessage()；② printStackTrace()</p>
</li>
<li><p>在 <code>try</code> 结构中声明的变量，再出了 <code>try</code> 结构以后，就不能再被调用</p>
</li>
<li><p><code>try-catch-finally</code> 结构可以嵌套</p>
</li>
</ul>
<p><strong>总结</strong></p>
<p><strong>如何看待代码中的编译时异常和运行时异常？</strong></p>
<ul>
<li><p>使用 <code>try-catch-finally</code> 处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用 <code>try-catch-finally</code> 将一个编译时可能出现的异常，延迟到运行时出现。</p>
</li>
<li><p>开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写 <code>try-catch-finally</code> 了。针对于编译时异常，我们一定要考虑异常的处理。</p>
</li>
</ul>
<p><strong>finally 的再说明</strong></p>
<ul>
<li><code>finally</code>是可选的</li>
<li><code>finally</code> 中声明的是一定会被执行的代码。即使 <code>catch</code> 中又出现异常了，<code>try</code> 中 <code>return</code> 语句，<code>catch</code> 中 <code>return</code> 语句等情况</li>
<li>像数据库连接、输入输出流、网络编程 Socket 等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在 <code>finally</code> 中</li>
</ul>
<hr>
<p><strong>面试题</strong></p>
<p>结构相似的：</p>
<ol>
<li>final、finally、finalize三者的区别？<ul>
<li>final 是一个修饰符，用于修饰类、方法或者变量。修饰类时，该类不能被继承；修饰方法时，该方法不能被重写；修饰变量时，该变量变为常量，不能二次赋值；修饰静态变量时，必须在声明时同时赋值（显示赋值或者构造器赋值）。不能修饰抽象类和接口。</li>
<li>finally 只能用于 try-catch-finally 结构。finally 语句块中的语句是一定会被执行的，并且会在 return，continue，break 关键字之前执行。在数据库连接、处理输入输出流时，一般都在 finally 中写释放资源的代码。</li>
<li>finalize 是一个方法，属于 java.lang.Object 类。这个方法由 System.gc() 启动，该对象被回收的时候被调用。一个对象的 finalize() 方法只会被调用一次，而且 finalize() 被调用不意味着 GC 会立即回收该对象</li>
</ul>
</li>
<li>throw 和 throws<ul>
<li>throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内</li>
<li>throws 属于异常处理的一种方式，声明在方法的声明处</li>
</ul>
</li>
<li>Collection 和 Collections</li>
<li>String 、StringBuffer、StringBuilder</li>
<li>ArrayList 、 LinkedList</li>
<li>HashMap 、LinkedHashMap</li>
<li>重写、重载</li>
</ol>
<p>结构不相似的：</p>
<ol>
<li>抽象类、接口</li>
<li>&#x3D;&#x3D; 、 equals()</li>
<li>sleep()、wait()</li>
</ol>
<p><strong>3）异常处理方式二</strong></p>
<ul>
<li><p>“throws + 异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型</p>
</li>
<li><p>一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足 throws 后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！</p>
</li>
</ul>
<p><strong>对比两种处理方式</strong></p>
<ul>
<li><p>try-catch-finally：真正的将异常给处理掉了</p>
</li>
<li><p>throws 的方式只是将异常抛给了方法的调用者。并没真正将异常处理掉</p>
</li>
</ul>
<p><strong>体会开发中应该如何选择两种处理方式？</strong></p>
<ul>
<li><p>如果父类中被重写的方法没使用 throws 方式处理异常，则子类重写的方法也不能使用 throws，意味着如果子类重写的方法中异常，必须使用 try-catch-finally 方式处理</p>
</li>
<li><p>执行的方法 a 中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用 throws 的方式进行处理。而执行的方法 a 可以考虑使用 try-catch-finally 方式进行处理</p>
</li>
</ul>
<blockquote>
<p>方法重写的规则之一：子类重写的方法抛出的异常类型<strong>不大于</strong>父类被重写的方法抛出的异常类型</p>
</blockquote>
<h4 id="8-3-手动抛出异常"><a href="#8-3-手动抛出异常" class="headerlink" title="8.3 手动抛出异常"></a>8.3 手动抛出异常</h4><p>在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的 throw 一个异常类的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">regist</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">		<span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line">			<span class="built_in">this</span>.id = id;</span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="comment">//手动抛出异常对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//			throw new RuntimeException(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line"><span class="comment">//			throw new Exception(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;不能输入负数&quot;</span>);</span><br><span class="line">		&#125;	</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="8-4-自定义异常类"><a href="#8-4-自定义异常类" class="headerlink" title="8.4 自定义异常类"></a>8.4 自定义异常类</h4><ol>
<li><p>继承于现的异常结构：RuntimeException 、Exception</p>
</li>
<li><p>提供全局常量：serialVersionUID</p>
</li>
<li><p>提供重载的构造器</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">7034897193246939L</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;		</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span>&#123;</span><br><span class="line">		<span class="built_in">super</span>(msg);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="第二部分-Java-高级编程"><a href="#第二部分-Java-高级编程" class="headerlink" title="第二部分 Java 高级编程"></a>第二部分 Java 高级编程</h2><h3 id="第9章-多线程"><a href="#第9章-多线程" class="headerlink" title="第9章 多线程"></a>第9章 多线程</h3><h4 id="9-1-基本概念"><a href="#9-1-基本概念" class="headerlink" title="9.1 基本概念"></a>9.1 基本概念</h4><ul>
<li><p><strong>程序（Program）</strong>：为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。</p>
</li>
<li><p><strong>进程（Process）</strong>：程序的一次执行过程，或是正在运行的一个程序。（<strong>进程作为资源分配的单位</strong>，系统在运行时会为每个进程分配不同的内存区域）</p>
</li>
<li><p><strong>线程（Thread）</strong>：进程可进一步细化为线程，是一个程序内部的一条执行路径。（线程作为调度和执行的单位，每个线程拥独立的运行栈和程序计数器（PC），线程切换的开销小）</p>
</li>
<li><p><strong>并行（Parallelism）</strong>：多个 CPU 同时执行多个任务。比如：多个人同时做不同的事。</p>
</li>
<li><p><strong>并发（Concurrency）</strong>：一个 CPU（采用时间片）同时执行多个任务。比如：秒杀、多个人做同一件事。</p>
</li>
</ul>
<h4 id="9-2-创建多线程的四种方式"><a href="#9-2-创建多线程的四种方式" class="headerlink" title="9.2 创建多线程的四种方式"></a>9.2 创建多线程的四种方式</h4><h5 id="9-2-1-继承-Thread-类"><a href="#9-2-1-继承-Thread-类" class="headerlink" title="9.2.1 继承 Thread 类"></a>9.2.1 继承 Thread 类</h5><ol>
<li>创建一个继承于 Thread 类的子类</li>
<li>重写 Thread 类的 run()，并将此线程执行的操作声明在 run() 中</li>
<li>创建 Thread 类的子类的对象</li>
<li>通过此对象调用 start()：① 启动当前线程 ② 调用当前线程的 run()<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个继承于Thread类的子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 重写Thread类的run() --&gt; 将此线程执行的操作声明在run()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewThread_1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 创建Thread类的子类的对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">// 4. 通过此对象调用start()：①启动当前线程 ② 调用当前线程的run()</span></span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<blockquote>
<p>启动一个线程，必须调用 start()，不能调用 run() 的方式启动线程。</p>
<p>如果再启动一个线程，必须重新创建一个Thread 子类的对象，调用此对象的 start()。</p>
</blockquote>
<h5 id="9-2-2-实现-Runnable-接口"><a href="#9-2-2-实现-Runnable-接口" class="headerlink" title="9.2.2 实现 Runnable 接口"></a>9.2.2 实现 Runnable 接口</h5><ol>
<li>创建一个实现了 Runnable 接口的类。</li>
<li>实现类去实现 Runnable 中的抽象方法 run()。</li>
<li>创建实现类的对象。</li>
<li>将此对象作为参数传递到 Thread 类的构造器中，创建 Thread 类的对象。</li>
<li>通过 Thread 类的对象调用 start()。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个实现了Runnable接口的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 实现类去实现Runnable中的抽象方法：run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewThread_2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 创建实现类的对象</span></span><br><span class="line">        <span class="type">HelloThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">        <span class="comment">// 4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread);</span><br><span class="line">        <span class="comment">// 5. 通过Thread类的对象调用start()</span></span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>两种方式的对比</strong></p>
<p>开发中：优先选择<strong>实现 Runnable 接口</strong>的方式</p>
<p>原因：① 实现的方式没类的单继承性的局限性</p>
<p>​           ② 实现的方式更适合来处理多个线程共享数据的情况。</p>
<p>联系：public class Thread implements Runnable</p>
<p>相同点：两种方式都需要重写 run()，将线程要执行的逻辑声明在 run() 中。</p>
<p>​              目前两种方式，要想启动线程，都是调用的 Thread 类中的 start()。</p>
</blockquote>
<h5 id="9-2-3-实现-Callable-接口-（JDK-5-0-新增）"><a href="#9-2-3-实现-Callable-接口-（JDK-5-0-新增）" class="headerlink" title="9.2.3 实现 Callable 接口 （JDK 5.0 新增）"></a>9.2.3 实现 Callable 接口 （JDK 5.0 新增）</h5><ol>
<li>创建一个实现 Callable 的实现类。</li>
<li>实现 call() 方法，将此线程需要执行的操作声明在 call() 中。</li>
<li>创建 Callable 接口实现类的对象。</li>
<li>将此 Callable 接口实现类的对象作为传递到 FutureTask 构造器中，创建 FutureTask 的对象。</li>
<li>将 FutureTask 的对象作为参数传递到 Thread 类的构造器中，创建 Thread 对象，并调用 start()。</li>
<li>获取 Callable 中 call() 方法的返回值。</li>
</ol>
<p>![FutureTask](C:\Dvenotes=&#x3D; Java 学习路线  &#x3D;&#x3D;\image\FutureTask.png)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FutureTask 类的构造器方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> FutureTask&#125; that will, upon running, execute the given &#123;<span class="doctag">@code</span> Callable&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  callable the callable task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the callable is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.callable = callable;</span><br><span class="line">    <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">    <span class="comment">// 2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadNew</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3.创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line">        <span class="comment">// 4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">        <span class="comment">// 5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 6.获取Callable中call方法的返回值</span></span><br><span class="line">            <span class="comment">// get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>如何理解实现 Callable 接口的方式创建多线程比实现 Runnable 接口创建多线程方式强大？</strong></p>
<ol>
<li>call() 可以返回值的。</li>
<li>call() 可以抛出异常，被外面的操作捕获，获取异常的信息。</li>
<li>Callable 是支持泛型的。</li>
</ol>
<h5 id="9-2-4-使用线程池（JDK-5-0-新增）"><a href="#9-2-4-使用线程池（JDK-5-0-新增）" class="headerlink" title="9.2.4 使用线程池（JDK 5.0 新增）"></a>9.2.4 使用线程池（JDK 5.0 新增）</h5><ol>
<li>提供指定线程数量的线程池。</li>
<li>执行指定的线程的操作。需要提供实现 Runnable 接口或 Callable 接口实现类的对象。</li>
<li>关闭连接池。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">service1</span> <span class="operator">=</span> (ThreadPoolExecutor) service;</span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line"><span class="comment">//        System.out.println(service.getClass());</span></span><br><span class="line"><span class="comment">//        service1.setCorePoolSize(15);</span></span><br><span class="line"><span class="comment">//        service1.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread1</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        service.submit(Callable callable);//适合适用于Callable</span></span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>好处</strong></p>
<ol>
<li>提高响应速度（减少了创建新线程的时间）</li>
<li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li>
<li>便于线程管理<ul>
<li><code>corePoolSize</code>：核心池的大小</li>
<li><code>maximumPoolSize</code>：最大线程数</li>
<li><code>keepAliveTime</code>：线程没任务时最多保持多长时间后会终止</li>
</ul>
</li>
</ol>
<hr>
<p><strong>面试题</strong></p>
<ul>
<li>Java 中多线程的创建有几种方式？<strong>四种</strong>。</li>
</ul>
<h4 id="9-3-Thread-类中的常用方法"><a href="#9-3-Thread-类中的常用方法" class="headerlink" title="9.3 Thread 类中的常用方法"></a>9.3 Thread 类中的常用方法</h4><ul>
<li><p><code>start()</code>：启动当前线程；调用当前线程的 run()</p>
</li>
<li><p><code>run()</code>： 通常需要重写 Thread 类中的此方法，将创建的线程要执行的操作声明在此方法中</p>
</li>
<li><p><code>currentThread()</code>：静态方法，返回执行当前代码的线程</p>
</li>
<li><p><code>getName()</code>：获取当前线程的名字</p>
</li>
<li><p><code>setName()</code>：设置当前线程的名字</p>
</li>
<li><p><code>yield()</code>：线程让步，释放当前 CPU 的执行权</p>
</li>
<li><p><code>join()</code>：在线程 a 中调用线程 b 的 join()，此时线程 a 就进入阻塞状态，直到线程 b 完全执行完以后，线程 a 才结束阻塞状态。</p>
</li>
<li><p><del><code>stop()</code>：已过时。当执行此方法时，强制结束当前线程。</del></p>
</li>
<li><p><code>sleep(long millitime)</code>：让当前线程“睡眠”指定的 millitime 毫秒。在指定的 millitime 毫秒时间内，当前线程是阻塞状态。</p>
</li>
<li><p><code>isAlive()</code>：判断当前线程是否存活</p>
</li>
</ul>
<hr>
<ol>
<li><p><strong>线程的优先级</strong></p>
<ul>
<li>MAX_PRIORITY：10</li>
<li>MIN _PRIORITY：1</li>
<li>NORM_PRIORITY：5  （默认优先级）</li>
</ul>
</li>
<li><p><strong>如何获取和设置当前线程的优先级</strong></p>
<ul>
<li><code>getPriority()</code>：获取线程的优先级</li>
<li><code>setPriority(int p)</code>：设置线程的优先级</li>
</ul>
<p><strong>说明</strong>：高优先级的线程要抢占低优先级线程 CPU 的执行权。但是只是<strong>从概率上</strong>讲，高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行。</p>
<p>线程通信：<code>wait()</code> &#x2F; <code>notify()</code> &#x2F; <code>notifyAll()</code>：:此三个方法定义在 Object 类中的。</p>
</li>
<li><p><strong>线程的分类</strong>：一种是<strong>守护线程</strong>，一种是<strong>用户线程</strong>。</p>
</li>
</ol>
<h4 id="9-4-线程的生命周期"><a href="#9-4-线程的生命周期" class="headerlink" title="9.4 线程的生命周期"></a>9.4 线程的生命周期</h4><p><img src="/.io//image%5C%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="线程的生命周期"></p>
<p><strong>说明</strong></p>
<ol>
<li><p>生命周期关注两个概念：状态、相应的方法</p>
</li>
<li><p>关注：<code>状态 a --&gt; 状态 b</code>哪些方法执行了（回调方法）；某个方法主动调用使<code>状态 a--&gt;状态 b</code></p>
</li>
<li><p>阻塞：临时状态，不可以作为最终状态；死亡：最终状态。</p>
</li>
</ol>
<h4 id="9-5-线程的同步机制"><a href="#9-5-线程的同步机制" class="headerlink" title="9.5 线程的同步机制"></a>9.5 线程的同步机制</h4><p>在 Java 中，我们通过<strong>同步机制</strong>，来解决线程的安全问题。</p>
<h5 id="9-5-1-同步代码块"><a href="#9-5-1-同步代码块" class="headerlink" title="9.5.1 同步代码块"></a>9.5.1 同步代码块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 需要被同步的代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>说明</strong></p>
<ol>
<li>操作共享数据的代码，即为需要被同步的代码。不能包含代码多了，也不能包含代码少了。</li>
<li>共享数据：多个线程共同操作的变量。</li>
<li>同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。</li>
</ol>
<p>要求：多个线程必须要共用同一把锁。</p>
<ul>
<li><p>在实现 Runnable 接口创建多线程的方式中，我们可以考虑使用 this 充当同步监视器。</p>
</li>
<li><p>在继承 Thread 类创建多线程的方式中，<strong>慎用</strong> this 充当同步监视器，考虑使用当前类充当同步监视器。</p>
</li>
</ul>
<h5 id="9-5-2-同步方法"><a href="#9-5-2-同步方法" class="headerlink" title="9.5.2 同步方法"></a>9.5.2 同步方法</h5><p>如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。（用 <strong><code>synchronized</code></strong> 修饰方法）</p>
<ol>
<li>同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。</li>
<li>非静态的同步方法，同步监视器是：this</li>
<li>静态的同步方法，同步监视器是：当前类本身</li>
</ol>
<h5 id="9-5-3-Lock-锁（JDK-5-0-新增）"><a href="#9-5-3-Lock-锁（JDK-5-0-新增）" class="headerlink" title="9.5.3 Lock 锁（JDK 5.0 新增）"></a>9.5.3 Lock 锁（JDK 5.0 新增）</h5><ol>
<li>实例化 ReentrantLock</li>
<li>调用锁定方法 lock()</li>
<li>调用解锁方法unlock()</li>
</ol>
<p><strong>使用的优先顺序</strong></p>
<p><code>Lock ---&gt; 同步代码块（已经进入了方法体，分配了相应资源 ) ---&gt; 同步方法（在方法体之外)</code></p>
<p><strong>死锁问题</strong>：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</p>
<ul>
<li>出现死锁后，不会出现异常，不会出现提示，只是所的线程都处于阻塞状态，无法继续</li>
<li>在使用同步时，要避免出现死锁。</li>
</ul>
<p><strong>解决方法</strong>：① 专门的算法、原则；② 尽量减少同步资源的定义</p>
<hr>
<p><strong>面试题</strong></p>
<p>Java是如何解决线程安全问题的，有几种方式？并对比几种方式的不同</p>
<ul>
<li>使用同步机制来解决线程安全问题</li>
<li>共有三种方式</li>
</ul>
<p>synchronized 和 Lock 方式解决线程安全问题的对比（synchronized 与 Lock 的异同？）</p>
<ul>
<li><p>相同：二者都可以解决线程安全问题</p>
</li>
<li><p>不同：synchronized 机制在执行完相应的同步代码以后，自动的释放同步监视器</p>
<p>​           Lock 需要手动的启动同步（lock()，同时结束同步也需要手动的实现（unlock()）</p>
</li>
</ul>
<p><strong>利弊</strong>：同步的方式，<strong>解决了线程的安全问题</strong>。操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，<strong>效率低</strong>。</p>
<h4 id="9-6-线程通信"><a href="#9-6-线程通信" class="headerlink" title="9.6 线程通信"></a>9.6 线程通信</h4><p><strong>1）线程通信涉及到的三个方法</strong></p>
<ul>
<li><p><code>wait()</code>：一旦执行此方法，当前线程就进入<strong>阻塞状态</strong>，并释放同步监视器。</p>
</li>
<li><p><code>notify()</code>：一旦执行此方法，就会唤醒被 wait 的一个线程。如果有多个线程被 wait，就唤醒优先级高的那个。</p>
</li>
<li><p><code>notifyAll()</code>：一旦执行此方法，就会唤醒所有被 wait 的线程。</p>
</li>
</ul>
<p><strong>2）说明</strong></p>
<ul>
<li><p>这三个方法必须使用在<strong>同步代码块或同步方法</strong>中。</p>
</li>
<li><p>这三个方法的调用者必须是同步代码块或同步方法中的<strong>同步监视器</strong>。否则，会出现 <code>IllegalMonitorStateException</code> 异常</p>
</li>
<li><p>这三个方法是定义在 java.lang.Object 类中。</p>
</li>
</ul>
<p><strong>3）会释放锁的操作</strong></p>
<ol>
<li>当前线程的同步代码块、同步方法<strong>执行结束</strong>。</li>
<li>当前线程在同步代码块、同步方法中遇到 break、return <strong>终止</strong>了该代码块、该方法的继续执行。</li>
<li>当前线程在同步代码块、同步方法中出现了未处理的 Error 或 Exception，导致<strong>异常</strong>结束。</li>
<li>当前线程在同步代码块、同步方法中执行了线程对象的 **wait()**，当前线程暂停，并释放锁</li>
</ol>
<p><strong>4）不会释放锁的操作</strong></p>
<ol>
<li><p>线程执行同步代码块或同步方法时，程序调用 Thread.sleep()、Thread.yield() 方法暂停当前线程的执行。</p>
</li>
<li><p>线程执行同步代码块时，其他线程调用了该线程的 suspend() 方法将该线程挂起，该线程不会释放锁（同步监视器）。（应尽量避免使用 suspend() 和 resume() 来控制线程。）</p>
</li>
</ol>
<hr>
<p><strong>面试题</strong></p>
<p>sleep() 和 wait()的异同？</p>
<ol>
<li>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。</li>
<li>不同点：<ul>
<li>两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()</li>
<li>调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中</li>
<li>关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。</li>
</ul>
</li>
</ol>
<h3 id="第10章-Java-常用类"><a href="#第10章-Java-常用类" class="headerlink" title="第10章 Java 常用类"></a>第10章 Java 常用类</h3><h4 id="10-1-String-类"><a href="#10-1-String-类" class="headerlink" title="10.1 String 类"></a>10.1 String 类</h4><p><strong>1）概述</strong></p>
<ul>
<li><p>String（字符串）使用一对<code>&quot;&quot;</code>引起来表示。</p>
</li>
<li><p>String 内部定义了 private final char value[] 用于存储字符串数据；String 声明为 final 的，不可被继承</p>
</li>
<li><p>String 实现了 Serializable 接口：表示字符串是支持序列化的；实现了 Comparable 接口：表示 String 可以比较大小。</p>
</li>
<li><p>通过字面量的方式（区别于 new 给一个字符串赋值，此时的字符串值声明在字符串常量池中）。</p>
</li>
<li><p>字符串常量池中是不会存储相同内容（使用 String 类的 equals() 比较，返回 true）的字符串的。</p>
</li>
</ul>
<p><strong>2）String 的不可变性</strong></p>
<ul>
<li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的 value 进行赋值。</li>
<li>当对现的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。</li>
<li>当调用 String 的 replace() 方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。</li>
</ul>
<p><strong>3）String 实例化的不同方式</strong></p>
<ul>
<li><p>方式一：通过字面量定义的方式</p>
</li>
<li><p>方式二：通过 new + 构造器的方式</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过字面量定义的方式：此时的 str1 和 str2 的数据 JavaEE 声明在方法区中的字符串常量池中。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;JavaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;JavaEE&quot;</span>;</span><br><span class="line"><span class="comment">// 通过 new + 构造器的方式:此时的 str3 和 str4 保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;JavaEE&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;JavaEE&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">// true</span></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">// false</span></span><br><span class="line">System.out.println(str1 == str4);<span class="comment">// false</span></span><br><span class="line">System.out.println(str3 == str4);<span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><strong>面试题</strong></p>
<p><code>String s = new String(&quot;abc&quot;); </code>方式创建对象，在内存中创建了几个对象？</p>
<ul>
<li>两个：一个是堆空间中 new 结构，另一个是 char[] 对应的常量池中的数据：”abc”</li>
</ul>
<p><strong>4）字符串拼接方式赋值的对比</strong></p>
<ol>
<li><p>常量与常量的拼接结果在<strong>常量池</strong>。且常量池中不会存在相同内容的常量。</p>
</li>
<li><p>只要其中一个是变量，结果就在<strong>堆</strong>中。</p>
</li>
<li><p>如果拼接的结果调用 <strong>intern()</strong> 方法，返回值就在<strong>常量池</strong>中</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">// true</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">// false</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">// false</span></span><br><span class="line">System.out.println(s3 == s7);<span class="comment">// false</span></span><br><span class="line">System.out.println(s5 == s6);<span class="comment">// false</span></span><br><span class="line">System.out.println(s5 == s7);<span class="comment">// false</span></span><br><span class="line">System.out.println(s6 == s7);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();<span class="comment">// 返回值得到的 s8 使用的常量值中已经存在的 “javaEEhadoop”</span></span><br><span class="line">System.out.println(s3 == s8);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">System.out.println(s1 == s3);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;<span class="comment">// s4: 常量</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s4 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">System.out.println(s1 == s5);<span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>5）常用方法</strong></p>
<ul>
<li><p><code>int length()</code>：返回字符串的长度： return value.length</p>
</li>
<li><p><code>char charAt(int index)</code>： 返回某索引处的字符 return value[index]</p>
</li>
<li><p><code>boolean isEmpty()</code>：判断<strong>是否为空</strong>字符串：return value.length &#x3D;&#x3D; 0</p>
</li>
<li><p><code>String toLowerCase()</code>：使用默认语言环境，将 String 中的所字符<strong>转换为小写</strong></p>
</li>
<li><p><code>String toUpperCase()</code>：使用默认语言环境，将 String 中的所字符<strong>转换为大写</strong></p>
</li>
<li><p><code>String trim()</code>：返回字符串的副本，忽略前导空白和尾部空白</p>
</li>
<li><p><code>boolean equals(Object obj)</code>：比较字符串的<strong>内容</strong>是否相同</p>
</li>
<li><p><code>boolean equalsIgnoreCase(String anotherString)</code>：与equals方法类似，忽略大小写</p>
</li>
<li><p><code>String concat(String str)</code>：将指定字符串连接到此字符串的结尾。 等价于用 “+”</p>
</li>
<li><p><code>int compareTo(String anotherString)</code>：比较两个字符串的大小</p>
</li>
<li><p><code>String substring(int beginIndex)</code>：返回一个新的字符串，它是此字符串的从<code>beginIndex</code>开始截取到最后的一个子字符串。</p>
</li>
<li><p><code>String substring(int beginIndex, int endIndex) </code>：返回一个新字符串，它是此字符串从<code>beginIndex</code>开始截取到<code>endIndex</code><strong>(不包含)</strong> 的一个子字符串。</p>
</li>
<li><p><code>boolean endsWith(String suffix)</code>：测试此字符串是否以指定的<strong>后缀</strong>结束</p>
</li>
<li><p><code>boolean startsWith(String prefix)</code>：测试此字符串是否以指定的<strong>前缀</strong>开始</p>
</li>
<li><p><code>boolean startsWith(String prefix, int toffset)</code>：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</p>
</li>
<li><p><code>boolean contains(CharSequence s)</code>：当且仅当此字符串包含指定的 char 值序列时，返回 true</p>
</li>
<li><p><code>int indexOf(String str)</code>：返回指定子字符串在此字符串中第一次出现处的索引</p>
</li>
<li><p><code>int indexOf(String str, int fromIndex)</code>：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</p>
</li>
<li><p><code>int lastIndexOf(String str)</code>：返回指定子字符串在此字符串中最右边出现处的索引</p>
</li>
<li><p><code>int lastIndexOf(String str, int fromIndex)</code>：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</p>
</li>
<li><p>注：<code>indexOf</code> 和 <code>lastIndexOf</code> 方法如果未找到都是返回 -1</p>
</li>
</ul>
<p><strong>替换：</strong></p>
<ul>
<li><p><code>String replace(char oldChar, char newChar)</code>：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所 oldChar 得到的。</p>
</li>
<li><p><code>String replace(CharSequence target, CharSequence replacement)</code>：使用指定的字面值替换序列替换此字符串所匹配字面值目标序列的子字符串。</p>
</li>
<li><p><code>String replaceAll(String regex, String replacement)</code>：使用给定的 replacement 替换此字符串所匹配给定的正则表达式的子字符串。</p>
</li>
<li><p><code>String replaceFirst(String regex, String replacement)</code>：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</p>
</li>
</ul>
<p><strong>匹配:</strong></p>
<ul>
<li><code>boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。</code></li>
</ul>
<p><strong>切片：</strong></p>
<ul>
<li><p><code>String[] split(String regex)</code>：根据给定正则表达式的匹配拆分此字符串。</p>
</li>
<li><p><code>String[] split(String regex, int limit)</code>：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</p>
</li>
</ul>
<p><strong>6）String 与其它结构的转换</strong></p>
<ul>
<li><code>String --&gt; 基本数据类型、包装类</code>：调用包装类的<strong>静态方法</strong> parseXxx(str)</li>
<li><code>基本数据类型、包装类 --&gt; String</code>：调用 String 重载的 valueOf(xxx)</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str1);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> String.valueOf(num);</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> num + <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>String --&gt; char[]</code>：调用 String 的 toCharArray()</li>
<li><code>char[] --&gt; String</code>：调用 String 的构造器</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] charArray = str1.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">System.out.println(charArray[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] arr = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">System.out.println(str2);</span><br></pre></td></tr></table></figure>

<ul>
<li><p>编码：<code>String --&gt; byte[]</code>：调用 String 的 getBytes()</p>
</li>
<li><p>解码：<code>byte[] --&gt; String</code>：调用 String 的构造器</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc123中国&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] bytes = str1.getBytes();<span class="comment">// 使用默认的字符集进行编码。</span></span><br><span class="line">System.out.println(Arrays.toString(bytes));</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] gbks = str1.getBytes(<span class="string">&quot;gbk&quot;</span>);<span class="comment">// 使用gbk字符集进行编码。</span></span><br><span class="line">System.out.println(Arrays.toString(gbks));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);<span class="comment">// 使用默认的字符集，进行解码。</span></span><br><span class="line">System.out.println(str2);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks);</span><br><span class="line">System.out.println(str3);<span class="comment">// 出现乱码。原因：编码集和解码集不一致！</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">System.out.println(str4);<span class="comment">// 没出现乱码。原因：编码集和解码集一致！</span></span><br></pre></td></tr></table></figure>

<p>说明：解码时，要求解码使用的字符集必须与编码时使用的<strong>字符集一致</strong>，否则会出现乱码。</p>
<ul>
<li><code>String --&gt; StringBuffer、StringBuilder</code>：调用 StringBuffer、StringBuilder 构造器</li>
<li><code>StringBuffer、StringBuilder --&gt;S tring</code>：① 调用 String 构造器；② StringBuffer、StringBuilder 的 toString()</li>
</ul>
<p><strong>7）JVM 中字符串常量池存放位置说明</strong></p>
<ul>
<li><p>jdk 1.6：字符串常量池存储在<strong>方法区（永久区）</strong></p>
</li>
<li><p>jdk 1.7：字符串常量池存储在<strong>堆空间</strong></p>
</li>
<li><p>jdk 1.8：字符串常量池存储在<strong>方法区（元空间）</strong></p>
</li>
</ul>
<p><strong>8）常见算法题目</strong></p>
<ol>
<li><p>模拟一个 trim 方法，去除字符串两端的空格。</p>
</li>
<li><p>将一个字符串进行反转。将字符串中指定部分进行反转。比如 “abcdefg” 反转为 ”abfedcg”</p>
</li>
<li><p>获取一个字符串在另一个字符串中出现的次数。比如：获取 “ab” 在 “abkkcadkabkebfkabkskab” 中出现的次数</p>
</li>
<li><p>获取两个字符串中最大相同子串。比如：   str1 &#x3D; “abcwerthelloyuiodef“，str2 &#x3D; “cvhellobnm”</p>
<ul>
<li>提示：将短的那个串进行长度依次递减的子串与较长的串比较。</li>
</ul>
</li>
<li><p>对字符串中字符进行自然顺序排序。</p>
<ul>
<li>提示：字符串变成字符数组；对数组排序，择，冒泡，Arrays.sort()；将排序后的数组变成字符串。</li>
</ul>
</li>
</ol>
<h4 id="10-2-StringBuffer、StringBuilder-类"><a href="#10-2-StringBuffer、StringBuilder-类" class="headerlink" title="10.2 StringBuffer、StringBuilder 类"></a>10.2 StringBuffer、StringBuilder 类</h4><p><strong>1）String、StringBuffer、StringBuilder 三者的对比</strong></p>
<ul>
<li><p>String：<strong>不可变</strong>的字符序列；底层使用 char[] 存储</p>
</li>
<li><p>StringBuffer：<strong>可变</strong>的字符序列；<strong>线程安全</strong>的，效率低；底层使用 char[] 存储</p>
</li>
<li><p>StringBuilder：<strong>可变</strong>的字符序列；JDK 5.0 新增的，<strong>线程不安全</strong>的，效率高；底层使用 char[] 存储</p>
</li>
</ul>
<p><strong>2）StringBuffer 与 StringBuilder 的内存解析</strong></p>
<p>以 StringBuffer 为例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();<span class="comment">//char[] value = new char[0];</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();<span class="comment">//char[] value = new char[16]; 底层创建了一个长度是16的数组。</span></span><br><span class="line">System.out.println(sb1.length());<span class="comment">//</span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//value[0] = &#x27;a&#x27;;</span></span><br><span class="line">sb1.append(<span class="string">&#x27;b&#x27;</span>);<span class="comment">//value[1] = &#x27;b&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char[] value = new char[&quot;abc&quot;.length() + 16];</span></span><br></pre></td></tr></table></figure>

<p>问题1：<code> System.out.println(sb2.length());</code>&#x2F;&#x2F; 3</p>
<p>问题2：扩容问题：如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。</p>
<ul>
<li><p>默认情况下，扩容为原来容量的2倍 + 2，同时将原数组中的元素复制到新的数组中。</p>
</li>
<li><p>指导意义：开发中建议大家使用：<code>StringBuffer(int capacity)</code> 或 <code>StringBuilder(int capacity)</code></p>
</li>
</ul>
<p><strong>3）对比String、StringBuffer、StringBuilder 三者的执行效率</strong>从高到低排列：<code>StringBuilder &gt; StringBuffer &gt; String</code></p>
<p><strong>4）StringBuffer、StringBuilder中的常用方法</strong></p>
<ul>
<li><p>增：append(xxx)</p>
</li>
<li><p>删：delete(int start,int end)</p>
</li>
<li><p>改：setCharAt(int n ,char ch) &#x2F; replace(int start, int end, String str)</p>
</li>
<li><p>查：charAt(int n )</p>
</li>
<li><p>插：insert(int offset, xxx)</p>
</li>
<li><p>长度：length();</p>
</li>
<li><p>遍历：① for() + charAt()；② toString()</p>
</li>
</ul>
<h4 id="10-3-JDK-8-之前的日期时间-API"><a href="#10-3-JDK-8-之前的日期时间-API" class="headerlink" title="10.3 JDK 8 之前的日期时间 API"></a>10.3 JDK 8 之前的日期时间 API</h4><p><strong>1）获取系统当前时间</strong>：System 类中的 <code>currentTimeMillis()</code></p>
<p><strong>2）java.util.Date 类 与 java.sql.Date 类</strong></p>
<ul>
<li>java.sql.Date 类是 java.util.Date 类</li>
</ul>
<p><strong>两个构造器的使用</strong></p>
<ol>
<li><code>Date()</code>：创建一个对应当前时间的 Date 对象</li>
<li>创建指定毫秒数的Date对象</li>
</ol>
<p><strong>两个方法的使用</strong></p>
<ol>
<li><code>toString()</code>：显示当前的年、月、日、时、分、秒</li>
<li><code>getTime()</code>：获取当前Date对象对应的毫秒数。（时间戳）</li>
</ol>
<p><strong>java.sql.Date 对应着数据库中的日期类型的变量</strong></p>
<ul>
<li>如何实例化</li>
<li>如何将 java.util.Date 对象转换为 java.sql.Date 对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dateTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 Date 对象</span></span><br><span class="line">    <span class="comment">// 构造器一</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    System.out.println(date1.toString());</span><br><span class="line">    System.out.println(date1.getTime());</span><br><span class="line">    <span class="comment">// 构造器二</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">84739232874L</span>);</span><br><span class="line">    System.out.println(date2.toString());</span><br><span class="line">    <span class="comment">// 创建 java.sql.Date 对象</span></span><br><span class="line">    java.sql.<span class="type">Date</span> <span class="variable">date3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="number">739742938429L</span>);</span><br><span class="line">    System.out.println(date3);</span><br><span class="line">    <span class="comment">// 将java.util.Date对象转换为java.sql.Date对象</span></span><br><span class="line">    <span class="comment">// 方法一</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="number">342342342L</span>);</span><br><span class="line">    java.sql.<span class="type">Date</span> <span class="variable">date5</span> <span class="operator">=</span> (java.sql.Date)date4;</span><br><span class="line">    <span class="comment">// 方法二</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    java.sql.<span class="type">Date</span> <span class="variable">date7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(date6.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3）java.text.SimpleDataFormat类</strong></p>
<ul>
<li>对日期 Date 类的格式化和解析</li>
<li>格式化：<code>日期 --&gt; 字符串</code></li>
<li>解析：格式化的逆过程，<code>字符串 --&gt; 日期</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleDateFormatTest</span><span class="params">()</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    System.out.println(date);</span><br><span class="line">    <span class="comment">// 格式化</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> simpleDateFormat.format(date);</span><br><span class="line">    System.out.println(format);</span><br><span class="line">    <span class="comment">// 解析：要求字符串必须是符合 SimpleDateFormat 识别的格式（通过构造器参数体现），否则，报 java.text.ParseException</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">parse</span> <span class="operator">=</span> simpleDateFormat.parse(<span class="string">&quot;2021-02-06 04:39:35&quot;</span>);</span><br><span class="line">    System.out.println(parse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4）Calendar 类（抽象类）</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calendarTest</span><span class="params">()</span> &#123;</span><br><span class="line">java    <span class="comment">// 1.实例化</span></span><br><span class="line">    <span class="comment">// 方法一：创建其子类 GregorianCalendar 的对象</span></span><br><span class="line"><span class="comment">//        GregorianCalendar gregorianCalendar = new GregorianCalendar();</span></span><br><span class="line">    <span class="comment">// 方法二：调用其静态方法 getInstance()</span></span><br><span class="line">    <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">    <span class="comment">// 2.常用方法</span></span><br><span class="line">    <span class="comment">// get()</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">    System.out.println(days);</span><br><span class="line">    <span class="comment">// set()：Calendar 的可变性</span></span><br><span class="line">    calendar.set(Calendar.DAY_OF_MONTH, <span class="number">23</span>);</span><br><span class="line">    System.out.println(calendar.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">    <span class="comment">// add()</span></span><br><span class="line">    calendar.add(Calendar.DAY_OF_MONTH, -<span class="number">3</span>);</span><br><span class="line">    System.out.println(calendar.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">    <span class="comment">// getTime(): Calendar --&gt; Date</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">    System.out.println(date);</span><br><span class="line">    <span class="comment">// setTime(): Date --&gt; Calender</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    calendar.setTime(now);</span><br><span class="line">    System.out.println(calendar.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-4-JDK-8-中新时间日期-API"><a href="#10-4-JDK-8-中新时间日期-API" class="headerlink" title="10.4 JDK 8 中新时间日期 API"></a>10.4 JDK 8 中新时间日期 API</h4><p><strong>1）日期时间 API 的迭代</strong></p>
<ul>
<li>第一代：JDK 1.0 Date 类</li>
<li>第二代：JDK 1.1 Calenda r类，一定程度上替换 Date 类</li>
<li>第三代：JDK 1.8 提出了新的一套 API</li>
</ul>
<p><strong>2）前两代存在的问题</strong></p>
<ul>
<li>可变性：像日期和时间这样的类应该是不可变的。</li>
<li>偏移性：Date 中的年份是从1900开始的，而月份都从 0 开始。</li>
<li>格式化：格式化只对 Date 用，Calendar 则不行。</li>
<li>不是线程安全的；不能处理闰秒等。</li>
</ul>
<p><strong>3）新的日期时间 API 涉及到的包</strong></p>
<ul>
<li><strong>java.time</strong>：包含值对象的基础包</li>
<li>java.time.chrono：提供对不同的日历系统的访问</li>
<li><strong>java.time.format</strong>：格式化和解析时间和日期</li>
<li>java.time.temporal：包括底层框架和扩展特性</li>
<li>java.time.zone：包含时区支持的类</li>
</ul>
<p><strong>4）本地日期（LocalDate ）、本地时间（LocalTime）、本地日期时间（LocalDateTime）的使用</strong></p>
<h4 id="10-5-Java-比较器"><a href="#10-5-Java-比较器" class="headerlink" title="10.5 Java 比较器"></a>10.5 Java 比较器</h4><p>Java 中的对象，正常情况下，只能进行比较：&#x3D;&#x3D;  或  !&#x3D; 。不能使用 &gt; 或 &lt; 的。但是，在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。使用两个接口中的任何一个：Comparable 或 Comparator</p>
<p><strong>1）自然排序：使用 Comparable 接口</strong></p>
<ol>
<li>像 String、包装类等实现了 Comparable 接口，重写了 compareTo(obj) 方法，给出了比较两个对象大小的方式，进行了从小到大的排列。</li>
<li>重写 compareTo(obj) 的<strong>规则</strong>：<ul>
<li>如果当前对象 this 大于形参对象 obj，则返回正整数；</li>
<li>如果当前对象 this 小于形参对象 obj，则返回负整数；</li>
<li>如果当前对象 this 等于形参对象 obj，则返回 0。</li>
</ul>
</li>
<li>对于自定义类来说，如果需要排序，我们可以让自定义类实现 Comparable 接口，重写 compareTo(obj) 方法，在 compareTo(obj) 方法中指明如何排序</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Goods) &#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> (Goods)o;</span><br><span class="line">            <span class="comment">// 方法一</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.price &gt; goods.price) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.price &lt; goods.price) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(goods.name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 方法二</span></span><br><span class="line"><span class="comment">//            return Double.compare(this.price, goods.price);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入数据类型不一致！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getter、setter、toString()、构造器：省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2）定制排序：使用 Comparator 接口</strong></p>
<ol>
<li>当元素的类型没实现 java.lang.Comparable 接口而又不方便修改代码，或者实现了 java.lang.Comparable 接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序</li>
<li>重写 compare(Object o1, Object o2) 方法，比较 o1 和 o2 的大小：<ul>
<li>如果方法返回正整数，表示 o1 大于 o2；</li>
<li>如果方法返回负整数，表示 o1 小于 o2；</li>
<li>如果方法返回 0，表示相等。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Goods&gt; goods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    goods.add(<span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;rice&quot;</span>, <span class="number">34</span>));</span><br><span class="line">    goods.add(<span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;apple&quot;</span>, <span class="number">5</span>));</span><br><span class="line">    goods.add(<span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;meat&quot;</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Comparator comparator = new Comparator() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public int compare(Object o1, Object o2) &#123;</span></span><br><span class="line"><span class="comment">//                if (o1 instanceof Goods &amp;&amp; o2 instanceof Goods) &#123;</span></span><br><span class="line"><span class="comment">//                    Goods g1 = (Goods)o1;</span></span><br><span class="line"><span class="comment">//                    Goods g2 = (Goods)o2;</span></span><br><span class="line"><span class="comment">//                    if (g1.getName().equals(g2.getName())) &#123;</span></span><br><span class="line"><span class="comment">//                        return Double.compare(g1.getPrice(), g2.getPrice());</span></span><br><span class="line"><span class="comment">//                    &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                        return g1.getName().compareTo(g2.getName());</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                throw new RuntimeException(&quot;输入的数据类型不一致！&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Comparator</span> <span class="variable">comparator</span> <span class="operator">=</span> (o1, o2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> Goods &amp;&amp; o2 <span class="keyword">instanceof</span> Goods) &#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">g1</span> <span class="operator">=</span> (Goods)o1;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">g2</span> <span class="operator">=</span> (Goods)o2;</span><br><span class="line">            <span class="keyword">if</span> (g1.getName().equals(g2.getName())) &#123;</span><br><span class="line">                <span class="keyword">return</span> Double.compare(g1.getPrice(), g2.getPrice());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致！&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用</span></span><br><span class="line">    Arrays.sort(goods.toArray(), comparator);</span><br><span class="line">    Collections.sort(goods, comparator);</span><br><span class="line">    Set&lt;Goods&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Goods&gt;(comparator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="10-6-其他"><a href="#10-6-其他" class="headerlink" title="10.6 其他"></a>10.6 其他</h4><p><strong>1）System 类</strong></p>
<ul>
<li>System 类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于 java.lang 包。</li>
<li>由于该类的构造器是 private 的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是 static 的，所以也可以很方便的进行调用。</li>
<li>方法：<ul>
<li><code>native long currentTimeMillis()</code></li>
<li><code>void exit(int status)</code></li>
<li><code>void gc()</code></li>
<li><code>String getProperty(String key)</code></li>
</ul>
</li>
</ul>
<p><strong>2）Math类</strong></p>
<ul>
<li>java.lang.Math 提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为 double 型。</li>
</ul>
<p><strong>3）BigInteger 类、BigDecimal 类</strong></p>
<ul>
<li>java.math 包的 BigInteger 可以表示不可变的任意精度的整数。</li>
<li>要求数字精度比较高，用到 java.math.BigDecimal 类</li>
</ul>
<h3 id="第11章-Java-集合"><a href="#第11章-Java-集合" class="headerlink" title="第11章 Java 集合"></a>第11章 Java 集合</h3><h4 id="11-1-数组和集合"><a href="#11-1-数组和集合" class="headerlink" title="11.1 数组和集合"></a>11.1 数组和集合</h4><p><strong>1）集合与数组存储数据概述</strong></p>
<ul>
<li><p>集合、数组都是对多个数据进行存储操作的结构，简称 <strong>Java 容器</strong>。</p>
</li>
<li><p>说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt，.jpg，.avi，数据库中)</p>
</li>
</ul>
<p><strong>2）数组存储的特点</strong></p>
<ul>
<li>数组一旦初始化以后，其长度就确定了。一旦定义好，其元素的类型也就确定了，只能操作指定类型的数据了。</li>
</ul>
<p><strong>3）数组存储的弊端</strong></p>
<ol>
<li>一旦初始化以后，其长度就不可修改。</li>
<li>数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</li>
<li>获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用。</li>
<li>数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。</li>
</ol>
<p><strong>4）集合存储的优点</strong></p>
<ul>
<li>解决数组存储数据方面的弊端。</li>
</ul>
<h4 id="11-2-Collection-接口"><a href="#11-2-Collection-接口" class="headerlink" title="11.2 Collection 接口"></a>11.2 Collection 接口</h4><p><strong>1）集合框架结构</strong></p>
<p><img src="/.io//image%5CJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.gif" alt="集合框架"></p>
<p><strong>2）Collection 接口常用方法</strong></p>
<ul>
<li><code>add(Object obj)</code>：添加一个元素</li>
<li><code>addAll(Collection coll)</code>：添加集合元素</li>
<li><code>size()</code>：集合元素个数</li>
<li><code>isEmpty()</code>：是否为空</li>
<li><code>clear()</code>：清空</li>
<li><code>contains(Object obj)</code>：是否包含某个元素</li>
<li><code>containsAll(Collection coll)</code>：是否包含某个集合元素</li>
<li><code>remove(Object obj)</code>：删除某个元素</li>
<li><code>removeAll(Collection coll)</code>：删除所有属于某个集合中的元素</li>
<li><code>retainsAll(Collection coll)</code>：删除所有不属于某集合中的元素</li>
<li><code>equals(Object obj)</code>：是否相等</li>
<li><code>toArray()</code>：转换为数组</li>
<li><code>iterator()</code>：生成迭代器</li>
</ul>
<p><strong>3）Collection 集合与数组间的转换</strong></p>
<ul>
<li><code>集合 ---&gt; 数组：toArray()</code></li>
<li><code>数组 ---&gt; 集合：调用 Arrays 类的静态方法 asList(T ... t)</code></li>
</ul>
<p><strong>使用 Collection 集合存储对象，要求对象所属的类满足：向 Collection 接口的实现类的对象中添加数据 obj 时，要求 obj 所在类要重写 equals()。</strong></p>
<p><strong>要求</strong></p>
<ul>
<li><p>层次一：选择合适的集合类去实现数据的保存，调用其内部的相关方法。</p>
</li>
<li><p>层次二：不同的集合类底层的数据结构为何？如何实现数据的操作的：增删改查等。</p>
</li>
</ul>
<h4 id="11-3-Iterator-接口"><a href="#11-3-Iterator-接口" class="headerlink" title="11.3 Iterator 接口"></a>11.3 Iterator 接口</h4><p><strong>1）遍历 Collection 的两种方式</strong></p>
<ul>
<li>使用迭代器 Iterator</li>
<li>使用 foreach 循环（增强 for 循环）</li>
</ul>
<p><strong>2）迭代器接口 Iterator</strong></p>
<ul>
<li>java.utils 包下定义的迭代器接口：Iterator</li>
<li>Iterator 对象称为迭代器（设计模式的一种），主要用于<strong>遍历 Collection 集合中的元素</strong>（作用）</li>
<li>方法<ul>
<li><code>hasNext()</code>：判断是否还下一个元素</li>
<li><code>next()</code>：① 指针下移 ② 将下移以后集合位置上的元素返回</li>
<li><code>remove()</code>：删除集合中的元素（如果还未调用 next() 或在上一次调用 next() 方法之后已经调用了 remove() 方法，再调用 remove() 就会报IllegalStateException）</li>
</ul>
</li>
</ul>
<p><strong>3）增强 for 循环（JDK5.0 新特性）</strong></p>
<ul>
<li><code>for(集合元素的类型 局部变量 : 集合对象)&#123;&#125;</code></li>
<li>内部仍然调用了迭代器。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">12</span>, <span class="number">34</span>, <span class="number">43</span>, <span class="number">93</span>, <span class="number">32</span>);</span><br><span class="line"><span class="comment">// 使用迭代器遍历</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用增强 for 循环遍历</span></span><br><span class="line"><span class="keyword">for</span> (Integer num : list) &#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="11-4-List-接口"><a href="#11-4-List-接口" class="headerlink" title="11.4 List 接口"></a>11.4 List 接口</h4><p>存储有序的、可重复的数据</p>
<p><strong>1）常用方法</strong></p>
<ul>
<li>增：<code>add(Object obj)</code></li>
<li>删：<code>remove(int index)</code> &#x2F; <code>remove(Object obj)</code></li>
<li>改：<code>set(int index, Object ele)</code></li>
<li>查：<code>get(int index)</code></li>
<li>插：<code>add(int index, Object ele)</code></li>
<li>长度：<code>size()</code></li>
<li>遍历：① Iterator 迭代器方式；② 增强 for 循环；③ 普通的循环</li>
</ul>
<p><strong>2）常用的实现类</strong></p>
<ul>
<li>ArrayList：作为 List 接口的主要实现类；线程不安全的，效率高；底层使用 Object[] elementData 存储</li>
<li>LinkedList：对于频繁的插入、删除操作，使用此类效率比 ArrayList 高；底层使用双向链表存储</li>
<li>Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用 Object[] elementData 存储</li>
</ul>
<p><strong>3）源码分析</strong></p>
<p><strong>ArrayList</strong></p>
<ul>
<li>JDK 7 情况下<ul>
<li><code>ArrayList list = new ArrayList();</code>&#x2F;&#x2F; 底层创建了<strong>长度为10</strong> 的 Object[] elementData 数组</li>
<li><code>list.add(123);</code> &#x2F;&#x2F; elementData[0] &#x3D; new Integer(123);</li>
<li>如果此次的添加导致底层 elementData 数组容量不够，则扩容。</li>
<li>默认情况下，扩容为<strong>原来的容量的 1.5 倍</strong>，同时需要将原有数组中的数据复制到新的数组中。</li>
<li>结论：建议开发中使用带参的构造器：<code>ArrayList list = new ArrayList(int capacity)</code></li>
</ul>
</li>
<li>JDK 8 中的变化：<ul>
<li><code>ArrayList list = new ArrayList();</code>&#x2F;&#x2F; 底层 Object[] elementData 初始化为 {}，并没创建长度为10 的数组</li>
<li><code>list.add(123);</code>&#x2F;&#x2F; 第一次调用 add() 时，底层才创建了长度 10 的数组，并将数据 123 添加到 elementData[0]</li>
<li>后续的添加和扩容操作与 JDK 7 无异。</li>
</ul>
</li>
<li><strong>小结</strong>：JDK 7 中的 ArrayList 的对象的创建类似于单例的饿汉式，而 JDK 8 中的 ArrayList 的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</li>
</ul>
<p><strong>LinkedList</strong></p>
<ul>
<li><p><code>LinkedList list = new LinkedList();</code> 内部声明了 Node 类型的 first 和 last 属性，默认值为 null</p>
</li>
<li><p><code>list.add(123);</code>&#x2F;&#x2F; 将 123 封装到 Node 中，创建了 Node 对象。</p>
</li>
<li><p>其中，Node 定义为：体现了 LinkedList 的双向链表的说法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>Vector</strong></p>
<ul>
<li>JDK 7 和 JDK 8 中通过Vector()构造器创建对象时，底层都创建了**长度为 10 **的数组。</li>
<li>在扩容方面，默认扩容为原来的数组长度的2倍。</li>
</ul>
<p><strong>在添加的对象时，所在的类要重写 equals() 方法</strong></p>
<p>面试题：ArrayList、LinkedList、Vector 者的异同？</p>
<h4 id="11-5-Set-接口"><a href="#11-5-Set-接口" class="headerlink" title="11.5 Set 接口"></a>11.5 Set 接口</h4><p>无序的、不可重复的元素</p>
<p><strong>1）常用方法</strong></p>
<p>Set 接口中没额外定义新的方法，使用的都是 Collection 中声明过的方法。</p>
<p><strong>2）常用的实现类</strong></p>
<ul>
<li>HashSet：作为 Set 接口的主要实现类；线程不安全的；可以存储 null 值<ul>
<li>LinkedHashSet：作为 HashSet 的子类；遍历其内部数据时，可以按照添加的顺序遍历。在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。对于频繁的遍历操作，LinkedHashSet 效率高于 HashSet。</li>
</ul>
</li>
<li>TreeSet：可以照添加对象的指定属性，进行排序。</li>
</ul>
<p><strong>3）元素添加过程（以 HashSet 为例）</strong></p>
<p>我们向 HashSet 中添加元素 a，首先调用元素 a 所在类的 hashCode() 方法，计算元素 a 的哈希值，此哈希值接着通过某种算法计算出在 HashSet 底层数组中的存放位置（即索引位置），判断数组此位置上是否已经元素：</p>
<ul>
<li>如果此位置上没其他元素，则元素 a 添加成功。（情况1）</li>
<li>如果此位置上其他元素 b（或以链表形式存在的多个元素），则比较元素 a 与元素 b 的 hash 值：<ul>
<li>如果 hash 值不相同，则元素 a 添加成功。（情况2）</li>
<li>如果 hash 值相同，进而需要调用元素 a 所在类的 equals() 方法：<ul>
<li>equals() 返回 true,元素 a 添加失败</li>
<li>equals() 返回 false,则元素 a 添加成功。（情况3）</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>对于添加成功的情况 2 和情况 3 而言：元素 a 与已经存在指定索引位置上数据以链表的方式存储。</p>
<ul>
<li>JDK 7：元素 a 放到数组中，指向原来的元素。</li>
<li>JDK 8：原来的元素在数组中，指向元素 a</li>
<li>总结：七上八下</li>
</ul>
<p>HashSet 底层：数组 + 链表的结构。（前提：JDK 7）</p>
<p><strong>4）存储对象所在类的要求</strong></p>
<p><strong>HashSet&#x2F;LinkedHashSet</strong></p>
<ul>
<li>向 Set（主要指 HashSet、LinkedHashSet）中添加的数据，其所在的类<strong>一定要重写 hashCode() 和 equals()</strong><ul>
<li>重写的 hashCode() 和 equals() 尽可能保持一致性：相等的对象必须具有相等的散列码</li>
<li>重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</li>
</ul>
</li>
</ul>
<p><strong>TreeSet</strong></p>
<ul>
<li>自然排序中，比较两个对象是否相同的标准为：compareTo() 返回0，不再是equals()。</li>
<li>定制排序中，比较两个对象是否相同的标准为：compare() 返回0，不再是equals()。</li>
</ul>
<p><strong>5）TreeSet的使用</strong></p>
<ul>
<li>向 TreeSet 中添加的数据，要求是相同类的对象。</li>
<li>两种排序方式：自然排序（实现 Comparable 接口）和定制排序（实现 Comparator 接口）</li>
</ul>
<p><strong>常用的排序方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">comparableTest</span><span class="params">()</span> &#123;</span><br><span class="line">        Set&lt;User&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        traverseSet(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">comparatorTest</span><span class="params">()</span> &#123;</span><br><span class="line">        Comparator&lt;User&gt; comparator = Comparator.comparingInt(User::getAge);</span><br><span class="line"><span class="comment">//        Comparator&lt;User&gt; comparator = new Comparator&lt;User&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public int compare(User o1, User o2) &#123;</span></span><br><span class="line"><span class="comment">//                return Integer.compare(o1.getAge(), o2.getAge())</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"></span><br><span class="line">        TreeSet&lt;User&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(comparator);</span><br><span class="line"></span><br><span class="line">        traverseSet(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverseSet</span><span class="params">(Set set)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Mary&quot;</span>, <span class="number">24</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">34</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Arthur&quot;</span>, <span class="number">32</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">45</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Zoom&quot;</span>, <span class="number">28</span>));</span><br><span class="line"></span><br><span class="line">        Iterator&lt;User&gt; iterator = set.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) o;</span><br><span class="line">        <span class="type">return</span> <span class="variable">age</span> <span class="operator">=</span>= user.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, user.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> User) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) o;</span><br><span class="line">            <span class="type">int</span> <span class="variable">compare</span> <span class="operator">=</span> <span class="built_in">this</span>.name.compareTo(user.name);</span><br><span class="line">            <span class="keyword">if</span> (compare != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> compare;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.age, user.age);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的类型不匹配&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11-6-Map-接口"><a href="#11-6-Map-接口" class="headerlink" title="11.6 Map 接口"></a>11.6 Map 接口</h4><p>双列数据，存储 key-value 对的数据</p>
<p><strong>1）常用实现类</strong></p>
<ul>
<li>HashMap：作为 Map 的主要实现类；线程不安全的，效率高；可以存储 null 的 key 和 value<ul>
<li>LinkedHashMap：保证在遍历 map 元素时，可以照添加的顺序实现遍历。<ul>
<li><pre><code>               原因：在原的 HashMap 底层结构基础上，添加了一对指针，指向前一个和后一个元素。
</code></pre>
</li>
<li><pre><code>               对于频繁的遍历操作，此类执行效率高于 HashMap。
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>TreeMap：保证照添加的 key-value 对进行排序，实现排序遍历。此时考虑 key 的自然排序或定制排序</li>
<li>Hashtable：作为古老的实现类；线程安全的，效率低；不能存储 null 的 key 和 value<ul>
<li>Properties：常用来处理配置文件。key 和 value 都是 String 类型</li>
</ul>
</li>
</ul>
<p> <strong>HashMap 的底层</strong></p>
<ul>
<li>数组+链表（JDK 7 及之前)</li>
<li>数组+链表+红黑树（JDK 8)</li>
</ul>
<p><strong>2）存储结构的理解</strong></p>
<ul>
<li>Map 中的 key：无序的、不可重复的，使用 Set 存储所有的 key  <code>--&gt; </code> key 所在的类要重写 equals() 和 hashCode() （以 HashMap 为例)</li>
<li>Map 中的 value：无序的、可重复的，使用 Collection 存储所的 value <code>--&gt;</code> value 所在的类要重写 equals()</li>
<li>一个键值对 key-value 构成了一个 Entry 对象。</li>
<li>Map 中的 entry：无序的、不可重复的，使用 Set 存储所的 entry</li>
</ul>
<p><strong>3）常用方法</strong></p>
<ul>
<li>添加：<code>put(Object key, Object value)</code></li>
<li>删除：<code>remove(Object key)</code></li>
<li>修改：<code>put(Object key, Object value)</code></li>
<li>查询：<code>get(Object key)</code></li>
<li>长度：<code>size()</code></li>
<li>遍历：<code>keySet()</code> &#x2F; <code>values()</code> &#x2F;<code> entrySet()</code></li>
</ul>
<p><strong>4）内存结构说明</strong></p>
<p><strong>HashMap</strong></p>
<p><strong>① 在 JDK 7 中实现原理</strong></p>
<ul>
<li><pre><code> `HashMap map = new HashMap()`：在实例化以后，底层创建了**长度为16** 的一维数组 Entry[] table。
</code></pre>
</li>
<li><pre><code> `map.put(key1, value1)`：**首先**，调用 key1 所在类的 hashCode() 计算 key1 哈希值，此哈希值经过某种算法计算以后，得到在 Entry 数组中的存放位置。
 *      如果此位置上的数据为空，此时的 key1-value1 添加成功。（情况1）
 *      如果此位置上的数据不为空（意味着此位置上存在一个或多个数据（以链表形式存在）），比较 key1 和已经存在的一个或多个数据的哈希值：
        *              如果 key1 的哈希值与已经存在的数据的哈希值都不相同，此时 key1-value1 添加成功。（情况2）
        *              如果 key1 的哈希值和已经存在的某一个数据（key2-value2）的哈希值相同，继续比较：调用 key1.equals(key2) 方法，比较：
        *                      如果 equals() 返回 false：此时 key1-value1 添加成功。（情况3）
        *      如果 equals() 返回 true：使用 value1 替换 value2。
</code></pre>
</li>
</ul>
<p>关于情况2和情况3：此时 key1-value1 和原来的数据以链表的方式存储。</p>
<p>在不断的添加过程中，会涉及到扩容问题，当超出临界值（且要存放的位置非空）时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原的数据复制过来。</p>
<p><strong>② 在 JDK 8 中相较于 JDK 7 在底层实现方面的不同：</strong></p>
<ol>
<li>new HashMap()：底层没创建一个长度为 16 的数组</li>
<li>JDK 8底层的数组是：Node[]，而非 Entry[]</li>
<li>首次调用 put() 方法时，底层创建长度为 16 的数组</li>
<li>JDK 7 中底层结构：数组+链表；JDK 8 中底层结构：数组+链表+红黑树。</li>
<li>形成链表时，七上八下（JDK 7：新的元素指向旧的元素；JDK 8：旧的元素指向新的元素）</li>
<li>当数组的某一个索引位置上的元素（以链表形式存在的数据个数 &gt; 8）且（当前数组的长度 &gt; 64）时，此时此索引位置上的所数据改为使用红黑树存储</li>
</ol>
<p><strong>③ HashMap 底层典型属性的属性的说明</strong></p>
<ul>
<li>DEFAULT_INITIAL_CAPACITY : HashMap 的默认容量，16</li>
<li>DEFAULT_LOAD_FACTOR：HashMap 的默认加载因子，0.75</li>
<li>threshold：扩容的临界值 &#x3D; 容量 * 填充因子 &#x3D; 16 * 0.75 &#x3D; 12</li>
<li>TREEIFY_THRESHOLD：Bucket 中链表长度大于该默认值，转化为红黑树，8</li>
<li>MIN_TREEIFY_CAPACITY：桶中的 Node 被树化时最小的 hash 表容量，64</li>
</ul>
<p><strong>LinkedHashMap</strong></p>
<ul>
<li>LinkedHashMap 底层使用的结构与 HashMap 相同，因为 LinkedHashMap 继承于 HashMap。区别就在于：LinkedHashMap 内部提供了 Entry，替换 HashMap 中的 Node</li>
</ul>
<p><img src="/.io//image%5Cimage-20210206140413853.png" alt="image-20210206140413853"></p>
<p><strong>TreeMap</strong></p>
<ul>
<li>TreeMap 中添加 key-value，要求 key 必须是由同一个类创建的对象</li>
<li>因为要按照 key 进行排序：自然排序 、定制排序</li>
</ul>
<p><strong>Properties</strong></p>
<ul>
<li>常用来处理配置文件。key 和 value 都是 String 类型</li>
</ul>
<h4 id="11-7-Collections-工具类"><a href="#11-7-Collections-工具类" class="headerlink" title="11.7 Collections 工具类"></a>11.7 Collections 工具类</h4><ul>
<li>操作 Collection 和 Map 的工具类</li>
</ul>
<p><strong>常用方法</strong></p>
<ul>
<li><code>reverse(List)</code>：反转 List 中元素的顺序</li>
<li><code>shuffle(List)</code>：对 List 集合元素进行随机排序</li>
<li><code>sort(List)</code>：根据元素的自然顺序对指定 List 集合元素升序排序</li>
<li><code>sort(List，Comparator)</code>：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li>
<li><code>swap(List，int， int)</code>：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li>
<li><code>Object max(Collection)</code>：根据元素的自然顺序，返回给定集合中的最大元素</li>
<li><code>Object max(Collection，Comparator)</code>：根据 Comparator 指定的顺序，返回给定集合中的最大元素</li>
<li><code>Object min(Collection)</code></li>
<li><code>Object min(Collection，Comparator)</code></li>
<li><code>int frequency(Collection，Object)</code>：返回指定集合中指定元素的出现次数</li>
<li><code>void copy(List dest,List src)</code>：将src中的内容复制到dest中</li>
<li><code>boolean replaceAll(List list，Object oldVal，Object newVal)</code>：使用新值替换 List 对象的所旧值</li>
</ul>
<p><strong>ArrayList 和 HashMap 都是线程不安全的，如果程序要求线程安全，我们可以使用 synchronizedList(List list) 和 synchronizedMap(Map map) 将 ArrayList、HashMap 转换为线程安全的。</strong></p>
<h3 id="第12章-泛型（Generics）"><a href="#第12章-泛型（Generics）" class="headerlink" title="第12章 泛型（Generics）"></a>第12章 泛型（Generics）</h3><h4 id="12-1-概念"><a href="#12-1-概念" class="headerlink" title="12.1 概念"></a>12.1 概念</h4><ul>
<li>所谓泛型，就是允许在定义类、接口时通过一个<strong>标识</strong>表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。</li>
</ul>
<p><strong>泛型的引入背景</strong></p>
<ul>
<li>集合容器类在设计阶段和声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在 JDK1.5 之前只能把元素类型设计为 Object，JDK1.5 之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做<strong>泛型</strong>。<code>Collection&lt;E&gt;</code>，<code>List&lt;E&gt;</code>，<code>ArrayList&lt;E&gt;</code>   这个 <code>&lt;E&gt;</code> 就是<strong>类型参数</strong>，即<strong>泛型</strong>。</li>
</ul>
<h4 id="12-2-泛型在集合中的使用"><a href="#12-2-泛型在集合中的使用" class="headerlink" title="12.2 泛型在集合中的使用"></a>12.2 泛型在集合中的使用</h4><img src="/.io//没有泛型的集合.png" alt="没有泛型的集合" style="zoom:200%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">// 需求：存放学生的成绩</span></span><br><span class="line">    list.add(<span class="number">78</span>);</span><br><span class="line">    list.add(<span class="number">76</span>);</span><br><span class="line">    <span class="comment">// 问题一：类型不安全</span></span><br><span class="line">    <span class="comment">// list.add(&quot;Tom&quot;);</span></span><br><span class="line">    <span class="keyword">for</span>(Object score : list)&#123;</span><br><span class="line">        <span class="comment">// 问题二：强转时，可能出现 ClassCastException</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> (Integer) score;</span><br><span class="line">        System.out.println(stuScore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/.io//有泛型的集合.png" alt="有泛型的集合" style="zoom:200%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list =  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">	<span class="comment">// 需求：存放学生的成绩</span></span><br><span class="line">    list.add(<span class="number">78</span>);</span><br><span class="line">    list.add(<span class="number">87</span>);</span><br><span class="line">    <span class="comment">// 编译时，就会进行类型检查，保证数据的安全</span></span><br><span class="line">    <span class="comment">// list.add(&quot;Tom&quot;);</span></span><br><span class="line">    <span class="comment">// 方式一：</span></span><br><span class="line">    <span class="comment">//for(Integer score : list)&#123;</span></span><br><span class="line">    <span class="comment">//        // 避免了强转操作</span></span><br><span class="line">    <span class="comment">//        System.out.println(score);</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">// 方式二：</span></span><br><span class="line">    Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(stuScore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();</span></span><br><span class="line">    <span class="comment">// jdk7 新特性：类型推断</span></span><br><span class="line">    Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;Tom&quot;</span>,<span class="number">87</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Jerry&quot;</span>,<span class="number">87</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Jack&quot;</span>,<span class="number">67</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map.put(123,&quot;ABC&quot;);</span></span><br><span class="line">    <span class="comment">// 泛型的嵌套</span></span><br><span class="line">    Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entry = map.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entry.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; e = iterator.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">        System.out.println(key + <span class="string">&quot;----&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>集合中使用泛型总结</strong></p>
<ul>
<li><p>集合接口或集合类在 JDK 5.0 时都修改为带泛型的结构。</p>
</li>
<li><p>在实例化集合类时，可以指明具体的泛型类型</p>
</li>
<li><p>指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。</p>
<ul>
<li>比如：<code>add(E e)  --&gt; 实例化以后：add(Integer e)</code></li>
</ul>
</li>
<li><p>注意点：泛型的类型必须是<strong>类</strong>，不能是基本数据类型。需要用到基本数据类型的位置，拿<strong>包装类</strong>替换。</p>
</li>
<li><p>如果实例化时，没指明泛型的类型。默认类型为 <code>java.lang.Object</code> 类型。</p>
</li>
</ul>
<h4 id="12-3-自定义泛型类、泛型接口、泛型方法"><a href="#12-3-自定义泛型类、泛型接口、泛型方法" class="headerlink" title="12.3 自定义泛型类、泛型接口、泛型方法"></a>12.3 自定义泛型类、泛型接口、泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsClass</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 类的内部结构就可以使用类的泛型</span></span><br><span class="line">    T field;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        T a = new T(); // Type parameter &#x27;T&#x27; cannot be instantiated directly</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">a</span> <span class="operator">=</span> (T)<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GenericsClass</span><span class="params">(T field)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.field = field;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setField</span><span class="params">(T field)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.field = field;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态方法中不能使用类的泛型</span></span><br><span class="line">    <span class="comment">// &#x27;com.ding.generics.GenericsClass.this&#x27; cannot be referenced from a static context</span></span><br><span class="line"><span class="comment">//    public static void staticMethod(T field) &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(field);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericsInterface</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#x27;com.ding.generics.GenericsInterface.this&#x27; cannot be referenced from a static context</span></span><br><span class="line"><span class="comment">//    T field;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// public static final </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(T t)</span>; <span class="comment">// public abstract</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span>&#123;&#125;; <span class="comment">// public</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">genericsMethod</span><span class="params">(T t)</span> &#123;</span><br><span class="line"><span class="comment">//   return new T();// Type parameter &#x27;T&#x27; cannot be instantiated directly</span></span><br><span class="line">    <span class="keyword">return</span> (T)<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没任何关系。换句话说，泛型方法所属的类是不是泛型类都没关系。</p>
</li>
<li><p>泛型方法可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。</p>
</li>
</ul>
<h4 id="12-4-泛型在继承上的体现"><a href="#12-4-泛型在继承上的体现" class="headerlink" title="12.4 泛型在继承上的体现"></a>12.4 泛型在继承上的体现</h4><ul>
<li>虽然类 A 是类 B 的父类，但是 <code>G&lt;A&gt;</code> 和 <code>G&lt;B&gt;</code> 二者不具备子父类关系，二者是并列关系。类 A 是类 B 的父类，<code>A&lt;G&gt;</code> 是 <code>B&lt;G&gt;</code> 的父类.</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    obj = str;</span><br><span class="line"></span><br><span class="line">    Object[] arr1 = <span class="literal">null</span>;</span><br><span class="line">    String[] arr2 = <span class="literal">null</span>;</span><br><span class="line">    arr1 = arr2;</span><br><span class="line">    <span class="comment">// 编译不通过</span></span><br><span class="line">    <span class="comment">//        Date date = new Date();</span></span><br><span class="line">    <span class="comment">//        str = date;</span></span><br><span class="line">    List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 此时的list1和list2的类型不具子父类关系</span></span><br><span class="line">    <span class="comment">// 编译不通过</span></span><br><span class="line">    <span class="comment">//        list1 = list2;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        反证法：</span></span><br><span class="line"><span class="comment">        假设 list1 = list2;</span></span><br><span class="line"><span class="comment">           list1.add(123);导致混入非 String 的数据。出错。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    show(list1);</span><br><span class="line">    show1(list2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">(List&lt;String&gt; list)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(List&lt;Object&gt; list)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    AbstractList&lt;String&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">    ArrayList&lt;String&gt; list3 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    list1 = list3;</span><br><span class="line">    list2 = list3;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-5-通配符"><a href="#12-5-通配符" class="headerlink" title="12.5 通配符 ?"></a>12.5 通配符 ?</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    通配符的使用  </span></span><br><span class="line"><span class="comment">       1. 类 A 是类 B 的父类，G&lt;A&gt; 和 G&lt;B&gt; 是没关系的，二者共同的父类是：G&lt;?&gt;</span></span><br><span class="line"><span class="comment">       2. 涉及通配符的集合的数据的写入和读取</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    list = list1;</span><br><span class="line">    list = list2;</span><br><span class="line">    <span class="comment">//编译通过</span></span><br><span class="line">    <span class="comment">//        print(list1);</span></span><br><span class="line">    <span class="comment">//        print(list2);</span></span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list3.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    list3.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    list3.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    list = list3;</span><br><span class="line">    <span class="comment">// 添加(写入)：对于 List&lt;?&gt; 就不能向其内部添加数据。</span></span><br><span class="line">    <span class="comment">// 除了添加null之外。</span></span><br><span class="line">    <span class="comment">// list.add(&quot;DD&quot;);</span></span><br><span class="line">    <span class="comment">// list.add(&#x27;?&#x27;);</span></span><br><span class="line"></span><br><span class="line">    list.add(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取(读取)：允许读取数据，读取的数据类型为Object。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">    System.out.println(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;?&gt; list)</span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	限制条件的通配符的使用：</span></span><br><span class="line"><span class="comment">        ? extends A:  G&lt;? extends A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的子类</span></span><br><span class="line"><span class="comment">        ? super A: G&lt;? super A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;? <span class="built_in">super</span> Person&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Student&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line">    List&lt;Person&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">    List&lt;Object&gt; list5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    list1 = list3;</span><br><span class="line">    list1 = list4;</span><br><span class="line">    <span class="comment">//        list1 = list5;</span></span><br><span class="line">    <span class="comment">//        list2 = list3;</span></span><br><span class="line">    list2 = list4;</span><br><span class="line">    list2 = list5;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据：</span></span><br><span class="line">    list1 = list3;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> list1.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 编译不通过</span></span><br><span class="line">    <span class="comment">// Student s = list1.get(0);</span></span><br><span class="line"></span><br><span class="line">    list2 = list4;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list2.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 编译不通过</span></span><br><span class="line">    <span class="comment">//        Person obj = list2.get(0);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据：</span></span><br><span class="line">    <span class="comment">// 编译不通过</span></span><br><span class="line">    <span class="comment">//        list1.add(new Student());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//编译通过</span></span><br><span class="line">    list2.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">    list2.add(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">&#125;	 </span><br></pre></td></tr></table></figure>

<h3 id="第13章-IO-流"><a href="#第13章-IO-流" class="headerlink" title="第13章 IO 流"></a>第13章 IO 流</h3><h4 id="13-1-File-类的使用"><a href="#13-1-File-类的使用" class="headerlink" title="13.1 File 类的使用"></a>13.1 File 类的使用</h4><p><strong>1）File 类的理解</strong></p>
<ol>
<li><p>File 类的一个对象，代表一个<strong>文件</strong>或一个<strong>文件目录</strong>（俗称：文件夹）。</p>
</li>
<li><p>File 类声明在 java.io 包下。</p>
</li>
<li><p>File 类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间和文件大小等方法，并<strong>未涉及到写入或读取文件内容的操作</strong>。如果需要读取或写入文件内容，必须使用IO流来完成。</p>
</li>
<li><p>File 类的对象常会作为参数传递到流的构造器中，指明读取或写入的 “终点”。</p>
</li>
</ol>
<p><strong>2）File 的实例化</strong></p>
<p><strong>常用构造器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File(String filePath)</span><br><span class="line">File(String parentPath, String childPath)</span><br><span class="line">File(File parentFile, String childPath)</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>路径的分类</strong></p>
<p><strong>相对路径</strong>：相较于某个路径下，指明的路径。</p>
<p><strong>绝对路径</strong>：包含盘符在内的文件或文件目录的路径。</p>
<p><strong>路径分隔符</strong></p>
<p><strong>windows 和 DOS</strong> 系统默认使用 “\” 来表示</p>
<p><strong>UNIX 和 URL</strong> 使用 “&#x2F;” 来表示</p>
</blockquote>
<p><strong>说明</strong></p>
<p><strong>IDEA 中</strong>：使用 <strong>JUnit</strong> 中的单元测试方法测试，相对路径即为当前 <strong>Module</strong> 下；使用 <strong>main()</strong> 测试，相对路径即为当前的 <strong>Project</strong> 下。</p>
<p><strong>Eclipse 中</strong>：不管使用单元测试方法还是使用 main() 测试，相对路径都是当前的 Project 下。</p>
<p><strong>3）File 类的常用方法</strong></p>
<p><strong>获取功能</strong><br><strong><code>public String getAbsolutePath()</code>：获取绝对路径。</strong></p>
<p><code>public String getPath()</code>：获取路径。</p>
<p><code>public String getName()</code>：获取名称。</p>
<p><strong><code>public String getParent()</code>：获取上层文件目录路径。若无，返回 null。</strong></p>
<p><code>public long length()</code>：获取文件长度（即，字节数）。不能获取目录的长度。</p>
<p><code>public long lastModified()</code>：获取最后一次修改的时间（毫秒值）。</p>
<p><code>public String list[]</code>：获取指定目录下的所有文件或者文件目录的名称数组。</p>
<p><code>public File[] listFiles()</code>：获取指定目录下的所有文件或者文件目录的 File 数组。</p>
<p><strong>重命名功能</strong><br><code>public boolean renameTo(File dest)</code>：把文件重命名为指定的文件路径。</p>
<p><strong>判断功能</strong></p>
<p><strong><code>public boolean isDirectory()</code>：判断是否为文件目录。</strong></p>
<p><strong><code>public boolean isFile()</code>：判断是否为文件。</strong></p>
<p><strong><code>public boolean existst()</code>：判断是否存在。</strong></p>
<p><code>public boolean canRead()</code>：判断是否可读。</p>
<p><code>public boolean canWrite()</code>：判断是否可写。</p>
<p><code>public boolean isHidden()</code>：判断是否隐藏。</p>
<p><strong>创建功能</strong></p>
<p><strong><code>public boolean createNewFile()</code>：创建文件。若文件存在，则不创建，返回 false。</strong></p>
<p><code>public boolean mkdir()</code>：创建文件目录。如果此文件存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。</p>
<p><strong><code>public boolean mkdirs()</code>：创建文件目录。如果上层文件目录不存在，一并创建。</strong></p>
<p><strong>删除功能</strong><br><strong><code>public boolean delete()</code>：删除文件或文件夹。一经删除，不可恢复。不能删除包含文件或者文件目录的文件目录。</strong></p>
<h4 id="13-2-IO-流概述"><a href="#13-2-IO-流概述" class="headerlink" title="13.2 IO 流概述"></a>13.2 IO 流概述</h4><p><strong>1）流的分类</strong></p>
<p>按操作数据单位：字节流、字符流。</p>
<p>按数据的流向：输入流、输出流。</p>
<p>按流的角色：节点流、处理流。</p>
<img src="/.io//流的分类.png" alt="流的分类" style="zoom:200%;">

<p><strong>2）流的体系结构</strong></p>
<img src="/.io//流的体系结构.png" alt="流的体系结构" style="zoom:200%;">

<p><strong>重点流结构</strong></p>
<img src="/.io//重点流结构.png" alt="重点流结构" style="zoom:200%;">

<p><strong>3）输入输出的标准化过程</strong></p>
<p><strong>输入过程</strong></p>
<p>① 创建 File 类的对象，指明读取的数据的来源。（要求此文件一定要存在）</p>
<p>② 创建<strong>相应的</strong>输入流，将 File 类的对象作为参数，传入流的构造器中。</p>
<p>③ 具体的读入过程：    创建相应的 <strong>byte[]</strong> 或 **char[]**。</p>
<p>④ <strong>关闭流资源</strong></p>
<p><strong>说明</strong>：程序中出现的异常需要使用 try-catch-finally 处理。</p>
<p><strong>输出过程</strong></p>
<p>① 创建File类的对象，指明写出的数据的位置。（不要求此文件一定要存在）。</p>
<p>② 创建相应的输出流，将File类的对象作为参数，传入流的构造器中。</p>
<p>③ 具体的写出过程：    write(char[] &#x2F; byte[] buffer, 0, len)。</p>
<p>④ <strong>关闭流资源</strong></p>
<p><strong>说明</strong>：程序中出现的异常需要使用 try-catch-finally 处理。</p>
<h4 id="13-3-节点流（文件流）"><a href="#13-3-节点流（文件流）" class="headerlink" title="13.3 节点流（文件流）"></a>13.3 节点流（文件流）</h4><p><strong>1）FileReader &#x2F; FileWriter 的使用</strong></p>
<p><strong>FileReader 的使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将 hello.txt 文件内容读入程序中，并输出到控制台</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">说明点：</span></span><br><span class="line"><span class="comment">1. read()的理解：返回读入的一个字符。如果达到文件末尾，返回-1</span></span><br><span class="line"><span class="comment">2. 异常的处理：为了保证流资源一定可以执行关闭操作。需要使用 try-catch-finally 处理</span></span><br><span class="line"><span class="comment">3. 读入的文件一定要存在，否则就会报FileNotFoundException。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReader1</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.File类的实例化</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//2.FileReader流的实例化</span></span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">        <span class="comment">//3.读入的操作</span></span><br><span class="line">        <span class="comment">//read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//方式一：</span></span><br><span class="line">            <span class="comment">//错误的写法</span></span><br><span class="line">            <span class="comment">//                for(int i = 0;i &lt; cbuf.length;i++)&#123;</span></span><br><span class="line">            <span class="comment">//                    System.out.print(cbuf[i]);</span></span><br><span class="line">            <span class="comment">//                &#125;</span></span><br><span class="line">            <span class="comment">//正确的写法</span></span><br><span class="line">            <span class="comment">//                for(int i = 0;i &lt; len;i++)&#123;</span></span><br><span class="line">            <span class="comment">//                    System.out.print(cbuf[i]);</span></span><br><span class="line">            <span class="comment">//                &#125;</span></span><br><span class="line">            <span class="comment">//方式二：</span></span><br><span class="line">            <span class="comment">//错误的写法,对应着方式一的错误的写法</span></span><br><span class="line">            <span class="comment">//                String str = new String(cbuf);</span></span><br><span class="line">            <span class="comment">//                System.out.print(str);</span></span><br><span class="line">            <span class="comment">//正确的写法</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//4.资源的关闭</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>FileWriter 的使用</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从内存中写出数据到硬盘的文件里。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">1. 输出操作，对应的File可以不存在的。并不会报异常</span></span><br><span class="line"><span class="comment">2.</span></span><br><span class="line"><span class="comment">     File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。</span></span><br><span class="line"><span class="comment">     File对应的硬盘中的文件如果存在：</span></span><br><span class="line"><span class="comment">           如果流使用的构造器是：FileWriter(file,false) / FileWriter(file):对原文件的覆盖</span></span><br><span class="line"><span class="comment">           如果流使用的构造器是：FileWriter(file,true):不会对原文件覆盖，而是在原文件基础上追加内容</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.提供File类的对象，指明写出到的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//2.提供FileWriter的对象，用于数据的写出</span></span><br><span class="line">        fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//3.写出的操作</span></span><br><span class="line">        fw.write(<span class="string">&quot;I have a dream!\n&quot;</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;you need to have a dream!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.流资源的关闭</span></span><br><span class="line">        <span class="keyword">if</span>(fw != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>文本文件的复制</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReaderFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建File类的对象，指明读入和写出的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello2.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//不能使用字符流来处理图片等字节数据</span></span><br><span class="line">        <span class="comment">//            File srcFile = new File(&quot;爱情与友情.jpg&quot;);</span></span><br><span class="line">        <span class="comment">//            File destFile = new File(&quot;爱情与友情1.jpg&quot;);</span></span><br><span class="line">        <span class="comment">//2.创建输入流和输出流的对象</span></span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFile);</span><br><span class="line">        fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFile);</span><br><span class="line">        <span class="comment">//3.数据的读入和写出操作</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;<span class="comment">//记录每次读入到cbuf数组中的字符的个数</span></span><br><span class="line">        <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//每次写出len个字符</span></span><br><span class="line">            fw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关闭流资源</span></span><br><span class="line">        <span class="comment">//方式一：</span></span><br><span class="line">        <span class="comment">//            try &#123;</span></span><br><span class="line">        <span class="comment">//                if(fw != null)</span></span><br><span class="line">        <span class="comment">//                    fw.close();</span></span><br><span class="line">        <span class="comment">//            &#125; catch (IOException e) &#123;</span></span><br><span class="line">        <span class="comment">//                e.printStackTrace();</span></span><br><span class="line">        <span class="comment">//            &#125;finally&#123;</span></span><br><span class="line">        <span class="comment">//                try &#123;</span></span><br><span class="line">        <span class="comment">//                    if(fr != null)</span></span><br><span class="line">        <span class="comment">//                        fr.close();</span></span><br><span class="line">        <span class="comment">//                &#125; catch (IOException e) &#123;</span></span><br><span class="line">        <span class="comment">//                    e.printStackTrace();</span></span><br><span class="line">        <span class="comment">//                &#125;</span></span><br><span class="line">        <span class="comment">//            &#125;</span></span><br><span class="line">        <span class="comment">//方式二：</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fw != <span class="literal">null</span>)</span><br><span class="line">                fw.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="literal">null</span>)</span><br><span class="line">                fr.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2）FileInputStream &#x2F; FileOutputStream 的使用</strong></p>
<p>对于<strong>文本文件</strong>（.txt,.java,.c,.cpp），使用<strong>字符流处理</strong>。</p>
<p>对于<strong>非文本文件</strong>（.jpg,.mp3,.mp4,.avi,.doc,.ppt,…），使用<strong>字节流处理</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实现对图片的复制操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileInputOutputStream</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情.jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情1.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">//2.造流</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">        <span class="comment">//3.复制的过程</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//4.关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：相对路径在IDEA和Eclipse中使用的区别？</p>
<p>IDEA:</p>
<p>如果使用单元测试方法，相对路径基于当前的 Module 的。</p>
<p>如果使用 main() 测试，相对路径基于当前 Project 的。</p>
<p>Eclipse:</p>
<p>单元测试方法还是 main()，相对路径都是基于当前 Project 的。</p>
</blockquote>
<h4 id="13-4-缓冲流"><a href="#13-4-缓冲流" class="headerlink" title="13.4 缓冲流"></a>13.4 缓冲流</h4><p><strong>1）缓冲流介绍</strong></p>
<p>涉及到的类：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter。</p>
<p>作用：提供流的读取、写入的速度。</p>
<p>提高读写速度的原因：内部提供了一个<strong>缓冲区</strong>。默认情况下是 8kb。</p>
<p><strong>2）典型代码</strong></p>
<p><strong>使用 BufferedInputStream 和 BufferedOutputStream 处理非文本文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现文件复制的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFileWithBuffered</span><span class="params">(String srcPath,String destPath)</span>&#123;</span><br><span class="line">    <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(srcPath);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destPath);</span><br><span class="line">        <span class="comment">//2.造流</span></span><br><span class="line">        <span class="comment">//2.1 造节点流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>((srcFile));</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">        <span class="comment">//2.2 造缓冲流</span></span><br><span class="line">        bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">        bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line">        <span class="comment">//3.复制的细节：读取、写入</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.资源关闭</span></span><br><span class="line">        <span class="comment">//要求：先关闭外层的流，再关闭内层的流</span></span><br><span class="line">        <span class="keyword">if</span>(bos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.</span></span><br><span class="line">        <span class="comment">//        fos.close();</span></span><br><span class="line">        <span class="comment">//        fis.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>使用 BufferedReader 和 BufferedWriter 处理文本文件</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBufferedReaderBufferedWriter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建文件和相应的流</span></span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp.txt&quot;</span>)));</span><br><span class="line">        bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp1.txt&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.读写操作</span></span><br><span class="line">        <span class="comment">//方式一：使用char[]数组</span></span><br><span class="line">        <span class="comment">//            char[] cbuf = new char[1024];</span></span><br><span class="line">        <span class="comment">//            int len;</span></span><br><span class="line">        <span class="comment">//            while((len = br.read(cbuf)) != -1)&#123;</span></span><br><span class="line">        <span class="comment">//                bw.write(cbuf,0,len);</span></span><br><span class="line">        <span class="comment">//    //            bw.flush();</span></span><br><span class="line">        <span class="comment">//            &#125;</span></span><br><span class="line">        <span class="comment">//方式二：使用String</span></span><br><span class="line">        String data;</span><br><span class="line">        <span class="keyword">while</span>((data = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//方法一：</span></span><br><span class="line">            <span class="comment">//                bw.write(data + &quot;\n&quot;);//data中不包含换行符</span></span><br><span class="line">            <span class="comment">//方法二：</span></span><br><span class="line">            bw.write(data);<span class="comment">//data中不包含换行符</span></span><br><span class="line">            bw.newLine();<span class="comment">//提供换行的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3.关闭资源</span></span><br><span class="line">        <span class="keyword">if</span>(bw != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(br != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="13-5-转换流"><a href="#13-5-转换流" class="headerlink" title="13.5 转换流"></a>13.5 转换流</h4><p><strong>1）转换流介绍</strong></p>
<p>转换流属于字符流。</p>
<p>涉及到的类：</p>
<p>InputStreamReader（将一个字节的输入流转换为字符的输入流）。</p>
<p>解码：<code>字节、字节数组  ---&gt; 字符数组、字符串</code>。</p>
<p>OutputStreamWriter（将一个字符的输出流转换为字节的输出流）。</p>
<p>编码：<code>字符数组、字符串 ---&gt; 字节、字节数组。</code></p>
<p>说明：编码决定了解码的方式。</p>
<p><strong>作用</strong>：提供字节流与字符流之间的转换。</p>
<img src="/.io//转换流.png" alt="转换流" style="zoom:200%;">

<p><strong>2）典型实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//        InputStreamReader isr = new InputStreamReader(fis);//使用系统默认的字符集</span></span><br><span class="line">    <span class="comment">//参数2指明了字符集，具体使用哪个字符集，取决于文件dbcp.txt保存时使用的字符集</span></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis,<span class="string">&quot;UTF-8&quot;</span>);<span class="comment">//使用系统默认的字符集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len);</span><br><span class="line">        System.out.print(str);</span><br><span class="line">    &#125;</span><br><span class="line">    isr.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">此时处理异常的话，仍然应该使用try-catch-finally</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">综合使用InputStreamReader和OutputStreamWriter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1.造文件、造流</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp_gbk.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file1);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file2);</span><br><span class="line"></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos,<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">    <span class="comment">//2.读写过程</span></span><br><span class="line">    <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.关闭资源</span></span><br><span class="line">    isr.close();</span><br><span class="line">    osw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>常见的编码表</strong></p>
<p>ASCII：美国标准信息交换码。用一个字节的 7 位可以表示。</p>
<p>ISO8859-1：拉丁码表。欧洲码表，用一个字节的 8 位表示。</p>
<p>GB2312：中国的中文编码表。<strong>最多两个字节</strong>编码所有字符。</p>
<p>GBK：中国的中文编码表升级，融合了更多的中文文字符号。<strong>最多两个字节</strong>编码。</p>
<p>Unicode：国际标准码，融合了目前人类使用的所字符。为每个字符分配唯一的字符码。所有的文字都用<strong>两个字节</strong>来表示。</p>
<p>UTF-8：<strong>变长</strong>的编码方式，可用 1-4 个字节来表示一个字符。</p>
</blockquote>
<h4 id="13-6-对象流"><a href="#13-6-对象流" class="headerlink" title="13.6 对象流"></a>13.6 对象流</h4><p><strong>1）对象流介绍</strong></p>
<p><strong>ObjectInputStream 和 ObjectOutputStream</strong></p>
<ul>
<li><p>ObjectOutputStream：<code>内存中的对象 --&gt; 存储中的文件、通过网络传输出去</code>（序列化过程）。</p>
</li>
<li><p>ObjectInputStream：<code>存储中的文件、通过网络接收过来 --&gt; 内存中的对象</code>（反序列化过程）。</p>
</li>
</ul>
<p><strong>对象的序列化机制</strong></p>
<p>对象序列化机制允许把内存中的 <strong>Java 对象</strong>转换成平台无关的<strong>二进制流</strong>，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的 Java 对象。</p>
<p><strong>2）序列化代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectOutputStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我爱北京天安门&quot;</span>));</span><br><span class="line">        oos.flush();<span class="comment">//刷新操作</span></span><br><span class="line"></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王铭&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张学良&quot;</span>,<span class="number">23</span>,<span class="number">1001</span>,<span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">5000</span>)));</span><br><span class="line">        oos.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(oos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//3.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3）反序列化代码实现</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectInputStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ois != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现序列化的对象所属的类需要满足：</p>
<ol>
<li>需要实现接口：Serializable</li>
<li>当前类提供一个全局常量：serialVersionUID</li>
<li>除了当前Person类需要实现 Serializable 接口之外，还必须保证其内部所属性也必须是可序列化的。（默认情况下，基本数据类型可序列化）</li>
</ol>
<p><strong>ObjectOutputStream 和 ObjectInputStream 不能序列化 static 和 transient 修饰的成员变量。</strong></p>
</blockquote>
<h4 id="13-7-其他流"><a href="#13-7-其他流" class="headerlink" title="13.7 其他流"></a>13.7 其他流</h4><p><strong>1）标准的输入输出流</strong></p>
<p><code>System.in</code>：标准的输入流，默认从键盘输入。</p>
<p><code>System.out</code>：标准的输出流，默认从控制台输出。</p>
<p><strong>修改默认的输入和输出行为</strong>：System 类的 setIn(InputStream is) &#x2F; setOut(PrintStream ps) 方式重新指定输入和输出的流。</p>
<p><strong>2）打印流</strong></p>
<p><strong>PrintStream 和 PrintWriter</strong></p>
<p>提供了一系列重载的 print() 和 println() 方法，用于多种数据类型的输出。</p>
<p>System.out 返回的是 PrintStream 的实例。</p>
<p><strong>3）数据流</strong></p>
<p><strong>DataInputStream 和 DataOutputStream</strong></p>
<p>用于读取或写出基本数据类型的变量或字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">练习：将内存中的字符串、基本数据类型的变量写出到文件中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：处理异常的话，仍然应该使用try-catch-finally.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.</span></span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.</span></span><br><span class="line">    dos.writeUTF(<span class="string">&quot;刘建辰&quot;</span>);</span><br><span class="line">    dos.flush();<span class="comment">//刷新操作，将内存中的数据写入文件</span></span><br><span class="line">    dos.writeInt(<span class="number">23</span>);</span><br><span class="line">    dos.flush();</span><br><span class="line">    dos.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">    dos.flush();</span><br><span class="line">    <span class="comment">// 3.</span></span><br><span class="line">    dos.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中。</span></span><br><span class="line"><span class="comment">    注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isMale</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    System.out.println(<span class="string">&quot;age = &quot;</span> + age);</span><br><span class="line">    System.out.println(<span class="string">&quot;isMale = &quot;</span> + isMale);</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    dis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4）随机存储流</strong></p>
<p><strong>RandomAccessFile</strong></p>
<ol>
<li><p>RandomAccessFile直接继承于 java.lang.Object 类，实现了 DataInput 和 DataOutput 接口</p>
</li>
<li><p>RandomAccessFile 既可以作为一个输入流，又可以作为一个输出流</p>
</li>
<li><p>如果 RandomAccessFile 作为输出流时，写出到的文件。如果不存在，则在执行过程中自动创建。如果写出到的文件存在，则会对原文件内容进行覆盖。（默认情况下，从头覆盖）</p>
</li>
<li><p>可以通过相关的操作，实现 RandomAccessFile “插入”数据的效果。seek(int pos)</p>
</li>
</ol>
<p><strong>典型代码1</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        raf1 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情.jpg&quot;</span>),<span class="string">&quot;r&quot;</span>);</span><br><span class="line">        raf2 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情1.jpg&quot;</span>),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            raf2.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        <span class="keyword">if</span>(raf1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf1.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(raf2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf2.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>典型代码2</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用RandomAccessFile实现数据的插入效果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;hello.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">    raf1.seek(<span class="number">3</span>);<span class="comment">//将指针调到角标为3的位置</span></span><br><span class="line">    <span class="comment">//保存指针3后面的所数据到StringBuilder中</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>((<span class="type">int</span>) <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>).length());</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        builder.append(<span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>,len)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调回指针，写入“xyz”</span></span><br><span class="line">    raf1.seek(<span class="number">3</span>);</span><br><span class="line">    raf1.write(<span class="string">&quot;xyz&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将StringBuilder中的数据写入到文件中</span></span><br><span class="line">    raf1.write(builder.toString().getBytes());</span><br><span class="line"></span><br><span class="line">    raf1.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//思考：将StringBuilder替换为ByteArrayOutputStream</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="13-8-Path、Paths、Files-的使用"><a href="#13-8-Path、Paths、Files-的使用" class="headerlink" title="13.8 Path、Paths、Files 的使用"></a>13.8 Path、Paths、Files 的使用</h4><p><strong>1）Path的使用（jdk7 提供）</strong></p>
<p>Path 替换原有的 File 类。</p>
<p><strong>实例化</strong></p>
<p>Paths 类提供的静态 get() 方法用来获取 Path 对象。</p>
<p><code>static Path get(String first, String ... more)</code>：用于将多个字符串串连成路径。</p>
<p><code>static Path get(URI uri)</code>：返回指定 uri 对应的 Path 路径。</p>
<p><strong>常用方法</strong></p>
<p><code>String toString()</code>：返回调用 Path 对象的字符串表示形式。</p>
<p><code>boolean startsWith(String path)</code>：判断是否以 path 路径开始。</p>
<p><code>boolean endsWith(String path)</code>：判断是否以 path 路径结束。</p>
<p><code>boolean isAbsolute()</code>：判断是否为绝对路径。</p>
<p><code>Path getParent()</code>：返回 Path 对象包含整个路径，不包含 Path 对象指定的文件路径。</p>
<p><code>Path getRoot()</code>：返回调用 Path 对象的根路径。</p>
<p><code>Path getFileName()</code>：返回与调用 Path 对象关联的文件名。</p>
<p><code>int getNameCount()</code>：返回 Path 根目录后面元素的数量。</p>
<p><code>Path getName(int idx)</code>：返回指定所有位置 idx 的路径名称。</p>
<p><code>Path toAbsolutePath()</code>：作为绝对路径返回调用 Path 对象。</p>
<p><code>Path resolve(Path p)</code>：合并两个路径，返回合并后的路径对应的 Path 对象。</p>
<p><code>File toFile()</code>：将 Path 转化为 File 类的对象。</p>
<p><strong>2）Files 工具类（jdk7提供）</strong></p>
<p>操作文件或文件目录的工具类。</p>
<p><strong>常用方法</strong></p>
<p><code>Path copy(Path src, Path dest, CopyOption … how) </code>：文件的复制。</p>
<p><code>Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr) </code>：创建一个目录。</p>
<p><code>Path createFile(Path path, FileAttribute&lt;?&gt; … arr) </code>：创建一个文件。</p>
<p><code>void delete(Path path)</code> ：删除一个文件 目录，如果不存在，执行报错。</p>
<p><code>void deleteIfExists(Path path) </code>：Path 对应的文件 目录如果存在，执行删除。</p>
<p><code>Path move(Path src, Path dest, CopyOption…how)</code>·： 将 src 移动到 dest 位置。</p>
<p><code>long size(Path path) </code>： 返回 path 指定文件的大小。</p>
<p><strong>用于判断</strong></p>
<p><code>boolean exists(Path path, LinkOption … opts)</code> ：判断文件是否存在。</p>
<p><code>boolean isDirectory(Path path, LinkOption … opts)</code> ：判断是否是目录。</p>
<p><code>boolean isRegularFile(Path path, LinkOption … opts) </code>：判断是否是文件。</p>
<p><code>boolean isHidden(Path path) </code>：判断是否是隐藏文件。</p>
<p><code>boolean isReadable(Path path) </code>：判断文件是否可读。</p>
<p><code>boolean isWritable(Path path) </code>：判断文件是否可写。</p>
<p><code>boolean notExists(Path path, LinkOption … opts) </code>：判断文件是否不存在。</p>
<p><strong>用于操作内容</strong></p>
<p><code>SeekableByteChannel newByteChannel(Path path, OpenOption…how) </code>：获取与指定文件的连接，how 指定打开方式。</p>
<p><code>DirectoryStream&lt;Path&gt; newDirectoryStream(Path path)</code>：打开 path 指定的目录。</p>
<p><code>InputStream newInputStream(Path path, OpenOption…how)</code>：获取 InputStream 对象。</p>
<p><code>OutputStream newOutputStream(Path path, OpenOption…how) </code>：获取 OutputStream 对象。</p>
<h3 id="第14章-反射（Reflection）"><a href="#第14章-反射（Reflection）" class="headerlink" title="第14章 反射（Reflection）"></a>第14章 反射（Reflection）</h3><h4 id="14-1-反射的概念"><a href="#14-1-反射的概念" class="headerlink" title="14.1 反射的概念"></a>14.1 反射的概念</h4><p>反射是被视为动态语言的关键，反射机制允许程序在执行期借助于 Reflection API 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p>
<p><strong>框架 &#x3D; 反射 + 注解 + 设计模式。</strong></p>
<p><strong>1）反射机制的“动态性”</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//体会反射的动态性</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">3</span>);<span class="comment">//0,1,2</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classPath</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span>(num)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                classPath = <span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                classPath = <span class="string">&quot;java.lang.Object&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                classPath = <span class="string">&quot;com.atguigu.java.Person&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> getInstance(classPath);</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建一个指定类的对象。</span></span><br><span class="line"><span class="comment">classPath: 指定类的全类名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getInstance</span><span class="params">(String classPath)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span>  Class.forName(classPath);</span><br><span class="line">   <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2）功能</strong></p>
<ol>
<li>在运行时判断任意一个对象所属的类。</li>
<li>在运行时构造任意一个类的对象。</li>
<li>在运行时判断任意一个类所具有的成员变量和方法。</li>
<li>在运行时获取泛型信息。</li>
<li>在运行时调用任意一个对象的成员变量和方法。</li>
<li>在运行时处理注解。</li>
<li>生成动态代理。</li>
</ol>
<p><strong>3）相关API</strong></p>
<p>java.lang.Class: 反射的源头</p>
<p>java.lang.reflect.Method</p>
<p>java.lang.reflect.Field</p>
<p>java.lang.reflect.Constructor</p>
<p>….</p>
<h4 id="14-2-Class-类"><a href="#14-2-Class-类" class="headerlink" title="14.2 Class 类"></a>14.2 Class 类</h4><p><strong>1）Class 类的理解</strong></p>
<p><strong>类的加载过程</strong></p>
<p>程序经过 javac.ex e命令以后，会生成一个或多个字节码文件(.class结尾);接着我们使用 java.exe 命令对某个字节码文件进行解释运行。相当于将某个字节码文件<br>加载到内存中。此过程就称为<strong>类的加载</strong>。加载到内存中的类，我们就称为<strong>运行时类</strong>，此运行时类，就作为 Class 的一个实例。换句话说，<strong>Class 的实例就对应着一个运行时类。</strong>加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。</p>
<p><strong>2）获取 Class 实例的方式</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：调用运行时类的属性：.class</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Person.class;</span><br><span class="line">System.out.println(clazz1);</span><br><span class="line"><span class="comment">//方式二：通过运行时类的对象,调用getClass()</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> p1.getClass();</span><br><span class="line">System.out.println(clazz2);</span><br><span class="line"><span class="comment">//方式三：调用Class的静态方法：forName(String classPath)</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.java.Person&quot;</span>);</span><br><span class="line"><span class="comment">// clazz3 = Class.forName(&quot;java.lang.String&quot;);</span></span><br><span class="line">System.out.println(clazz3);</span><br><span class="line"></span><br><span class="line">System.out.println(clazz1 == clazz2);</span><br><span class="line">System.out.println(clazz1 == clazz3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式四：使用类的加载器：ClassLoader  (了解)</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ReflectionTest.class.getClassLoader();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz4</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;com.atguigu.java.Person&quot;</span>);</span><br><span class="line">System.out.println(clazz4);</span><br><span class="line"></span><br><span class="line">System.out.println(clazz1 == clazz4);</span><br></pre></td></tr></table></figure>

<p><strong>Class 实例可以是：</strong></p>
<ol>
<li>class：内部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类。</li>
<li>interface：接口。</li>
<li>[]：数组。</li>
<li>enum：枚举。</li>
<li>annotation：注解。</li>
<li>primitive type：基本数据类型。</li>
<li>void</li>
</ol>
<blockquote>
<p><strong>创建类的对象的方式</strong></p>
<p>方式一：new + 构造器</p>
<p>方式二：要创建 Xxx 类的对象，可以考虑：Xxx、Xxxs、XxxFactory、XxxBuilder 类中查看是否有静态方法的存在。可以调用其静态方法，创建 Xxx 对象。</p>
<p>方式三：通过反射</p>
</blockquote>
<h4 id="14-3-类加载器"><a href="#14-3-类加载器" class="headerlink" title="14.3 类加载器"></a>14.3 类加载器</h4><p><strong>1）类的加载过程</strong></p>
<img src="/.io//类的加载过程.png" alt="类的加载过程" style="zoom:200%;">

<p><strong>2）类的加载器的作用</strong></p>
<p><strong>3）类的加载器的分类</strong></p>
<img src="/.io//类的加载器的分类.png" alt="类的加载器的分类" style="zoom:200%;">

<p><strong>4）Java 类编译、运行的执行的流程</strong></p>
<img src="/.io//执行的流程.png" alt="执行的流程" style="zoom:200%;">

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Classloader加载src目录下的配置文件</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">//此时的文件默认在当前的module下。</span></span><br><span class="line">    <span class="comment">//读取配置文件的方式一：</span></span><br><span class="line">    <span class="comment">//        FileInputStream fis = new FileInputStream(&quot;jdbc.properties&quot;);</span></span><br><span class="line">    <span class="comment">//        FileInputStream fis = new FileInputStream(&quot;src\\jdbc1.properties&quot;);</span></span><br><span class="line">    <span class="comment">//        pros.load(fis);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取配置文件的方式二：使用ClassLoader</span></span><br><span class="line">    <span class="comment">//配置文件默认识别为：当前module的src下</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> classLoader.getResourceAsStream(<span class="string">&quot;jdbc1.properties&quot;</span>);</span><br><span class="line">    pros.load(is);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user = &quot;</span> + user + <span class="string">&quot;,password = &quot;</span> + password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="14-4-反射的应用"><a href="#14-4-反射的应用" class="headerlink" title="14.4 反射的应用"></a>14.4 反射的应用</h4><p><strong>1）创建运行时类的对象</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure>

<p><code>newInstance()</code>：调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器。</p>
<p>要想此方法正常的创建运行时类的对象，要求：</p>
<ol>
<li>运行时类必须提供空参的构造器.</li>
<li>空参的构造器的访问权限得够。通常，设置为public。</li>
</ol>
<p>在 JavaBean 中要求提供一个 public 的空参构造器。原因：</p>
<ol>
<li>便于通过反射，创建运行时类的对象.</li>
<li>便于子类继承此运行时类时，默认调用super()时，保证父类此构造器.</li>
</ol>
<p><strong>2）获取运行时类的完整结构</strong></p>
<p>通过反射，获取对应的运行时类中所有的属性、方法、构造器、父类、接口、父类的泛型、包、注解、异常等。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取属性结构</span></span><br><span class="line">    <span class="comment">//getFields():获取当前运行时类及其父类中声明为public访问权限的属性</span></span><br><span class="line">    Field[] fields = clazz.getFields();</span><br><span class="line">    <span class="keyword">for</span>(Field f : fields)&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getDeclaredFields():获取当前运行时类中声明的所属性。（不包含父类中声明的属性</span></span><br><span class="line">    Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span>(Field f : declaredFields)&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getMethods():获取当前运行时类及其所父类中声明为public权限的方法</span></span><br><span class="line">    Method[] methods = clazz.getMethods();</span><br><span class="line">    <span class="keyword">for</span>(Method m : methods)&#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//getDeclaredMethods():获取当前运行时类中声明的所方法。（不包含父类中声明的方法</span></span><br><span class="line">    Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span>(Method m : declaredMethods)&#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取构造器结构</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line">    <span class="comment">//getConstructors():获取当前运行时类中声明为public的构造器</span></span><br><span class="line">    Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">    <span class="keyword">for</span>(Constructor c : constructors)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//getDeclaredConstructors():获取当前运行时类中声明的所的构造器</span></span><br><span class="line">    Constructor[] declaredConstructors = clazz.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span>(Constructor c : declaredConstructors)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类的父类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">superclass</span> <span class="operator">=</span> clazz.getSuperclass();</span><br><span class="line">    System.out.println(superclass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类的带泛型的父类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line">    System.out.println(genericSuperclass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类的带泛型的父类的泛型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    代码：逻辑性代码  vs 功能性代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line">    <span class="type">ParameterizedType</span> <span class="variable">paramType</span> <span class="operator">=</span> (ParameterizedType) genericSuperclass;</span><br><span class="line">    <span class="comment">//获取泛型类型</span></span><br><span class="line">    Type[] actualTypeArguments = paramType.getActualTypeArguments();</span><br><span class="line">    <span class="comment">//        System.out.println(actualTypeArguments[0].getTypeName());</span></span><br><span class="line">    System.out.println(((Class)actualTypeArguments[<span class="number">0</span>]).getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类实现的接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    Class[] interfaces = clazz.getInterfaces();</span><br><span class="line">    <span class="keyword">for</span>(Class c : interfaces)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//获取运行时类的父类实现的接口</span></span><br><span class="line">    Class[] interfaces1 = clazz.getSuperclass().getInterfaces();</span><br><span class="line">    <span class="keyword">for</span>(Class c : interfaces1)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类所在的包</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="type">Package</span> <span class="variable">pack</span> <span class="operator">=</span> clazz.getPackage();</span><br><span class="line">    System.out.println(pack);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	获取运行时类声明的注解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">    <span class="keyword">for</span>(Annotation annos : annotations)&#123;</span><br><span class="line">        System.out.println(annos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>3）调用运行时类的指定结构</strong></p>
<p><strong>调用指定的属性</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testField1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. getDeclaredField(String fieldName):获取运行时类中指定变量名的属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证当前属性是可访问的</span></span><br><span class="line">    name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//3.获取、设置指定对象的此属性值</span></span><br><span class="line">    name.set(p,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(name.get(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用指定的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.获取指定的某个方法</span></span><br><span class="line"><span class="comment">        getDeclaredMethod():参数1 ：指明获取的方法的名称  参数2：指明获取的方法的形参列表</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line">    <span class="comment">//2.保证当前方法是可访问的</span></span><br><span class="line">    show.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        3. 调用方法的invoke():参数1：方法的调用者  参数2：给方法形参赋值的实参</span></span><br><span class="line"><span class="comment">        invoke()的返回值即为对应类中调用的方法的返回值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> show.invoke(p,<span class="string">&quot;CHN&quot;</span>); <span class="comment">//String nation = p.show(&quot;CHN&quot;);</span></span><br><span class="line">    System.out.println(returnValue);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*************如何调用静态方法*****************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private static void showDesc()</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">showDesc</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;showDesc&quot;</span>);</span><br><span class="line">    showDesc.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//如果调用的运行时类中的方法没返回值，则此invoke()返回null</span></span><br><span class="line">    <span class="comment">//        Object returnVal = showDesc.invoke(null);</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> showDesc.invoke(Person.class);</span><br><span class="line">    System.out.println(returnVal);<span class="comment">//null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>调用指定的构造器</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private Person(String name)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.获取指定的构造器</span></span><br><span class="line"><span class="comment">    getDeclaredConstructor():参数：指明构造器的参数列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证此构造器是可访问的</span></span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.调用此构造器创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> (Person) constructor.newInstance(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    System.out.println(per);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>4）动态代理</strong></p>
<p>代理模式的原理：使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。 </p>
<p><strong>静态代理</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Runnable接口的方法创建多线程。</span></span><br><span class="line">Class MyThread <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;&#125; <span class="comment">//相当于被代理类</span></span><br><span class="line">Class Thread <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;&#125; <span class="comment">//相当于代理类</span></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">    thread.start();<span class="comment">//启动线程；调用线程的run()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>静态代理的缺点</strong></p>
<p>① 代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。</p>
<p>② 每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。</p>
<p><strong>动态代理</strong></p>
<p>动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。</p>
<p><strong>需要解决的两个主要问题</strong></p>
<p>问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。 （<strong>通过 Proxy.newProxyInstance() 实现</strong>）</p>
<p>问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。(<strong>通过 InvocationHandler 接口的实现类及其方法 invoke()</strong>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理的举例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Human</span>&#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getBelief</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperMan</span> <span class="keyword">implements</span> <span class="title class_">Human</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBelief</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I believe I can fly!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我喜欢吃&quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanUtil</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====================通用方法一====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====================通用方法二====================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyFactory</span>&#123;</span><br><span class="line">    <span class="comment">//调用此方法，返回一个代理类的对象。解决问题一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxyInstance</span><span class="params">(Object obj)</span>&#123;<span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        <span class="type">MyInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>();</span><br><span class="line"></span><br><span class="line">        handler.bind(obj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object obj;<span class="comment">//需要使用被代理类的对象进行赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()</span></span><br><span class="line">    <span class="comment">//将被代理类要执行的方法a的功能就声明在invoke()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanUtil</span> <span class="variable">util</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanUtil</span>();</span><br><span class="line">        util.method1();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法</span></span><br><span class="line">        <span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(obj,args);</span><br><span class="line"></span><br><span class="line">        util.method2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上述方法的返回值就作为当前类中的invoke()的返回值。</span></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SuperMan</span> <span class="variable">superMan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperMan</span>();</span><br><span class="line">        <span class="comment">//proxyInstance:代理类的对象</span></span><br><span class="line">        <span class="type">Human</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">        <span class="comment">//当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">belief</span> <span class="operator">=</span> proxyInstance.getBelief();</span><br><span class="line">        System.out.println(belief);</span><br><span class="line">        proxyInstance.eat(<span class="string">&quot;四川麻辣烫&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">NikeClothFactory</span> <span class="variable">nikeClothFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NikeClothFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ClothFactory</span> <span class="variable">proxyClothFactory</span> <span class="operator">=</span> (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory);</span><br><span class="line"></span><br><span class="line">        proxyClothFactory.produceCloth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第15章-网络编程"><a href="#第15章-网络编程" class="headerlink" title="第15章 网络编程"></a>第15章 网络编程</h3><h4 id="15-1-InetAddress-类的使用"><a href="#15-1-InetAddress-类的使用" class="headerlink" title="15.1 InetAddress 类的使用"></a>15.1 InetAddress 类的使用</h4><p><strong>1）网络通信的实现</strong></p>
<ol>
<li><p>准确地定位网络上一台或多台主机；定位主机上的特定的应用：<strong>IP 和端口号</strong>。</p>
</li>
<li><p>找到主机后可靠高效地进行数据传输：<strong>提供网络通信协议</strong>（TCP&#x2F;IP参考模型（应用层、传输层、网络层、物理+数据链路层））。</p>
</li>
</ol>
<p><strong>2）IP 和端口号</strong></p>
<p><strong>IP</strong>：<strong>唯一的标识</strong>，Internet 上的计算机（通信实体）。</p>
<ol>
<li>在 Java 中使用 InetAddress 类代表 IP。</li>
<li>IP分类：IPv4 和 IPv6；万维网 和 局域网。</li>
<li>域名:   <a target="_blank" rel="noopener" href="http://www.baidu.com/">www.baidu.com</a>   <a target="_blank" rel="noopener" href="http://www.mi.com/">www.mi.com</a>  <a target="_blank" rel="noopener" href="http://www.sina.com/">www.sina.com</a>  <a target="_blank" rel="noopener" href="http://www.jd.com/">www.jd.com</a></li>
<li>域名解析：域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器（DNS）负责将域名转化成IP地址，这样才能和主机建立连接。</li>
<li>本地回路地址：127.0.0.1 对应 localhost</li>
</ol>
<p><strong>端口号</strong>：正在计算机上运行的进程。</p>
<ul>
<li>要求：不同的进程不同的端口号。</li>
<li>范围：被规定为一个 16 位的整数 0~65535。</li>
</ul>
<p><strong>套接字</strong>：端口号与 IP 地址的组合得出一个网络套接字（Socket）。</p>
<p><strong>3）InetAddress 类</strong></p>
<ul>
<li><p>此类的一个对象就代表着一个具体的 IP 地址。</p>
</li>
<li><p><strong>实例化</strong>：getByName(String host) 、 getLocalHost()。</p>
</li>
<li><p><strong>常用方法</strong>：getHostName() &#x2F; getHostAddress()。</p>
</li>
</ul>
<p><strong>4）网络通信协议</strong></p>
<img src="/.io//参考模型.png" alt="参考模型" style="zoom:150%;">

<p><strong>TCP 和 UDP 的区别</strong></p>
<p><strong>TCP 协议</strong></p>
<ol>
<li>使用 TCP 协议前，须先建立 TCP 连接，形成传输数据通道。</li>
<li>传输前，采用“三次握手”方式，<strong>点对点</strong>通信，是<strong>可靠的</strong>。</li>
<li>TCP 协议进行通信的两个应用进程：客户端、服务器。</li>
<li>在连接中可<strong>进行大数据量的传输</strong>。</li>
<li>传输完毕，<strong>须释放已建立的连接，效率低</strong>。</li>
</ol>
<p><strong>UDP 协议</strong></p>
<ol>
<li>将数据、源、目的封装成数据包，不需要建立连接。</li>
<li>每个数据报的大小限制在 64k 内。</li>
<li>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的。</li>
<li>可以广播发送。</li>
<li>发送数据结束时无需是否资源，开销小，速度快。</li>
</ol>
<p><strong>TCP 三次握手和四次挥手</strong></p>
<img src="/.io//TCP 三次握手.png" alt="TCP 三次握手" style="zoom: 200%;">

<img src="/.io//TCP 四次握手.png" alt="TCP 四次握手" style="zoom: 200%;">

<h4 id="15-2-TCP-网络编程"><a href="#15-2-TCP-网络编程" class="headerlink" title="15.2 TCP 网络编程"></a>15.2 TCP 网络编程</h4><p><strong>1）代码示例1</strong>：客户端发送信息给服务端，服务端将数据显示在控制台上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建Socket对象，指明服务器端的ip和端口号</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.14.100&quot;</span>);</span><br><span class="line">        socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(inet,<span class="number">8899</span>);</span><br><span class="line">        <span class="comment">//2.获取一个输出流，用于输出数据</span></span><br><span class="line">        os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.写出数据的操作</span></span><br><span class="line">        os.write(<span class="string">&quot;你好，我是客户端mm&quot;</span>.getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.资源的关闭</span></span><br><span class="line">        <span class="keyword">if</span>(os != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(socket != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建服务器端的ServerSocket，指明自己的端口号</span></span><br><span class="line">        ss = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8899</span>);</span><br><span class="line">        <span class="comment">//2.调用accept()表示接收来自于客户端的socket</span></span><br><span class="line">        socket = ss.accept();</span><br><span class="line">        <span class="comment">//3.获取输入流</span></span><br><span class="line">        is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不建议这样写，可能会乱码</span></span><br><span class="line">        <span class="comment">//        byte[] buffer = new byte[1024];</span></span><br><span class="line">        <span class="comment">//        int len;</span></span><br><span class="line">        <span class="comment">//        while((len = is.read(buffer)) != -1)&#123;</span></span><br><span class="line">        <span class="comment">//            String str = new String(buffer,0,len);</span></span><br><span class="line">        <span class="comment">//            System.out.print(str);</span></span><br><span class="line">        <span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//4.读取输入流中的数据</span></span><br><span class="line">        baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;收到了来自于：&quot;</span> + socket.getInetAddress().getHostAddress() + <span class="string">&quot;的数据&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(baos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//5.关闭资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(socket != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ss != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ss.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2）代码示例2</strong>：客户端发送文件给服务端，服务端将文件保存在本地。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">9090</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty.jpg&quot;</span>));</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.</span></span><br><span class="line">    fis.close();</span><br><span class="line">    os.close();</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9090</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty1.jpg&quot;</span>));</span><br><span class="line">    <span class="comment">//5.</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.</span></span><br><span class="line">    fos.close();</span><br><span class="line">    is.close();</span><br><span class="line">    socket.close();</span><br><span class="line">    ss.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">代码示例<span class="number">3</span>：从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。并关闭相应的连接。</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">9090</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty.jpg&quot;</span>));</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭数据的输出</span></span><br><span class="line">    socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.接收来自于服务器端的数据，并显示到控制台上</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="type">byte</span>[] bufferr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len1;</span><br><span class="line">    <span class="keyword">while</span>((len1 = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        baos.write(buffer,<span class="number">0</span>,len1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.</span></span><br><span class="line">    fis.close();</span><br><span class="line">    os.close();</span><br><span class="line">    socket.close();</span><br><span class="line">    baos.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9090</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty2.jpg&quot;</span>));</span><br><span class="line">    <span class="comment">//5.</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;图片传输完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.服务器端给予客户端反馈</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">    os.write(<span class="string">&quot;你好，美女，照片我已收到，非常漂亮！&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.</span></span><br><span class="line">    fos.close();</span><br><span class="line">    is.close();</span><br><span class="line">    socket.close();</span><br><span class="line">    ss.close();</span><br><span class="line">    os.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-3-UDP-网络编程"><a href="#15-3-UDP-网络编程" class="headerlink" title="15.3 UDP 网络编程"></a>15.3 UDP 网络编程</h4><p><strong>代码示例</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sender</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我是UDP方式发送的导弹&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] data = str.getBytes();</span><br><span class="line">    <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">    <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data,<span class="number">0</span>,data.length,inet,<span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">    socket.send(packet);</span><br><span class="line"></span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiver</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer,<span class="number">0</span>,buffer.length);</span><br><span class="line"></span><br><span class="line">    socket.receive(packet);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(),<span class="number">0</span>,packet.getLength()));</span><br><span class="line"></span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="15-4-URL-编程"><a href="#15-4-URL-编程" class="headerlink" title="15.4  URL 编程"></a>15.4  URL 编程</h4><p><strong>1）URL（Uniform Resource Locator）</strong>：统一资源定位符，对应着互联网的某一资源地址。</p>
<p><strong>URL 的5个基本结构</strong>     </p>
<table>
<thead>
<tr>
<th>http:&#x2F;&#x2F;</th>
<th>localhost:</th>
<th>8080</th>
<th>&#x2F;examples&#x2F;beauty.jpg</th>
<th>?username&#x3D;Tom</th>
</tr>
</thead>
<tbody><tr>
<td>协议</td>
<td>主机名</td>
<td>端口号</td>
<td>资源地址</td>
<td>参数列表</td>
</tr>
</tbody></table>
<p><strong>实例化</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg?username=Tom&quot;</span>);</span><br></pre></td></tr></table></figure>

<p><strong>2）常用方法</strong></p>
<p><code>public String getProtocol()</code>：获取该 URL 的协议名。</p>
<p><code>public String getHost()</code>：获取该 URL 的主机名。</p>
<p><code>public String getPort()</code>：获取该 URL 的端口号。</p>
<p><strong><code>public String getPath()</code>：获取该 URL 的文件路径。</strong></p>
<p><code>public String getFile()</code>：获取该 URL 的文件名。</p>
<p><strong><code>public String getQuery()</code>：获取该 URL 的查询名。</strong></p>
<p><strong>3）读取、下载对应的 url 资源</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">HttpURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line"></span><br><span class="line">        urlConnection.connect();</span><br><span class="line"></span><br><span class="line">        is = urlConnection.getInputStream();</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;day10\\beauty3.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;下载完成&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        <span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(urlConnection != <span class="literal">null</span>)&#123;</span><br><span class="line">            urlConnection.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第16章-注解（Annotation）"><a href="#第16章-注解（Annotation）" class="headerlink" title="第16章 注解（Annotation）"></a>第16章 注解（Annotation）</h3><h4 id="16-1-注解的理解"><a href="#16-1-注解的理解" class="headerlink" title="16.1 注解的理解"></a>16.1 注解的理解</h4><ul>
<li><p>JDK 5.0 新增的功能</p>
</li>
<li><p>注解其实就是代码里的<strong>特殊标记</strong>，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用注解，程序员可以在不改变原逻辑的情况下，在源文件中嵌入一些补充信息。</p>
</li>
<li><p>在 Java SE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 和 Android 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 Java EE 旧版中所遗留的繁冗代码和 XML 配置等。</p>
</li>
<li><p><strong>框架 &#x3D; 注解 + 反射机制 + 设计模式</strong></p>
</li>
</ul>
<h4 id="16-2-使用示例"><a href="#16-2-使用示例" class="headerlink" title="16.2 使用示例"></a>16.2 使用示例</h4><ol>
<li>生成文档相关的注解</li>
<li>在编译时进行格式检查（JDK 内置的基本注解）<ul>
<li>@Override：限定重写父类方法, 该注解只能用于方法。</li>
<li>@Deprecated：用于表示所修饰的元素（类, 方法等）已过时。通常是因为所修饰的结构危险或存在更好的选择。</li>
<li>@SuppressWarnings：抑制编译器警告。</li>
</ul>
</li>
</ol>
<h4 id="16-3-自定义注解"><a href="#16-3-自定义注解" class="headerlink" title="16.3 自定义注解"></a>16.3 自定义注解</h4><p><strong>参照 @SuppressWarnings 定义</strong></p>
<ol>
<li><p>注解声明为：@interface。</p>
</li>
<li><p>内部定义成员，通常使用 value 表示。</p>
</li>
<li><p>可以指定成员的默认值，使用 default 定义。</p>
</li>
<li><p>如果自定义注解没成员，表明是一个标识作用。</p>
</li>
</ol>
<p><strong>说明</strong></p>
<ul>
<li><p>如果注解有成员，在使用注解时，需要指明成员的值。</p>
</li>
<li><p>自定义注解必须配上注解的信息处理流程(使用反射)才意义。</p>
</li>
<li><p>自定义注解通过都会指明两个元注解：Retention、Target。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="16-4-元注解"><a href="#16-4-元注解" class="headerlink" title="16.4 元注解"></a>16.4 元注解</h4><ul>
<li>对现有的注解进行解释说明的注解。</li>
</ul>
<p><strong>JDK 提供的 4 种元注解</strong></p>
<ol>
<li>Retention：指定所修饰的 Annotation 的生命周期：SOURCE\CLASS（默认行为 RUNTIME 只声明为 RUNTIME 生命周期的注解，才能通过反射获取。）</li>
<li>Target：用于指定被修饰的 Annotation 能用于修饰哪些程序元素</li>
<li>Documented：表示所修饰的注解在被 javadoc 解析时，保留下来。</li>
<li>Inherited：被它修饰的 Annotation 将具继承性。</li>
</ol>
<h4 id="16-5-获取注解信息"><a href="#16-5-获取注解信息" class="headerlink" title="16.5 获取注解信息"></a>16.5 获取注解信息</h4><p><strong>1）通过反射来进行获取、调用。</strong></p>
<ul>
<li>要求此注解的元注解 Retention 中声明的生命周期状态为：RUNTIME.</li>
</ul>
<p><strong>2）JDK8中注解的新特性</strong></p>
<ol>
<li><strong>可重复注解</strong><ul>
<li>在 MyAnnotation 上声明 @Repeatable，成员值为 MyAnnotations.class。</li>
<li>MyAnnotation 的 Target 和 Retention 等元注解与 MyAnnotations 相同。</li>
</ul>
</li>
<li><strong>类型注解</strong><ul>
<li><code>ElementType.TYPE_PARAMETER</code> 表示该注解能写在类型变量的<strong>声明语句</strong>中，如：泛型声明。</li>
<li><code>ElementType.TYPE_USE</code> 表示该注解能写在使用类型的<strong>任何语句</strong>中。</li>
</ul>
</li>
</ol>
<h3 id="第17章-枚举类（Enumeration）"><a href="#第17章-枚举类（Enumeration）" class="headerlink" title="第17章 枚举类（Enumeration）"></a>第17章 枚举类（Enumeration）</h3><h4 id="17-1-枚举类的说明"><a href="#17-1-枚举类的说明" class="headerlink" title="17.1 枚举类的说明"></a>17.1 枚举类的说明</h4><ol>
<li><p>枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类</p>
</li>
<li><p>当需要定义一组常量时，强烈建议使用枚举类</p>
</li>
<li><p>如果枚举类中只一个对象，则可以作为单例模式的实现方式。</p>
</li>
</ol>
<h4 id="17-2-自定义枚举类"><a href="#17-2-自定义枚举类" class="headerlink" title="17.2 自定义枚举类"></a>17.2 自定义枚举类</h4><ol>
<li>声明对象的属性：<code>private final</code> 修饰。</li>
<li>私化类的构造器,并给对象属性赋值。</li>
<li>提供当前枚举类的多个对象：<code>public static final</code> 的。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义枚举类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">     <span class="comment">//1.声明Season对象的属性:private final修饰</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">     <span class="comment">//2.私化类的构造器,并给对象属性赋值</span></span><br><span class="line">     <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">         <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">         <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//3.提供当前枚举类的多个对象：public static final的</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line">     <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> seasonName;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> seasonDesc;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//4.其他诉求1：提供toString()</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                 <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                 <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                 <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="17-3-使用-enum-定义枚举类"><a href="#17-3-使用-enum-定义枚举类" class="headerlink" title="17.3 使用 enum 定义枚举类"></a>17.3 使用 enum 定义枚举类</h4><p><strong>1）使用 enum 定义枚举类（ jdk 5.0 新增）</strong></p>
<ol>
<li>提供当前枚举类的对象，多个对象之间用 “,” 隔开，末尾对象 “;” 结束。</li>
<li>声明对象的属性：<code>private final</code> 修饰。</li>
<li>私化类的构造器,并给对象属性赋值。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">     <span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">     SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">     SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">     AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">     WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//2.声明Season对象的属性:private final修饰</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//3.私化类的构造器,并给对象属性赋值</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">         <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">         <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> seasonName;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> seasonDesc;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>2）枚举类常用方法（继承于 java.lang.Enum 类）</strong></p>
<ul>
<li><code>toString()</code>：返回枚举类对象的名称</li>
<li><code>values()</code>：返回所有的枚举类对象构成的数组</li>
<li><code>valueOf(String objName)</code>：返回枚举类中对象名是 objName 的对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用enum定义枚举类之后，枚举类常用方法：</span></span><br><span class="line"><span class="type">Season1</span> <span class="variable">summer</span> <span class="operator">=</span> Season.SUMMER;</span><br><span class="line"><span class="comment">// toString():返回枚举类对象的名称</span></span><br><span class="line">System.out.println(summer.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// System.out.println(Season1.class.getSuperclass());</span></span><br><span class="line">System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line"><span class="comment">// values():返回所的枚举类对象构成的数组</span></span><br><span class="line">Season1[] values = Season.values();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; values.length;i++)&#123;</span><br><span class="line">    System.out.println(values[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">Thread.State[] values1 = Thread.State.values();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values1.length; i++) &#123;</span><br><span class="line">    System.out.println(values1[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//valueOf(String objName):返回枚举类中对象名是objName的对象。</span></span><br><span class="line"><span class="type">Season1</span> <span class="variable">winter</span> <span class="operator">=</span> Season1.valueOf(<span class="string">&quot;WINTER&quot;</span>);</span><br><span class="line"><span class="comment">//如果没objName的枚举类对象，则抛异常：IllegalArgumentException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        Season1 winter = Season1.valueOf(&quot;WINTER1&quot;);</span></span><br><span class="line">System.out.println(winter);</span><br></pre></td></tr></table></figure>

<p><strong>3）枚举类对象分别实现接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用enum定义枚举类之后，如何让枚举类对象分别实现接口：</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;春天在哪里？&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;宁夏&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秋天不回来&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;大约在冬季&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="第18章-新特性"><a href="#第18章-新特性" class="headerlink" title="第18章 新特性"></a>第18章 新特性</h3><h4 id="18-1-Java8-的新特性"><a href="#18-1-Java8-的新特性" class="headerlink" title="18.1 Java8 的新特性"></a>18.1 Java8 的新特性</h4><p><strong>1）Lambda 表达式</strong></p>
<p><strong>2）函数式接口</strong></p>
<p><strong>3）方法引用</strong></p>
<p><strong>4）构造器引用和数组引用</strong></p>
<p><strong>5）Stream API</strong></p>
<p><strong>6）Optional 类的使用</strong></p>
<p><strong>7）其他新特性</strong></p>
<h4 id="18-2-Java9-新特性"><a href="#18-2-Java9-新特性" class="headerlink" title="18.2 Java9 新特性"></a>18.2 Java9 新特性</h4><h4 id="18-3-Java10-新特性"><a href="#18-3-Java10-新特性" class="headerlink" title="18.3 Java10 新特性"></a>18.3 Java10 新特性</h4><h4 id="18-4-Java11-新特性"><a href="#18-4-Java11-新特性" class="headerlink" title="18.4 Java11 新特性"></a>18.4 Java11 新特性</h4></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ActionDing</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://actionding.github.io/2020/08/Java%20%E7%AC%94%E8%AE%B0/">https://actionding.github.io/2020/08/Java%20%E7%AC%94%E8%AE%B0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ActionDing.github.io" target="_blank">ActionDing</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/%E7%AC%94%E8%AE%B0/">笔记</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/img/wechat.jpg" target="_blank"><img class="post-qr-code-img" src="/img/wechat.jpg" alt="Wechat"/></a><div class="post-qr-code-desc">Wechat</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src="/img/alipay.jpg" alt="Alipay"/></a><div class="post-qr-code-desc">Alipay</div></li></ul></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/08/MySQL%20%E7%AC%94%E8%AE%B0/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">MySQL 笔记</div></div></a></div><div class="next-post pull-right"><a href="/2020/08/Spring%20%E7%AC%94%E8%AE%B0/"><img class="next-cover" src="https://spring.io/images/spring-logo-9146a4d3298760c2e7e49595184e1975.svg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Spring 笔记</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%910-Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/" title="【Java基础】0-Java语言概述"><img class="cover" src="https://p5.qhimg.com/bdr/__85/t01807e5a724cedb514.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-05</div><div class="title">【Java基础】0-Java语言概述</div></div></a></div><div><a href="/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%911-%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F/" title="【Java基础】1-第一个Java程序"><img class="cover" src="https://p5.qhimg.com/bdr/__85/t01807e5a724cedb514.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-05</div><div class="title">【Java基础】1-第一个Java程序</div></div></a></div><div><a href="/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%9110-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/" title="【Java基础】10-异常处理"><img class="cover" src="https://p5.qhimg.com/bdr/__85/t01807e5a724cedb514.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-05</div><div class="title">【Java基础】10-异常处理</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://s2.loli.net/2022/03/08/NatumZBRC4zSi8Q.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ActionDing</div><div class="author-info__description">Less is More</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">18</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ActionDing"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ActionDing" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:dingkj32@gmail.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">Welcom to my Blog.</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86-Java-%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B"><span class="toc-number">1.</span> <span class="toc-text">第一部分 Java 基础编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC1%E7%AB%A0-Java-%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">第1章 Java 语言概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-Java-%E7%AE%80%E5%8F%B2"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1 Java 简史</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-Java-%E6%8A%80%E6%9C%AF%E4%BD%93%E7%B3%BB%E5%B9%B3%E5%8F%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.2 Java 技术体系平台</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E5%BA%94%E7%94%A8%E9%A2%86%E5%9F%9F"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.3 应用领域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-Java%E8%AF%AD%E8%A8%80%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.4 Java语言运行机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC2%E7%AB%A0-%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.2.</span> <span class="toc-text">第2章 第一个Java程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%89%93%E5%8D%B0-Hello-World"><span class="toc-number">1.2.1.</span> <span class="toc-text">2.1 打印 Hello World</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E6%B3%A8%E9%87%8A"><span class="toc-number">1.2.2.</span> <span class="toc-text">2.2 注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E8%89%AF%E5%A5%BD%E7%9A%84%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC"><span class="toc-number">1.2.3.</span> <span class="toc-text">2.3 良好的编程风格</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%99%84%EF%BC%9ATips"><span class="toc-number">1.2.4.</span> <span class="toc-text">附：Tips</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC3%E7%AB%A0-%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.</span> <span class="toc-text">第3章 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E5%85%B3%E9%94%AE%E5%AD%97%E4%B8%8E%E4%BF%9D%E7%95%99%E5%AD%97"><span class="toc-number">1.3.1.</span> <span class="toc-text">3.1 关键字与保留字</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E6%A0%87%E8%AF%86%E7%AC%A6-Identifier"><span class="toc-number">1.3.2.</span> <span class="toc-text">3.2 标识符 (Identifier)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E5%8F%98%E9%87%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">3.3 变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-4-%E8%87%AA%E5%8A%A8%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.4.</span> <span class="toc-text">3.4 自动类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-5-%E5%BC%BA%E5%88%B6%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.3.5.</span> <span class="toc-text">3.5 强制类型转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC4%E7%AB%A0-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.</span> <span class="toc-text">第4章 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-1-%E7%AE%97%E6%9C%AF%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.1.</span> <span class="toc-text">4.1 算术运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.2.</span> <span class="toc-text">4.2 赋值运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-3-%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.3.</span> <span class="toc-text">4.3 比较运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-4-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.4.</span> <span class="toc-text">4.4 逻辑运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-5-%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.5.</span> <span class="toc-text">4.5 位运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-6-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.4.6.</span> <span class="toc-text">4.6 三元运算符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">1.5.</span> <span class="toc-text">第5章 流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-if-else-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.1.</span> <span class="toc-text">5.1 if-else 条件判断结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-switch-case-%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.2.</span> <span class="toc-text">5.2 switch-case 选择结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-for-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.3.</span> <span class="toc-text">5.3 for  循环结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-while-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.4.</span> <span class="toc-text">5.4 while 循环结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-do-while"><span class="toc-number">1.5.5.</span> <span class="toc-text">5.5 do-while</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF"><span class="toc-number">1.5.6.</span> <span class="toc-text">5.6 嵌套循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-break-%E5%92%8C-continue-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.5.7.</span> <span class="toc-text">5.7 break 和 continue 关键字</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E6%95%B0%E7%BB%84%EF%BC%88Array%EF%BC%89"><span class="toc-number">1.6.</span> <span class="toc-text">第6章 数组（Array）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E6%95%B0%E7%BB%84%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.1.</span> <span class="toc-text">6.1 数组的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.2.</span> <span class="toc-text">6.2 一维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.6.3.</span> <span class="toc-text">6.3 二维数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95"><span class="toc-number">1.6.4.</span> <span class="toc-text">6.4 数组的常见算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-Arrays-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">1.6.5.</span> <span class="toc-text">6.5 Arrays 工具类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-%E6%95%B0%E7%BB%84%E7%9A%84%E5%B8%B8%E8%A7%81%E5%BC%82%E5%B8%B8"><span class="toc-number">1.6.6.</span> <span class="toc-text">6.6 数组的常见异常</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-%EF%BC%88OOP%EF%BC%89"><span class="toc-number">1.7.</span> <span class="toc-text">第7章 面向对象 （OOP）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E7%B1%BB%E5%92%8C%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.7.1.</span> <span class="toc-text">7.1 类和对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%EF%BC%88Field%EF%BC%89"><span class="toc-number">1.7.2.</span> <span class="toc-text">7.2 类的属性（Field）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%EF%BC%88Method%EF%BC%89"><span class="toc-number">1.7.3.</span> <span class="toc-text">7.3 类的方法（Method）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%88Constructor%EF%BC%89"><span class="toc-number">1.7.4.</span> <span class="toc-text">7.4 类的构造器（Constructor）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-%E5%B0%81%E8%A3%85%E6%80%A7%EF%BC%88Encapsulation%EF%BC%89"><span class="toc-number">1.7.5.</span> <span class="toc-text">7.5 封装性（Encapsulation）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-%E7%BB%A7%E6%89%BF%E6%80%A7%EF%BC%88Inheritance%EF%BC%89"><span class="toc-number">1.7.6.</span> <span class="toc-text">7.6 继承性（Inheritance）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-7-%E5%A4%9A%E6%80%81%E6%80%A7%EF%BC%88Polymorphism%EF%BC%89"><span class="toc-number">1.7.7.</span> <span class="toc-text">7.7 多态性（Polymorphism）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-8-Object-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">1.7.8.</span> <span class="toc-text">7.8 Object 类的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-9-%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">1.7.9.</span> <span class="toc-text">7.9 代码块和内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-9-%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">1.7.10.</span> <span class="toc-text">7.9 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-9-1-return"><span class="toc-number">1.7.10.1.</span> <span class="toc-text">7.9.1 return</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-9-2-this"><span class="toc-number">1.7.10.2.</span> <span class="toc-text">7.9.2 this</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-9-3-package"><span class="toc-number">1.7.10.3.</span> <span class="toc-text">7.9.3 package</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-9-4-import"><span class="toc-number">1.7.10.4.</span> <span class="toc-text">7.9.4 import</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-9-5-super"><span class="toc-number">1.7.10.5.</span> <span class="toc-text">7.9.5 super</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-9-6-static"><span class="toc-number">1.7.10.6.</span> <span class="toc-text">7.9.6 static</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-9-7-final"><span class="toc-number">1.7.10.7.</span> <span class="toc-text">7.9.7 final</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-9-8-abstract"><span class="toc-number">1.7.10.8.</span> <span class="toc-text">7.9.8 abstract</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-9-9-interface"><span class="toc-number">1.7.10.9.</span> <span class="toc-text">7.9.9 interface</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-10-%E5%85%B6%E4%BB%96"><span class="toc-number">1.7.11.</span> <span class="toc-text">7.10 其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.8.</span> <span class="toc-text">第8章 异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E5%BC%82%E5%B8%B8%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">1.8.1.</span> <span class="toc-text">8.1 异常的体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.8.2.</span> <span class="toc-text">8.2 异常处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-%E6%89%8B%E5%8A%A8%E6%8A%9B%E5%87%BA%E5%BC%82%E5%B8%B8"><span class="toc-number">1.8.3.</span> <span class="toc-text">8.3 手动抛出异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8%E7%B1%BB"><span class="toc-number">1.8.4.</span> <span class="toc-text">8.4 自定义异常类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-Java-%E9%AB%98%E7%BA%A7%E7%BC%96%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">第二部分 Java 高级编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.1.</span> <span class="toc-text">第9章 多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">2.1.1.</span> <span class="toc-text">9.1 基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-%E5%88%9B%E5%BB%BA%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-number">2.1.2.</span> <span class="toc-text">9.2 创建多线程的四种方式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-2-1-%E7%BB%A7%E6%89%BF-Thread-%E7%B1%BB"><span class="toc-number">2.1.2.1.</span> <span class="toc-text">9.2.1 继承 Thread 类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-2-2-%E5%AE%9E%E7%8E%B0-Runnable-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.1.2.2.</span> <span class="toc-text">9.2.2 实现 Runnable 接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-2-3-%E5%AE%9E%E7%8E%B0-Callable-%E6%8E%A5%E5%8F%A3-%EF%BC%88JDK-5-0-%E6%96%B0%E5%A2%9E%EF%BC%89"><span class="toc-number">2.1.2.3.</span> <span class="toc-text">9.2.3 实现 Callable 接口 （JDK 5.0 新增）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-2-4-%E4%BD%BF%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%88JDK-5-0-%E6%96%B0%E5%A2%9E%EF%BC%89"><span class="toc-number">2.1.2.4.</span> <span class="toc-text">9.2.4 使用线程池（JDK 5.0 新增）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-Thread-%E7%B1%BB%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.3.</span> <span class="toc-text">9.3 Thread 类中的常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">2.1.4.</span> <span class="toc-text">9.4 线程的生命周期</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-number">2.1.5.</span> <span class="toc-text">9.5 线程的同步机制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-5-1-%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">2.1.5.1.</span> <span class="toc-text">9.5.1 同步代码块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-5-2-%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">2.1.5.2.</span> <span class="toc-text">9.5.2 同步方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-5-3-Lock-%E9%94%81%EF%BC%88JDK-5-0-%E6%96%B0%E5%A2%9E%EF%BC%89"><span class="toc-number">2.1.5.3.</span> <span class="toc-text">9.5.3 Lock 锁（JDK 5.0 新增）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-6-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="toc-number">2.1.6.</span> <span class="toc-text">9.6 线程通信</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-Java-%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">2.2.</span> <span class="toc-text">第10章 Java 常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-String-%E7%B1%BB"><span class="toc-number">2.2.1.</span> <span class="toc-text">10.1 String 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-StringBuffer%E3%80%81StringBuilder-%E7%B1%BB"><span class="toc-number">2.2.2.</span> <span class="toc-text">10.2 StringBuffer、StringBuilder 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-JDK-8-%E4%B9%8B%E5%89%8D%E7%9A%84%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4-API"><span class="toc-number">2.2.3.</span> <span class="toc-text">10.3 JDK 8 之前的日期时间 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-JDK-8-%E4%B8%AD%E6%96%B0%E6%97%B6%E9%97%B4%E6%97%A5%E6%9C%9F-API"><span class="toc-number">2.2.4.</span> <span class="toc-text">10.4 JDK 8 中新时间日期 API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-Java-%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-number">2.2.5.</span> <span class="toc-text">10.5 Java 比较器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-6-%E5%85%B6%E4%BB%96"><span class="toc-number">2.2.6.</span> <span class="toc-text">10.6 其他</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-Java-%E9%9B%86%E5%90%88"><span class="toc-number">2.3.</span> <span class="toc-text">第11章 Java 集合</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-%E6%95%B0%E7%BB%84%E5%92%8C%E9%9B%86%E5%90%88"><span class="toc-number">2.3.1.</span> <span class="toc-text">11.1 数组和集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-Collection-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.3.2.</span> <span class="toc-text">11.2 Collection 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-Iterator-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.3.3.</span> <span class="toc-text">11.3 Iterator 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-List-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.3.4.</span> <span class="toc-text">11.4 List 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-5-Set-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.3.5.</span> <span class="toc-text">11.5 Set 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-6-Map-%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.3.6.</span> <span class="toc-text">11.6 Map 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-7-Collections-%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">2.3.7.</span> <span class="toc-text">11.7 Collections 工具类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E6%B3%9B%E5%9E%8B%EF%BC%88Generics%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">第12章 泛型（Generics）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-%E6%A6%82%E5%BF%B5"><span class="toc-number">2.4.1.</span> <span class="toc-text">12.1 概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-%E6%B3%9B%E5%9E%8B%E5%9C%A8%E9%9B%86%E5%90%88%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.4.2.</span> <span class="toc-text">12.2 泛型在集合中的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB%E3%80%81%E6%B3%9B%E5%9E%8B%E6%8E%A5%E5%8F%A3%E3%80%81%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.3.</span> <span class="toc-text">12.3 自定义泛型类、泛型接口、泛型方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-%E6%B3%9B%E5%9E%8B%E5%9C%A8%E7%BB%A7%E6%89%BF%E4%B8%8A%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-number">2.4.4.</span> <span class="toc-text">12.4 泛型在继承上的体现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-5-%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">2.4.5.</span> <span class="toc-text">12.5 通配符 ?</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-IO-%E6%B5%81"><span class="toc-number">2.5.</span> <span class="toc-text">第13章 IO 流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-File-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.5.1.</span> <span class="toc-text">13.1 File 类的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-IO-%E6%B5%81%E6%A6%82%E8%BF%B0"><span class="toc-number">2.5.2.</span> <span class="toc-text">13.2 IO 流概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-%E8%8A%82%E7%82%B9%E6%B5%81%EF%BC%88%E6%96%87%E4%BB%B6%E6%B5%81%EF%BC%89"><span class="toc-number">2.5.3.</span> <span class="toc-text">13.3 节点流（文件流）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-4-%E7%BC%93%E5%86%B2%E6%B5%81"><span class="toc-number">2.5.4.</span> <span class="toc-text">13.4 缓冲流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-5-%E8%BD%AC%E6%8D%A2%E6%B5%81"><span class="toc-number">2.5.5.</span> <span class="toc-text">13.5 转换流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-6-%E5%AF%B9%E8%B1%A1%E6%B5%81"><span class="toc-number">2.5.6.</span> <span class="toc-text">13.6 对象流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-7-%E5%85%B6%E4%BB%96%E6%B5%81"><span class="toc-number">2.5.7.</span> <span class="toc-text">13.7 其他流</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-8-Path%E3%80%81Paths%E3%80%81Files-%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.5.8.</span> <span class="toc-text">13.8 Path、Paths、Files 的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-%E5%8F%8D%E5%B0%84%EF%BC%88Reflection%EF%BC%89"><span class="toc-number">2.6.</span> <span class="toc-text">第14章 反射（Reflection）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-1-%E5%8F%8D%E5%B0%84%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">2.6.1.</span> <span class="toc-text">14.1 反射的概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-Class-%E7%B1%BB"><span class="toc-number">2.6.2.</span> <span class="toc-text">14.2 Class 类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">2.6.3.</span> <span class="toc-text">14.3 类加载器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">2.6.4.</span> <span class="toc-text">14.4 反射的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">2.7.</span> <span class="toc-text">第15章 网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15-1-InetAddress-%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.7.1.</span> <span class="toc-text">15.1 InetAddress 类的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-2-TCP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">2.7.2.</span> <span class="toc-text">15.2 TCP 网络编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-3-UDP-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">2.7.3.</span> <span class="toc-text">15.3 UDP 网络编程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-4-URL-%E7%BC%96%E7%A8%8B"><span class="toc-number">2.7.4.</span> <span class="toc-text">15.4  URL 编程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC16%E7%AB%A0-%E6%B3%A8%E8%A7%A3%EF%BC%88Annotation%EF%BC%89"><span class="toc-number">2.8.</span> <span class="toc-text">第16章 注解（Annotation）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#16-1-%E6%B3%A8%E8%A7%A3%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">2.8.1.</span> <span class="toc-text">16.1 注解的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-2-%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B"><span class="toc-number">2.8.2.</span> <span class="toc-text">16.2 使用示例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.8.3.</span> <span class="toc-text">16.3 自定义注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-4-%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">2.8.4.</span> <span class="toc-text">16.4 元注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#16-5-%E8%8E%B7%E5%8F%96%E6%B3%A8%E8%A7%A3%E4%BF%A1%E6%81%AF"><span class="toc-number">2.8.5.</span> <span class="toc-text">16.5 获取注解信息</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC17%E7%AB%A0-%E6%9E%9A%E4%B8%BE%E7%B1%BB%EF%BC%88Enumeration%EF%BC%89"><span class="toc-number">2.9.</span> <span class="toc-text">第17章 枚举类（Enumeration）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#17-1-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-number">2.9.1.</span> <span class="toc-text">17.1 枚举类的说明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">2.9.2.</span> <span class="toc-text">17.2 自定义枚举类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#17-3-%E4%BD%BF%E7%94%A8-enum-%E5%AE%9A%E4%B9%89%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">2.9.3.</span> <span class="toc-text">17.3 使用 enum 定义枚举类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC18%E7%AB%A0-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">2.10.</span> <span class="toc-text">第18章 新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#18-1-Java8-%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">2.10.1.</span> <span class="toc-text">18.1 Java8 的新特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-2-Java9-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">2.10.2.</span> <span class="toc-text">18.2 Java9 新特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-3-Java10-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">2.10.3.</span> <span class="toc-text">18.3 Java10 新特性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#18-4-Java11-%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">2.10.4.</span> <span class="toc-text">18.4 Java11 新特性</span></a></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background-image: url('https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/cover/default_bg2.png')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By ActionDing</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script id="click-show-text" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-show-text.min.js" data-mobile="false" data-text="富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善" data-fontsize="15px" data-random="false" async="async"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>