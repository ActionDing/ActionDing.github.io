<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>ActionDing</title>
  
  
  <link href="https://actionding.github.io/atom.xml" rel="self"/>
  
  <link href="https://actionding.github.io/"/>
  <updated>2022-03-11T01:51:37.732Z</updated>
  <id>https://actionding.github.io/</id>
  
  <author>
    <name>ActionDing</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 面试知识点</title>
    <link href="https://actionding.github.io/2022/03/Java%20%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://actionding.github.io/2022/03/Java%20%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2022-03-09T16:00:00.000Z</published>
    <updated>2022-03-11T01:51:37.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-基础-40"><a href="#Java-基础-40" class="headerlink" title="Java 基础 40"></a>Java 基础 40</h2><h3 id="语言特性-12"><a href="#语言特性-12" class="headerlink" title="语言特性 12"></a>语言特性 12</h3><h4 id="Q1：Java-语言的优点？"><a href="#Q1：Java-语言的优点？" class="headerlink" title="Q1：Java 语言的优点？"></a>Q1：Java 语言的优点？</h4><p>① 平台无关性，摆脱硬件束缚，”一次编写，到处运行”。</p><p>② 相对安全的内存管理和访问机制，避免大部分内存泄漏和指针越界。</p><p>③ 热点代码检测和运行时编译及优化，使程序随运行时间增长获得更高性能。</p><p>④ 完善的应用程序接口，支持第三方类库。</p><hr><h4 id="Q2：Java-如何实现平台无关？"><a href="#Q2：Java-如何实现平台无关？" class="headerlink" title="Q2：Java 如何实现平台无关？"></a>Q2：Java 如何实现平台无关？</h4><p><strong>JVM：</strong> Java 编译器可生成与计算机体系结构无关的字节码指令，字节码文件不仅可以轻易地在任何机器上解释执行，还可以动态地转换成本地机器代码，转换是由 JVM 实现的，JVM 是平台相关的，屏蔽了不同操作系统的差异。</p><p><strong>语言规范：</strong> 基本数据类型大小有明确规定，例如 int 永远为 32 位，而 C&#x2F;C++ 中可能是 16 位、32 位，也可能是编译器开发商指定的其他大小。Java 中数值类型有固定字节数，二进制数据以固定格式存储和传输，字符串采用标准的 Unicode 格式存储。</p><hr><h4 id="Q3：JDK-和-JRE-的区别？"><a href="#Q3：JDK-和-JRE-的区别？" class="headerlink" title="Q3：JDK 和 JRE 的区别？"></a>Q3：JDK 和 JRE 的区别？</h4><p><strong>JDK：</strong> Java Development Kit，开发工具包。提供了编译运行 Java 程序的各种工具，包括编译器、JRE 及常用类库，是 JAVA 核心。</p><p><strong>JRE：</strong> Java Runtime Environment，运行时环境，运行 Java 程序的必要环境，包括 JVM、核心类库、核心配置工具。</p><hr><h4 id="Q4：Java-按值调用还是引用调用？"><a href="#Q4：Java-按值调用还是引用调用？" class="headerlink" title="Q4：Java 按值调用还是引用调用？"></a>Q4：Java 按值调用还是引用调用？</h4><p><strong>按值调用</strong>指方法接收调用者提供的值，<strong>按引用调用</strong>指方法接收调用者提供的变量地址。</p><p>Java 总是按值调用，方法得到的是所有参数值的副本，传递对象时实际上方法接收的是对象引用的副本。方法不能修改基本数据类型的参数，如果传递了一个 int 值 ，改变值不会影响实参，因为改变的是值的一个副本。</p><p>可以改变对象参数的状态，但不能让对象参数引用一个新的对象。如果传递了一个 int 数组，改变数组的内容会影响实参，而改变这个参数的引用并不会让实参引用新的数组对象。</p><hr><h4 id="Q5：浅拷贝和深拷贝的区别？"><a href="#Q5：浅拷贝和深拷贝的区别？" class="headerlink" title="Q5：浅拷贝和深拷贝的区别？"></a>Q5：浅拷贝和深拷贝的区别？</h4><p><strong>浅拷贝：</strong> 只复制当前对象的基本数据类型及引用变量，没有复制引用变量指向的实际对象。修改克隆对象可能影响原对象，不安全。</p><p><strong>深拷贝：</strong> 完全拷贝基本数据类型和引用数据类型，安全。</p><hr><h4 id="Q6：什么是反射？"><a href="#Q6：什么是反射？" class="headerlink" title="Q6：什么是反射？"></a>Q6：什么是反射？</h4><p>在运行状态中，对于任意一个类都能知道它的所有属性和方法，对于任意一个对象都能调用它的任意方法和属性，这种动态获取信息及调用对象方法的功能称为反射。缺点是破坏了封装性以及泛型约束。反射是框架的核心，Spring 大量使用反射。</p><hr><h4 id="Q7：Class-类的作用？如何获取一个-Class-对象？"><a href="#Q7：Class-类的作用？如何获取一个-Class-对象？" class="headerlink" title="Q7：Class 类的作用？如何获取一个 Class 对象？"></a>Q7：Class 类的作用？如何获取一个 Class 对象？</h4><p>在程序运行期间，Java 运行时系统为所有对象维护一个运行时类型标识，这个信息会跟踪每个对象所属的类，虚拟机利用运行时类型信息选择要执行的正确方法，保存这些信息的类就是 Class，这是一个泛型类。</p><p>获取 Class 对象：① <code>类名.class</code> 。②对象的 <code>getClass</code>方法。③ <code>Class.forName(类的全限定名)</code>。</p><hr><h4 id="Q8：什么是注解？什么是元注解？"><a href="#Q8：什么是注解？什么是元注解？" class="headerlink" title="Q8：什么是注解？什么是元注解？"></a>Q8：什么是注解？什么是元注解？</h4><p><strong>注解</strong>是一种标记，使类或接口附加额外信息，帮助编译器和 JVM 完成一些特定功能，例如 <code>@Override</code> 标识一个方法是重写方法。</p><p><strong>元注解</strong>是自定义注解的注解，例如：</p><p><code>@Target</code>：约束作用位置，值是 ElementType 枚举常量，包括 METHOD 方法、VARIABLE 变量、TYPE 类&#x2F;接口、PARAMETER 方法参数、CONSTRUCTORS 构造方法和 LOACL_VARIABLE 局部变量等。</p><p><code>@Rentention</code>：约束生命周期，值是 RetentionPolicy 枚举常量，包括 SOURCE <a href>源码</a>、CLASS 字节码和 RUNTIME 运行时。</p><p><code>@Documented</code>：表明这个注解应该被 javadoc 记录。</p><hr><h4 id="Q9：什么是泛型，有什么作用？"><a href="#Q9：什么是泛型，有什么作用？" class="headerlink" title="Q9：什么是泛型，有什么作用？"></a>Q9：什么是泛型，有什么作用？</h4><p><strong>泛型</strong>本质是参数化类型，解决不确定对象具体类型的问题。泛型在定义处只具备执行 Object 方法的能力。</p><p>泛型的好处：① 类型安全，放置什么出来就是什么，不存在 ClassCastException。② 提升可读性，编码阶段就显式知道泛型集合、泛型方法等处理的对象类型。③ 代码重用，合并了同类型的处理代码。</p><h4 id="Q10：泛型擦除是什么？"><a href="#Q10：泛型擦除是什么？" class="headerlink" title="Q10：泛型擦除是什么？"></a>Q10：泛型擦除是什么？</h4><p>泛型用于编译阶段，编译后的字节码文件不包含泛型类型信息，因为虚拟机没有泛型类型对象，所有对象都属于普通类。例如定义 <code>List&lt;Object&gt;</code> 或 <code>List&lt;String&gt;</code>，在编译后都会变成 <code>List</code> 。</p><p>定义一个泛型类型，会自动提供一个对应原始类型，类型变量会被擦除。如果没有限定类型就会替换为 Object，如果有限定类型就会替换为第一个限定类型，例如 <code>&lt;T extends A &amp; B&gt;</code> 会使用 A 类型替换 T。</p><hr><h4 id="Q11：JDK8-新特性有哪些？"><a href="#Q11：JDK8-新特性有哪些？" class="headerlink" title="Q11：JDK8 新特性有哪些？"></a>Q11：JDK8 新特性有哪些？</h4><p><strong>lambda 表达式：</strong>允许把函数作为参数传递到方法，简化匿名内部类代码。</p><p><strong>函数式接口：</strong>使用 <code>@FunctionalInterface</code> 标识，有且仅有一个抽象方法，可被隐式转换为 lambda 表达式。</p><p><strong>方法引用：</strong>可以引用已有类或对象的方法和构造方法，进一步简化 lambda 表达式。</p><p><strong>接口：</strong>接口可以定义 <code>default</code> 修饰的默认方法，降低了接口升级的复杂性，还可以定义静态方法。</p><p><strong>注解：</strong>引入重复注解机制，相同注解在同地方可以声明多次。注解作用范围也进行了扩展，可作用于局部变量、泛型、方法异常等。</p><p><strong>类型推测：</strong>加强了类型推测机制，使代码更加简洁。</p><p><strong>Optional 类：</strong>处理空指针异常，提高代码可读性。</p><p><strong>Stream 类：</strong>引入函数式编程风格，提供了很多功能，使代码更加简洁。方法包括 <code>forEach</code> 遍历、<code>count</code> 统计个数、<code>filter</code> 按条件过滤、<code>limit</code> 取前 n 个元素、<code>skip</code> 跳过前 n 个元素、<code>map</code> 映射加工、<code>concat</code> 合并 stream 流等。</p><p><strong>日期：</strong>增强了日期和时间 API，新的 java.time 包主要包含了处理日期、时间、日期&#x2F;时间、时区、时刻和时钟等操作。</p><p><strong><a href>JavaScript</a>：</strong>提供了一个新的 <a href>JavaScript</a> 引擎，允许在 JVM上运行特定 <a href>JavaScript</a> 应用。</p><hr><h4 id="Q12：异常有哪些分类？"><a href="#Q12：异常有哪些分类？" class="headerlink" title="Q12：异常有哪些分类？"></a>Q12：异常有哪些分类？</h4><p>所有异常都是 Throwable 的子类，分为 Error 和 Exception。<strong>Error</strong> 是 Java 运行时系统的内部错误和资源耗尽错误，例如 StackOverFlowError 和 OutOfMemoryError，这种异常程序无法处理。</p><p><strong>Exception</strong> 分为受检异常和非受检异常，受检异常需要在代码中显式处理，否则会编译出错，非受检异常是运行时异常，继承自 RuntimeException。</p><p><strong>受检异常</strong>：① 无能为力型，如字段超长导致的 SQLException。② 力所能及型，如未授权异常 UnAuthorizedException，程序可跳转权限申请页面。常见受检异常还有 FileNotFoundException、ClassNotFoundException、IOException等。</p><p><strong>非受检异常</strong>：① 可预测异常，例如 IndexOutOfBoundsException、NullPointerException、ClassCastException 等，这类异常应该提前处理。② 需捕捉异常，例如进行 RPC 调用时的远程服务超时，这类异常<a href>客户端</a>必须显式处理。③ 可透出异常，指框架或系统产生的且会自行处理的异常，例如 Spring 的 NoSuchRequestHandingMethodException，Spring 会自动完成异常处理，将异常自动映射到合适的状态码。</p><hr><h3 id="数据类型-5"><a href="#数据类型-5" class="headerlink" title="数据类型 5"></a>数据类型 5</h3><h4 id="Q1：Java-有哪些基本数据类型？"><a href="#Q1：Java-有哪些基本数据类型？" class="headerlink" title="Q1：Java 有哪些基本数据类型？"></a>Q1：Java 有哪些基本数据类型？</h4><table><thead><tr><th>数据类型</th><th>内存大小</th><th>默认值</th><th>取值范围</th></tr></thead><tbody><tr><td>byte</td><td>1 B</td><td>(byte)0</td><td>-128 ~ 127</td></tr><tr><td>short</td><td>2 B</td><td>(short)0</td><td>-2^15^ ~ 2^15^-1</td></tr><tr><td>int</td><td>4 B</td><td>0</td><td>-2^31^ ~ 2^31^-1</td></tr><tr><td>long</td><td>8 B</td><td>0L</td><td>-2^63^ ~ 2^63^-1</td></tr><tr><td>float</td><td>4 B</td><td>0.0F</td><td>±3.4E+38（有效位数 6~7 位）</td></tr><tr><td>double</td><td>8 B</td><td>0.0D</td><td>±1.7E+308（有效位数 15 位）</td></tr><tr><td>char</td><td><del>英文 1B，中文 UTF-8 占 3B，GBK 占 2B。</del></td><td>‘\u0000’</td><td>‘\u0000’ ~ ‘\uFFFF’</td></tr><tr><td>boolean</td><td>单个变量 4B &#x2F; 数组 1B</td><td>false</td><td>true、false</td></tr></tbody></table><p>JVM 没有 boolean 赋值的专用字节码指令，<code>boolean f = false</code> 就是使用 ICONST_0 即常数 0 赋值。单个 boolean 变量用 int 代替，boolean 数组会编码成 byte 数组。</p><hr><h4 id="Q2：自动装箱-x2F-拆箱是什么？"><a href="#Q2：自动装箱-x2F-拆箱是什么？" class="headerlink" title="Q2：自动装箱&#x2F;拆箱是什么？"></a>Q2：自动装箱&#x2F;拆箱是什么？</h4><p>每个基本数据类型都对应一个包装类，除了 int 和 char 对应 Integer 和 Character 外，其余基本数据类型的包装类都是首字母大写即可。</p><p><strong>自动装箱：</strong> 将基本数据类型包装为一个包装类对象，例如向一个泛型为 Integer 的集合添加 int 元素。</p><p><strong>自动拆箱：</strong> 将一个包装类对象转换为一个基本数据类型，例如将一个包装类对象赋值给一个基本数据类型的变量。</p><p>比较两个包装类数值要用 <code>equals</code> ，而不能用 <code>==</code> 。</p><hr><h4 id="Q3：String-是不可变类为什么值可以修改？"><a href="#Q3：String-是不可变类为什么值可以修改？" class="headerlink" title="Q3：String 是不可变类为什么值可以修改？"></a>Q3：String 是不可变类为什么值可以修改？</h4><p>String 类和其存储数据的成员变量 value 字节数组都是 final 修饰的。对一个 String 对象的任何修改实际上都是创建一个新 String 对象，再引用该对象。只是修改 String 变量引用的对象，没有修改原 String 对象的内容。</p><hr><h4 id="Q4：字符串拼接的方式有哪些？"><a href="#Q4：字符串拼接的方式有哪些？" class="headerlink" title="Q4：字符串拼接的方式有哪些？"></a>Q4：字符串拼接的方式有哪些？</h4><p>① 直接用 <code>+</code> ，底层用 StringBuilder 实现。只适用小数量，如果在循环中使用 <code>+</code> 拼接，相当于不断创建新的 StringBuilder 对象再转换成 String 对象，效率极差。</p><p>② 使用 String 的 concat 方法，该方法中使用 <code>Arrays.copyOf</code> 创建一个新的字符数组 buf 并将当前字符串 value 数组的值拷贝到 buf 中，buf 长度 &#x3D; 当前字符串长度 + 拼接字符串长度。之后调用 <code>getChars</code> 方法使用 <code>System.arraycopy</code> 将拼接字符串的值也拷贝到 buf 数组，最后用 buf 作为构造参数 new 一个新的 String 对象返回。效率稍高于直接使用 <code>+</code>。</p><p>③ 使用 StringBuilder 或 StringBuffer，两者的 <code>append</code> 方法都继承自 AbstractStringBuilder，该方法首先使用 <code>Arrays.copyOf</code> 确定新的字符数组容量，再调用 <code>getChars</code> 方法使用 <code>System.arraycopy</code> 将新的值追加到数组中。StringBuilder 是 JDK5 引入的，效率高但线程不安全。StringBuffer 使用 synchronized 保证线程安全。</p><hr><h4 id="Q5：String-a-x3D-“a”-new-String-“b”-创建了几个对象？"><a href="#Q5：String-a-x3D-“a”-new-String-“b”-创建了几个对象？" class="headerlink" title="Q5：String a &#x3D; “a” + new String(“b”) 创建了几个对象？"></a>Q5：String a &#x3D; “a” + new String(“b”) 创建了几个对象？</h4><p>常量和常量拼接仍是常量，结果在常量池，只要有变量参与拼接结果就是变量，存在堆。</p><p>使用字面量时只创建一个常量池中的常量，使用 new 时如果常量池中没有该值就会在常量池中新创建，再在堆中创建一个对象引用常量池中常量。因此 <code>String a = &quot;a&quot; + new String(&quot;b&quot;)</code> 会创建四个对象，常量池中的 a 和 b，堆中的 b 和堆中的 ab。</p><hr><h3 id="面向对象-10"><a href="#面向对象-10" class="headerlink" title="面向对象 10"></a>面向对象 10</h3><h4 id="Q1：谈一谈你对面向对象的理解"><a href="#Q1：谈一谈你对面向对象的理解" class="headerlink" title="Q1：谈一谈你对面向对象的理解"></a>Q1：谈一谈你对面向对象的理解</h4><p>面向过程让计算机有步骤地顺序做一件事，是过程化思维，使用面向过程语言开发大型<a href>项目</a>，软件复用和维护存在很大问题，模块之间耦合严重。面向对象相对面向过程更适合解决规模较大的问题，可以拆解问题复杂度，对现实事物进行抽象并映射为开发对象，更接近人的思维。</p><p>例如开门这个动作，面向过程是 <code>open(Door door)</code>，动宾结构，door 作为操作对象的参数传入方法，方法内定义开门的具体步骤。面向对象的方式首先会定义一个类 Door，抽象出门的属性（如尺寸、颜色）和行为（如 open 和 close），主谓结构。</p><p>面向过程代码松散，强调流程化解决问题。面向对象代码强调高内聚、低耦合，先抽象模型定义共性行为，再解决实际问题。</p><hr><h4 id="Q2：面向对象的三大特性？"><a href="#Q2：面向对象的三大特性？" class="headerlink" title="Q2：面向对象的三大特性？"></a>Q2：面向对象的三大特性？</h4><p><strong>封装</strong>是对象功能内聚的表现形式，在抽象基础上决定信息是否公开及公开等级，核心问题是以什么方式暴漏哪些信息。主要任务是对属性、数据、敏感行为实现隐藏，对属性的访问和修改必须通过公共接口实现。封装使对象关系变得简单，降低了代码耦合度，方便维护。</p><p>迪米特原则就是对封装的要求，即 A 模块使用 B 模块的某接口行为，对 B 模块中除此行为外的其他信息知道得应尽可能少。不直接对 public 属性进行读取和修改而使用 getter&#x2F;setter 方法是因为假设想在修改属性时进行权限控制、日志记录等操作，在直接访问属性的情况下无法实现。如果将 public 的属性和行为修改为 private 一般依赖模块都会报错，因此不知道使用哪种权限时应优先使用 private。</p><p><strong>继承</strong>用来扩展一个类，子类可继承父类的部分属性和行为使模块具有复用性。继承是”is-a”关系，可使用里氏替换原则判断是否满足”is-a”关系，即任何父类出现的地方子类都可以出现。如果父类引用直接使用子类引用来代替且可以正确编译并执行，输出结果符合子类场景预期，那么说明两个类符合里氏替换原则。</p><p><strong>多态</strong>以封装和继承为基础，根据运行时对象实际类型使同一行为具有不同表现形式。多态指在编译层面无法确定最终调用的方法体，在运行期由 JVM 动态绑定，调用合适的重写方法。由于重载属于静态绑定，本质上重载结果是完全不同的方法，因此多态一般专指重写。</p><hr><h4 id="Q3：重载和重写的区别？"><a href="#Q3：重载和重写的区别？" class="headerlink" title="Q3：重载和重写的区别？"></a>Q3：重载和重写的区别？</h4><p><strong>重载</strong>指方法名称相同，但参数类型个数不同，是行为水平方向不同实现。对编译器来说，方法名称和参数列表组成了一个唯一键，称为方法签名，JVM 通过方法签名决定调用哪种重载方法。不管继承关系如何复杂，重载在编译时可以根据规则知道调用哪种目标方法，因此属于静态绑定。</p><p>JVM 在重载方法中选择合适方法的顺序：① 精确匹配。② 基本数据类型自动转换成更大表示范围。③ 自动拆箱与装箱。④ 子类向上转型。⑤ 可变参数。</p><p><strong>重写</strong>指子类实现接口或继承父类时，保持方法签名完全相同，实现不同方法体，是行为垂直方向不同实现。</p><p>元空间有一个方法表保存方法信息，如果子类重写了父类的方法，则方法表中的方法引用会指向子类实现。父类引用执行子类方法时无法调用子类存在而父类不存在的方法。</p><p>重写方法访问权限不能变小，返回类型和抛出的异常类型不能变大，必须加 <code>@Override</code> 。</p><hr><h4 id="Q4：类之间有哪些关系？"><a href="#Q4：类之间有哪些关系？" class="headerlink" title="Q4：类之间有哪些关系？"></a>Q4：类之间有哪些关系？</h4><table><thead><tr><th>类关系</th><th>描述</th><th>权力强侧</th><th>举例</th></tr></thead><tbody><tr><td>继承</td><td>父子类之间的关系：is-a</td><td>父类</td><td>小狗继承于动物</td></tr><tr><td>实现</td><td>接口和实现类之间的关系：can-do</td><td>接口</td><td>小狗实现了狗叫接口</td></tr><tr><td>组合</td><td>比聚合更强的关系：contains-a</td><td>整体</td><td>头是身体的一部分</td></tr><tr><td>聚合</td><td>暂时组装的关系：has-a</td><td>组装方</td><td>小狗和绳子是暂时的聚合关系</td></tr><tr><td>依赖</td><td>一个类用到另一个：depends-a</td><td>被依赖方</td><td>人养小狗，人依赖于小狗</td></tr><tr><td>关联</td><td>平等的使用关系：links-a</td><td>平等</td><td>人使用卡消费，卡可以提取人的信息</td></tr></tbody></table><hr><h4 id="Q5：Object-类有哪些方法？"><a href="#Q5：Object-类有哪些方法？" class="headerlink" title="Q5：Object 类有哪些方法？"></a>Q5：Object 类有哪些方法？</h4><p><strong>equals：</strong>检测对象是否相等，默认使用 <code>==</code> 比较对象引用，可以重写 equals 方法自定义比较规则。equals 方法规范：自反性、对称性、传递性、一致性、对于任何非空引用 x，<code>x.equals(null)</code> 返回 false。</p><p><strong>hashCode：</strong>散列码是由对象导出的一个整型值，没有规律，每个对象都有默认散列码，值由对象存储地址得出。字符串散列码由内容导出，值可能相同。为了在集合中正确使用，一般需要同时重写 equals 和 hashCode，要求 equals 相同 hashCode 必须相同，hashCode 相同 equals 未必相同，因此 hashCode 是对象相等的必要不充分条件。</p><p><strong>toString</strong>：打印对象时默认的方法，如果没有重写打印的是表示对象值的一个字符串。</p><p><strong>clone：</strong>clone 方法声明为 protected，类只能通过该方法克隆它自己的对象，如果希望其他类也能调用该方法必须定义该方法为 public。如果一个对象的类没有实现 Cloneable 接口，该对象调用 clone 方***抛出一个 CloneNotSupport 异常。默认的 clone 方法是浅拷贝，一般重写 clone 方法需要实现 Cloneable 接口并指定访问修饰符为 public。</p><p><strong>finalize：</strong>确定一个对象死亡至少要经过两次标记，如果对象在可达性分析后发现没有与 GC Roots 连接的引用链会被第一次标记，随后进行一次筛选，条件是对象是否有必要执行 finalize 方法。假如对象没有重写该方法或方法已被虚拟机调用，都视为没有必要执行。如果有必要执行，对象会被放置在 F-Queue 队列，由一条低调度优先级的 Finalizer 线程去执行。虚拟机会触发该方法但不保证会结束，这是为了防止某个对象的 finalize 方法执行缓慢或发生死循环。只要对象在 finalize 方法中重新与引用链上的对象建立关联就会在第二次标记时被移出回收集合。由于运行代价高昂且无法保证调用顺序，在 JDK 9 被标记为过时方法，并不适合释放资源。</p><p><strong>getClass：</strong>返回包含对象信息的类对象。</p><p><strong>wait &#x2F; notify &#x2F; notifyAll：</strong>阻塞或唤醒持有该对象锁的线程。</p><hr><h4 id="Q6：内部类的作用是什么，有哪些分类？"><a href="#Q6：内部类的作用是什么，有哪些分类？" class="headerlink" title="Q6：内部类的作用是什么，有哪些分类？"></a>Q6：内部类的作用是什么，有哪些分类？</h4><p>内部类可对同一包中其他类隐藏，内部类方法可以访问定义这个内部类的作用域中的数据，包括 private 数据。</p><p>内部类是一个编译器现象，与虚拟机无关。编译器会把内部类转换成常规的类文件，用 $ 分隔外部类名与内部类名，其中匿名内部类使用数字编号，虚拟机对此一无所知。</p><p><strong>静态内部类：</strong> 属于外部类，只加载一次。作用域仅在包内，可通过 <code>外部类名.内部类名</code> 直接访问，类内只能访问外部类所有静态属性和方法。HashMap 的 Node 节点，ReentrantLock 中的 Sync 类，ArrayList 的 SubList 都是静态内部类。内部类中还可以定义内部类，如 ThreadLoacl 静态内部类 ThreadLoaclMap 中定义了内部类 Entry。</p><p><strong>成员内部类：</strong> 属于外部类的每个对象，随对象一起加载。不可以定义静态成员和方法，可访问外部类的所有内容。</p><p><strong>局部内部类：</strong> 定义在方法内，不能声明访问修饰符，只能定义实例成员变量和实例方法，作用范围仅在声明类的代码块中。</p><p><strong>匿名内部类：</strong> 只用一次的没有名字的类，可以简化代码，创建的对象类型相当于 new 的类的子类类型。用于实现事件监听和其他回调。</p><hr><h4 id="Q7：访问权限控制符有哪些？"><a href="#Q7：访问权限控制符有哪些？" class="headerlink" title="Q7：访问权限控制符有哪些？"></a>Q7：访问权限控制符有哪些？</h4><table><thead><tr><th>访问权限控制符</th><th>本类</th><th>包内</th><th>包外子类</th><th>任何地方</th></tr></thead><tbody><tr><td>public</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>protected</td><td>√</td><td>√</td><td>√</td><td>×</td></tr><tr><td>无</td><td>√</td><td>√</td><td>×</td><td>×</td></tr><tr><td>private</td><td>√</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><hr><h4 id="Q8：接口和抽象类的异同？"><a href="#Q8：接口和抽象类的异同？" class="headerlink" title="Q8：接口和抽象类的异同？"></a>Q8：接口和抽象类的异同？</h4><p>接口和抽象类对实体类进行更高层次的抽象，仅定义公共行为和特征。</p><table><thead><tr><th>语法维度</th><th>抽象类</th><th>接口</th></tr></thead><tbody><tr><td>成员变量</td><td>无特殊要求</td><td>默认 public static final 常量</td></tr><tr><td>构造方法</td><td>有构造方法，不能实例化</td><td>没有构造方法，不能实例化</td></tr><tr><td>方法</td><td>抽象类可以没有抽象方法，但有抽象方法一定是抽象类。</td><td>默认 public abstract，JDK8 支持默认&#x2F;静态方法，JDK9 支持私有方法。</td></tr><tr><td>继承</td><td>单继承</td><td>多继承</td></tr></tbody></table><hr><h4 id="Q9：接口和抽象类应该怎么选择？"><a href="#Q9：接口和抽象类应该怎么选择？" class="headerlink" title="Q9：接口和抽象类应该怎么选择？"></a>Q9：接口和抽象类应该怎么选择？</h4><p>抽象类体现 is-a 关系，接口体现 can-do 关系。与接口相比，抽象类通常是对同类事物相对具体的抽象。</p><p>抽象类是模板式设计，包含一组具体特征，例如某<a href>汽车</a>，底盘、控制电路等是抽象出来的共同特征，但内饰、显示屏、座椅材质可以根据不同级别配置存在不同实现。</p><p>接口是契约式设计，是开放的，定义了方法名、参数、返回值、抛出的异常类型，谁都可以实现它，但必须遵守接口的约定。例如所有车辆都必须实现刹车这种强制规范。</p><p>接口是顶级类，抽象类在接口下面的第二层，对接口进行了组合，然后实现部分接口。当纠结定义接口和抽象类时，推荐定义为接口，遵循接口隔离原则，按维度划分成多个接口，再利用抽象类去实现这些，方便后续的扩展和重构。</p><p>例如 Plane 和 Bird 都有 fly 方法，应把 fly 定义为接口，而不是抽象类的抽象方法再继承，因为除了 fly 行为外 Plane 和 Bird 间很难再找到其他共同特征。</p><hr><h4 id="Q10：子类初始化的顺序"><a href="#Q10：子类初始化的顺序" class="headerlink" title="Q10：子类初始化的顺序"></a>Q10：子类初始化的顺序</h4><p>① 父类静态代码块和静态变量。② 子类静态代码块和静态变量。③ 父类普通代码块和普通变量。④ 父类构造方法。⑤ 子类普通代码块和普通变量。⑥ 子类构造方法。</p><hr><p>作者：是瑶瑶公主吖<br>链接：<a href="https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post">https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post</a><br>来源：牛客网</p><h3 id="集合-7"><a href="#集合-7" class="headerlink" title="集合 7"></a>集合 7</h3><h4 id="Q1：说一说-ArrayList"><a href="#Q1：说一说-ArrayList" class="headerlink" title="Q1：说一说 ArrayList"></a>Q1：说一说 ArrayList</h4><p><strong>ArrayList</strong> 是容量可变的非线程安全列表，使用数组实现，集合扩容时会创建更大的数组，把原有数组复制到新数组。支持对元素的快速随机访问，但插入与删除速度很慢。ArrayList 实现了 RandomAcess 标记接口，如果一个类实现了该接口，那么表示使用索引遍历比迭代器更快。</p><p><strong>elementData</strong>是 ArrayList 的数据域，被 transient 修饰，序列化时会调用 writeObject 写入流，反序列化时调用 readObject 重新赋值到新对象的 elementData。原因是 elementData 容量通常大于实际存储元素的数量，所以只需发送真正有实际值的数组元素。</p><p><strong>size</strong> 是当前实际大小，elementData 大小大于等于 size。</p><p>**modCount **记录了 ArrayList 结构性变化的次数，继承自 AbstractList。所有涉及结构变化的方法都会增加该值。expectedModCount 是迭代器初始化时记录的 modCount 值，每次访问新元素时都会检查 modCount 和 expectedModCount 是否相等，不相等就会抛出异常。这种机制叫做 fail-fast，所有集合类都有这种机制。</p><hr><h4 id="Q2：说一说-LinkedList"><a href="#Q2：说一说-LinkedList" class="headerlink" title="Q2：说一说 LinkedList"></a>Q2：说一说 LinkedList</h4><p><strong>LinkedList</strong> 本质是双向<a href>链表</a>，与 ArrayList 相比插入和删除速度更快，但随机访问元素很慢。除继承 AbstractList 外还实现了 Deque 接口，这个接口具有队列和栈的性质。成员变量被 transient 修饰，原理和 ArrayList 类似。</p><p>LinkedList 包含三个重要的成员：size、first 和 last。size 是双向<a href>链表</a>中节点的个数，first 和 last 分别指向首尾节点的引用。</p><p>LinkedList 的优点在于可以将零散的内存单元通过附加引用的方式关联起来，形成按链路顺序查找的线性结构，内存利用率较高。</p><hr><h4 id="Q3：Set-有什么特点，有哪些实现？"><a href="#Q3：Set-有什么特点，有哪些实现？" class="headerlink" title="Q3：Set 有什么特点，有哪些实现？"></a>Q3：Set 有什么特点，有哪些实现？</h4><p><strong>Set</strong> 不允许元素重复且无序，常用实现有 HashSet、LinkedHashSet 和 TreeSet。</p><p><strong>HashSet</strong> 通过 HashMap 实现，HashMap 的 Key 即 HashSet 存储的元素，所有 Key 都使用相同的 Value ，一个名为 PRESENT 的 Object 类型常量。使用 Key 保证元素唯一性，但不保证有序性。由于 HashSet 是 HashMap 实现的，因此线程不安全。</p><p>HashSet 判断元素是否相同时，对于包装类型直接按值比较。对于引用类型先比较 hashCode 是否相同，不同则代表不是同一个对象，相同则继续比较 equals，都相同才是同一个对象。</p><p><strong>LinkedHashSet</strong> 继承自 HashSet，通过 LinkedHashMap 实现，使用双向<a href>链表</a>维护元素插入顺序。</p><p><strong>TreeSet</strong> 通过 TreeMap 实现的，添加元素到集合时按照比较规则将其插入合适的位置，保证插入后的集合仍然有序。</p><hr><h4 id="Q4：TreeMap-有什么特点？"><a href="#Q4：TreeMap-有什么特点？" class="headerlink" title="Q4：TreeMap 有什么特点？"></a>Q4：TreeMap 有什么特点？</h4><p>TreeMap 基于<a href>红黑树</a>实现，增删改查的平均和最差时间复杂度均为 O(log<del>n</del>) ，最大特点是 Key 有序。Key 必须实现 Comparable 接口或提供的 Comparator 比较器，所以 Key 不允许为 null。</p><p>HashMap 依靠 <code>hashCode</code> 和 <code>equals</code> 去重，而 TreeMap 依靠 Comparable 或 Comparator。 TreeMap <a href>排序</a>时，如果比较器不为空就会优先使用比较器的 <code>compare</code> 方法，否则使用 Key 实现的 Comparable 的 <code>compareTo</code> 方法，两者都不满足会抛出异常。</p><p>TreeMap 通过 <code>put</code> 和 <code>deleteEntry</code> 实现增加和删除树节点。插入新节点的规则有三个：① 需要调整的新节点总是红色的。② 如果插入新节点的父节点是黑色的，不需要调整。③ 如果插入新节点的父节点是红色的，由于<a href>红黑树</a>不能出现相邻红色，进入循环判断，通过重新着色或左右旋转来调整。TreeMap 的插入操作就是按照 Key 的对比往下遍历，大于节点值向右查找，小于向左查找，先按照二叉查找树的特性操作，后续会重新着色和旋转，保持<a href>红黑树</a>的特性。</p><hr><h4 id="Q5：HashMap-有什么特点？"><a href="#Q5：HashMap-有什么特点？" class="headerlink" title="Q5：HashMap 有什么特点？"></a>Q5：HashMap 有什么特点？</h4><p>JDK8 之前底层实现是数组 + <a href>链表</a>，JDK8 改为数组 + <a href>链表</a>&#x2F;<a href>红黑树</a>，节点类型从Entry 变更为 Node。主要成员变量包括存储数据的 table 数组、元素数量 size、加载因子 loadFactor。</p><p>table 数组记录 HashMap 的数据，每个下标对应一条<a href>链表</a>，所有哈希冲突的数据都会被存放到同一条<a href>链表</a>，Node&#x2F;Entry 节点包含四个成员变量：key、value、next 指针和 hash 值。</p><p>HashMap 中数据以键值对的形式存在，键对应的 hash 值用来计算数组下标，如果两个元素 key 的 hash 值一样，就会发生哈希冲突，被放到同一个<a href>链表</a>上，为使查询效率尽可能高，键的 hash 值要尽可能分散。</p><p>HashMap 默认初始化容量为 16，扩容容量必须是 2 的幂次方、最大容量为 1&lt;&lt; 30 、默认加载因子为 0.75。</p><hr><h4 id="Q6：HashMap-相关方法的源码？"><a href="#Q6：HashMap-相关方法的源码？" class="headerlink" title="Q6：HashMap 相关方法的源码？"></a>Q6：HashMap 相关方法的<a href>源码</a>？</h4><p><strong>JDK8 之前</strong></p><p><strong>hash：计算元素 key 的散列值</strong></p><p>① 处理 String 类型时，调用 <code>stringHash32</code> 方法获取 hash 值。</p><p>② 处理其他类型数据时，提供一个相对于 HashMap 实例唯一不变的随机值 hashSeed 作为计算初始量。</p><p>③ 执行异或和无符号右移使 hash 值更加离散，减小哈希冲突概率。</p><p><strong>indexFor：计算元素下标</strong></p><p>将 hash 值和数组长度-1 进行与操作，保证结果不会超过 table 数组范围。</p><p><strong>get：获取元素的 value 值</strong></p><p>① 如果 key 为 null，调用 <code>getForNullKey</code> 方法，如果 size 为 0 表示<a href>链表</a>为空，返回 null。如果 size 不为 0 说明存在<a href>链表</a>，遍历 table[0] <a href>链表</a>，如果找到了 key 为 null 的节点则返回其 value，否则返回 null。</p><p>② 如果 key 为 不为 null，调用 <code>getEntry</code> 方法，如果 size 为 0 表示<a href>链表</a>为空，返回 null 值。如果 size 不为 0，首先计算 key 的 hash 值，然后遍历该<a href>链表</a>的所有节点，如果节点的 key 和 hash 值都和要查找的元素相同则返回其 Entry 节点。</p><p>③ 如果找到了对应的 Entry 节点，调用 <code>getValue</code> 方法获取其 value 并返回，否则返回 null。</p><p><strong>put：添加元素</strong></p><p>① 如果 key 为 null，直接存入 table[0]。</p><p>② 如果 key 不为 null，计算 key 的 hash 值。</p><p>③ 调用 <code>indexFor</code> 计算元素存放的下标 i。</p><p>④ 遍历 table[i] 对应的<a href>链表</a>，如果 key 已存在，就更新 value 然后返回旧 value。</p><p>⑤ 如果 key 不存在，将 modCount 值加 1，使用 <code>addEntry</code> 方法增加一个节点并返回 null。</p><p><strong>resize：扩容数组</strong></p><p>① 如果当前容量达到了最大容量，将阈值设置为 Integer 最大值，之后扩容不再触发。</p><p>② 否则计算新的容量，将阈值设为 <code>newCapacity x loadFactor</code> 和 <code>最大容量 + 1</code> 的较小值。</p><p>③ 创建一个容量为 newCapacity 的 Entry 数组，调用 <code>transfer</code> 方法将旧数组的元素转移到新数组。</p><p><strong>transfer：转移元素</strong></p><p>① 遍历旧数组的所有元素，调用 <code>rehash</code> 方法判断是否需要哈希重构，如果需要就重新计算元素 key 的 hash 值。</p><p>② 调用 <code>indexFor</code> 方法计算元素存放的下标 i，利用头插法将旧数组的元素转移到新数组。</p><p><strong>JDK8</strong></p><p><strong>hash：计算元素 key 的散列值</strong></p><p>如果 key 为 null 返回 0，否则就将 key 的 <code>hashCode</code> 方法返回值高低16位异或，让尽可能多的位参与运算，让结果的 0 和 1 分布更加均匀，降低哈希冲突概率。</p><p><strong>put：添加元素</strong></p><p>① 调用 <code>putVal</code> 方法添加元素。</p><p>② 如果 table 为空或长度为 0 就进行扩容，否则计算元素下标位置，不存在就调用 <code>newNode</code> 创建一个节点。</p><p>③ 如果存在且是<a href>链表</a>，如果首节点和待插入元素的 hash 和 key 都一样，更新节点的 value。</p><p>④ 如果首节点是 TreeNode 类型，调用 <code>putTreeVal</code> 方法增加一个树节点，每一次都比较插入节点和当前节点的大小，待插入节点小就往左子树查找，否则往右子树查找，找到空位后执行两个方法：<code>balanceInsert</code> 方法，插入节点并调整平衡、<code>moveRootToFront</code> 方法，由于调整平衡后根节点可能变化，需要重置根节点。</p><p>⑤ 如果都不满足，遍历<a href>链表</a>，根据 hash 和 key 判断是否重复，决定更新 value 还是新增节点。如果遍历到了<a href>链表</a>末尾则添加节点，如果达到建树阈值 7，还需要调用 <code>treeifyBin</code> 把<a href>链表</a>重构为<a href>红黑树</a>。</p><p>⑥ 存放元素后将 modCount 加 1，如果 <code>++size &gt; threshold</code> ，调用 <code>resize</code> 扩容。</p><p><strong>get ：获取元素的 value 值</strong></p><p>① 调用 <code>getNode</code> 方法获取 Node 节点，如果不是 null 就返回其 value 值，否则返回 null。</p><p>② <code>getNode</code> 方法中如果数组不为空且存在元素，先比较第一个节点和要查找元素的 hash 和 key ，如果都相同则直接返回。</p><p>③ 如果第二个节点是 TreeNode 类型则调用 <code>getTreeNode</code> 方法进行查找，否则遍历<a href>链表</a>根据 hash 和 key 查找，如果没有找到就返回 null。</p><p><strong>resize：扩容数组</strong></p><p>重新规划长度和阈值，如果长度发生了变化，部分数据节点也要重新排列。</p><p><strong>重新规划长度</strong></p><p>① 如果当前容量 <code>oldCap &gt; 0</code> 且达到最大容量，将阈值设为 Integer 最大值，return 终止扩容。</p><p>② 如果未达到最大容量，当 <code>oldCap &lt;&lt; 1</code> 不超过最大容量就扩大为 2 倍。</p><p>③ 如果都不满足且当前扩容阈值 <code>oldThr &gt; 0</code>，使用当前扩容阈值作为新容量。</p><p>④ 否则将新容量置为默认初始容量 16，新扩容阈值置为 12。</p><p><strong>重新排列数据节点</strong></p><p>① 如果节点为 null 不进行处理。</p><p>② 如果节点不为 null 且没有next节点，那么通过节点的 hash 值和 <code>新容量-1</code> 进行与运算计算下标存入新的 table 数组。</p><p>③ 如果节点为 TreeNode 类型，调用 <code>split</code> 方法处理，如果节点数 hc 达到6 会调用 <code>untreeify</code> 方法转回<a href>链表</a>。</p><p>④ 如果是<a href>链表</a>节点，需要将<a href>链表</a>拆分为 hash 值超出旧容量的<a href>链表</a>和未超出容量的<a href>链表</a>。对于<code>hash &amp; oldCap == 0</code> 的部分不需要做处理，否则需要放到新的下标位置上，新下标 &#x3D; 旧下标 + 旧容量。</p><hr><h4 id="Q7：HashMap-为什么线程不安全？"><a href="#Q7：HashMap-为什么线程不安全？" class="headerlink" title="Q7：HashMap 为什么线程不安全？"></a>Q7：HashMap 为什么线程不安全？</h4><p>JDK7 存在死循环和数据丢失问题。</p><p><strong>数据丢失：</strong></p><ul><li><strong>并发赋值被覆盖：</strong> 在 <code>createEntry</code> 方法中，新添加的元素直接放在头部，使元素之后可以被更快访问，但如果两个线程同时执行到此处，会导致其中一个线程的赋值被覆盖。</li><li><strong>已遍历区间新增元素丢失：</strong> 当某个线程在 <code>transfer</code> 方法迁移时，其他线程新增的元素可能落在已遍历过的哈希槽上。遍历完成后，table 数组引用指向了 newTable，新增元素丢失。</li><li><strong>新表被覆盖：</strong> 如果 <code>resize</code> 完成，执行了 <code>table = newTable</code>，则后续元素就可以在新表上进行插入。但如果多线程同时 <code>resize</code> ，每个线程都会 new 一个数组，这是线程内的局部对象，线程之间不可见。迁移完成后<code>resize</code> 的线程会赋值给 table 线程共享变量，可能会覆盖其他线程的操作，在新表中插入的对象都会被丢弃。</li></ul><p><strong>死循环：</strong> 扩容时 <code>resize</code> 调用 <code>transfer</code> 使用头插法迁移元素，虽然 newTable 是局部变量，但原先 table 中的 Entry <a href>链表</a>是共享的，问题根源是 Entry 的 next 指针并发修改，某线程还没有将 table 设为 newTable 时用完了 CPU 时间片，导致数据丢失或死循环。</p><p>JDK8 在 <code>resize</code> 方法中完成扩容，并改用尾插法，不会产生死循环，但并发下仍可能丢失数据。可用 ConcurrentHashMap 或 <code>Collections.synchronizedMap</code> 包装成同步集合。</p><hr><h3 id="IO-流-6"><a href="#IO-流-6" class="headerlink" title="IO 流 6"></a>IO 流 6</h3><h4 id="Q1：同步-x2F-异步-x2F-阻塞-x2F-非阻塞-IO-的区别？"><a href="#Q1：同步-x2F-异步-x2F-阻塞-x2F-非阻塞-IO-的区别？" class="headerlink" title="Q1：同步&#x2F;异步&#x2F;阻塞&#x2F;非阻塞 IO 的区别？"></a>Q1：同步&#x2F;异步&#x2F;阻塞&#x2F;非阻塞 IO 的区别？</h4><p>同步和异步是通信机制，阻塞和非阻塞是调用状态。</p><p>同步 IO 是用户线程发起 IO 请求后需要等待或轮询内核 IO 操作完成后才能继续执行。异步 IO 是用户线程发起 IO 请求后可以继续执行，当内核 IO 操作完成后会通知用户线程，或调用用户线程注册的回调函数。</p><p>阻塞 IO 是 IO 操作需要彻底完成后才能返回用户空间 。非阻塞 IO 是 IO 操作调用后立即返回一个状态值，无需等 IO 操作彻底完成。</p><hr><h4 id="Q2：什么是-BIO？"><a href="#Q2：什么是-BIO？" class="headerlink" title="Q2：什么是 BIO？"></a>Q2：什么是 BIO？</h4><p><strong>BIO</strong> 是同步阻塞式 IO，JDK1.4 之前的 IO 模型。服务器实现模式为一个连接请求对应一个线程，服务器需要为每一个<a href>客户端</a>请求创建一个线程，如果这个连接不做任何事会造成不必要的线程开销。可以通过线程池改善，这种 IO 称为伪异步 IO。适用连接数目少且服务器资源多的场景。</p><hr><h4 id="Q3：什么是-NIO？"><a href="#Q3：什么是-NIO？" class="headerlink" title="Q3：什么是 NIO？"></a>Q3：什么是 NIO？</h4><p><strong>NIO</strong> 是 JDK1.4 引入的同步非阻塞 IO。服务器实现模式为多个连接请求对应一个线程，<a href>客户端</a>连接请求会注册到一个多路复用器 Selector ，Selector 轮询到连接有 IO 请求时才启动一个线程处理。适用连接数目多且连接时间短的场景。</p><p>同步是指线程还是要不断接收<a href>客户端</a>连接并处理数据，非阻塞是指如果一个管道没有数据，不需要等待，可以轮询下一个管道。</p><p>核心组件：</p><ul><li><p><strong>Selector：</strong> 多路复用器，轮询检查多个 Channel 的状态，判断注册事件是否发生，即判断 Channel 是否处于可读或可写状态。使用前需要将 Channel 注册到 Selector，注册后会得到一个 SelectionKey，通过 SelectionKey 获取 Channel 和 Selector 相关信息。</p></li><li><p><strong>Channel：</strong> 双向通道，替换了 BIO 中的 Stream 流，不能直接访问数据，要通过 Buffer 来读写数据，也可以和其他 Channel 交互。</p></li><li><p><strong>Buffer：</strong> 缓冲区，本质是一块可读写数据的内存，用来简化数据读写。Buffer 三个重要属性：position 下次读写数据的位置，limit 本次读写的极限位置，capacity 最大容量。</p><ul><li><code>flip</code> 将写转为读，底层实现原理把 position 置 0，并把 limit 设为当前的 position 值。 </li><li><code>clear</code> 将读转为写模式（用于读完全部数据的情况，把 position 置 0，limit 设为 capacity）。 </li><li><code>compact</code> 将读转为写模式（用于存在未读数据的情况，让 position 指向未读数据的下一个）。 </li><li>通道方向和 Buffer 方向相反，读数据相当于向 Buffer 写，写数据相当于从 Buffer 读。</li></ul><p>使用步骤：向 Buffer 写数据，调用 flip 方法转为读模式，从 Buffer 中读数据，调用 clear 或 compact 方法清空缓冲区。</p></li></ul><hr><h4 id="Q4：什么是-AIO？"><a href="#Q4：什么是-AIO？" class="headerlink" title="Q4：什么是 AIO？"></a>Q4：什么是 AIO？</h4><p>AIO 是 JDK7 引入的异步非阻塞 IO。服务器实现模式为一个有效请求对应一个线程，<a href>客户端</a>的 IO 请求都是由操作系统先完成 IO 操作后再通知服务器应用来直接使用准备好的数据。适用连接数目多且连接时间长的场景。</p><p>异步是指服务端线程接收到<a href>客户端</a>管道后就交给底层处理IO通信，自己可以做其他事情，非阻塞是指<a href>客户端</a>有数据才会处理，处理好再通知服务器。</p><p>实现方式包括通过 Future 的 <code>get</code> 方法进行阻塞式调用以及实现 CompletionHandler 接口，重写请求成功的回调方法 <code>completed</code> 和请求失败回调方法 <code>failed</code>。</p><hr><h4 id="Q5：java-io-包下有哪些流？"><a href="#Q5：java-io-包下有哪些流？" class="headerlink" title="Q5：java.io 包下有哪些流？"></a>Q5：java.io 包下有哪些流？</h4><p>主要分为字符流和字节流，字符流一般用于文本文件，字节流一般用于图像或其他文件。</p><p>字符流包括了字符输入流 Reader 和字符输出流 Writer，字节流包括了字节输入流 InputStream 和字节输出流 OutputStream。字符流和字节流都有对应的缓冲流，字节流也可以包装为字符流，缓冲流带有一个 8KB 的缓冲数组，可以提高流的读写效率。除了缓冲流外还有过滤流 FilterReader、字符数组流 CharArrayReader、字节数组流 ByteArrayInputStream、文件流 FileInputStream 等。</p><hr><h4 id="Q6：序列化和反序列化是什么？"><a href="#Q6：序列化和反序列化是什么？" class="headerlink" title="Q6：序列化和反序列化是什么？"></a>Q6：序列化和反序列化是什么？</h4><p>Java 对象 JVM 退出时会全部销毁，如果需要将对象及状态持久化，就要通过序列化实现，将内存中的对象保存在二进制流中，需要时再将二进制流反序列化为对象。对象序列化保存的是对象的状态，因此属于类属性的静态变量不会被序列化。</p><p>常见的序列化有三种：</p><ul><li><p><strong>Java 原生序列化</strong></p><p>实现 <code>Serializabale</code> 标记接口，Java 序列化保留了对象类的元数据（如类、成员变量、继承类信息）以及对象数据，兼容性最好，但不支持跨语言，性能一般。序列化和反序列化必须保持序列化 ID 的一致，一般使用 <code>private static final long serialVersionUID</code> 定义序列化 ID，如果不设置编译器会根据类的内部实现自动生成该值。如果是兼容升级不应该修改序列化 ID，防止出错，如果是不兼容升级则需要修改。</p></li><li><p><strong>Hessian 序列化</strong></p><p>Hessian 序列化是一种支持动态类型、跨语言、基于对象传输的网络协议。Java 对象序列化的二进制流可以被其它语言反序列化。Hessian 协议的特性：① 自描述序列化类型，不依赖外部描述文件，用一个字节表示常用基础类型，极大缩短二进制流。② 语言无关，支持脚本语言。③ 协议简单，比 Java 原生序列化高效。Hessian 会把复杂对象所有属性存储在一个 Map 中序列化，当父类和子类存在同名成员变量时会先序列化子类再序列化父类，因此子类值会被父类覆盖。</p></li><li><p><strong>JSON 序列化</strong></p><p>JSON 序列化就是将数据对象转换为 JSON 字符串，在序列化过程中抛弃了类型信息，所以反序列化时只有提供类型信息才能准确进行。相比前两种方式可读性更好，方便调试。</p></li></ul><p>序列化通常会使用网络传输对象，而对象中往往有敏感数据，容易遭受攻击，Jackson 和 fastjson 等都出现过反序列化漏洞，因此不需要进行序列化的敏感属性传输时应加上 transient 关键字。transient 的作用就是把变量生命周期仅限于内存而不会写到磁盘里持久化，变量会被设为对应数据类型的零值。</p><hr><h2 id="JVM-32"><a href="#JVM-32" class="headerlink" title="JVM 32"></a>JVM 32</h2><h3 id="内存区域划分-8"><a href="#内存区域划分-8" class="headerlink" title="内存区域划分 8"></a>内存区域划分 8</h3><p>作者：是瑶瑶公主吖<br>链接：<a href="https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post">https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post</a><br>来源：牛客网</p><h4 id="Q1：运行时数据区是什么？"><a href="#Q1：运行时数据区是什么？" class="headerlink" title="Q1：运行时数据区是什么？"></a>Q1：运行时数据区是什么？</h4><p>虚拟机在执行 Java 程序的过程中会把它所管理的内存划分为若干不同的数据区，这些区域有各自的用途、创建和销毁时间。</p><p>线程私有：程序计数器、Java 虚拟机栈、本地方法栈。</p><p>线程共享：Java 堆、方法区。</p><hr><h4 id="Q2：程序计数器是什么？"><a href="#Q2：程序计数器是什么？" class="headerlink" title="Q2：程序计数器是什么？"></a>Q2：程序计数器是什么？</h4><p><strong>程序计数器</strong>是一块较小的内存空间，可以看作当前线程所执行字节码的行号指示器。字节码解释器工作时通过改变计数器的值选取下一条执行指令。分支、循环、跳转、线程恢复等功能都需要依赖计数器完成。是唯一在虚拟机规范中没有规定内存溢出情况的区域。</p><p>如果线程正在执行 Java 方法，计数器记录正在执行的虚拟机字节码指令地址。如果是本地方法，计数器值为 Undefined。</p><hr><h4 id="Q3：Java-虚拟机栈的作用？"><a href="#Q3：Java-虚拟机栈的作用？" class="headerlink" title="Q3：Java 虚拟机栈的作用？"></a>Q3：Java 虚拟机栈的作用？</h4><p><strong>Java 虚拟机栈</strong>来描述 Java 方法的内存模型。每当有新线程创建时就会分配一个栈空间，线程结束后栈空间被回收，栈与线程拥有相同的生命周期。栈中元素用于支持虚拟机进行方法调用，每个方法在执行时都会创建一个栈帧存储方法的局部变量表、操作栈、动态链接和方法出口等信息。每个方法从调用到执行完成，就是栈帧从入栈到出栈的过程。</p><p>有两类异常：① 线程请求的栈深度大于虚拟机允许的深度抛出 StackOverflowError。② 如果 JVM 栈容量可以动态扩展，栈扩展无法申请足够内存抛出 OutOfMemoryError（HotSpot 不可动态扩展，不存在此问题）。</p><hr><h4 id="Q4：本地方法栈的作用？"><a href="#Q4：本地方法栈的作用？" class="headerlink" title="Q4：本地方法栈的作用？"></a>Q4：本地方法栈的作用？</h4><p><strong>本地方法栈</strong>与虚拟机栈作用相似，不同的是虚拟机栈为虚拟机执行 Java 方法服务，本地方法栈为虚本地方法服务。调用本地方法时虚拟机栈保持不变，动态链接并直接调用指定本地方法。</p><p>虚拟机规范对本地方法栈中方法的语言与数据结构无强制规定，虚拟机可自由实现，例如 HotSpot 将虚拟机栈和本地方法栈合二为一。</p><p>本地方法栈在栈深度异常和栈扩展失败时分别抛出 StackOverflowError 和 OutOfMemoryError。</p><hr><h4 id="Q5：堆的作用是什么？"><a href="#Q5：堆的作用是什么？" class="headerlink" title="Q5：堆的作用是什么？"></a>Q5：堆的作用是什么？</h4><p><strong>堆</strong>是虚拟机所管理的内存中最大的一块，被所有线程共享的，在虚拟机启动时创建。堆用来存放对象实例，Java 里几乎所有对象实例都在堆分配内存。堆可以处于物理上不连续的内存空间，逻辑上应该连续，但对于例如数组这样的大对象，多数虚拟机实现出于简单、存储高效的考虑会要求连续的内存空间。</p><p>堆既可以被实现成固定大小，也可以是可扩展的，可通过 <code>-Xms</code> 和 <code>-Xmx</code> 设置堆的最小和最大容量，当前主流 JVM 都按照可扩展实现。如果堆没有内存完成实例分配也无法扩展，抛出 OutOfMemoryError。</p><hr><h4 id="Q6：方法区的作用是什么？"><a href="#Q6：方法区的作用是什么？" class="headerlink" title="Q6：方法区的作用是什么？"></a>Q6：方法区的作用是什么？</h4><p><strong>方法区</strong>用于存储被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据。</p><p>JDK8 之前使用永久代实现方法区，容易内存溢出，因为永久代有 <code>-XX:MaxPermSize</code> 上限，即使不设置也有默认大小。JDK7 把放在永久代的字符串常量池、静态变量等移出，JDK8 中永久代完全废弃，改用在本地内存中实现的元空间代替，把 JDK 7 中永久代剩余内容（主要是类型信息）全部移到元空间。</p><p>虚拟机规范对方法区的约束宽松，除和堆一样不需要连续内存和可选择固定大小&#x2F;可扩展外，还可以不实现垃圾回收。垃圾回收在方法区出现较少，主要目标针对常量池和类型卸载。如果方法区无法满足新的内存分配需求，将抛出 OutOfMemoryError。</p><hr><h4 id="Q7：运行时常量池的作用是什么"><a href="#Q7：运行时常量池的作用是什么" class="headerlink" title="Q7：运行时常量池的作用是什么?"></a>Q7：运行时常量池的作用是什么?</h4><p>运行时常量池是方法区的一部分，Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表，用于存放编译器生成的各种字面量与符号引用，这部分内容在类加载后存放到运行时常量池。一般除了保存 Class 文件中描述的符号引用外，还会把符号引用翻译的直接引用也存储在运行时常量池。</p><p>运行时常量池相对于 Class 文件常量池的一个重要特征是动态性，Java 不要求常量只有编译期才能产生，运行期间也可以将新的常量放入池中，这种特性利用较多的是 String 的 <code>intern</code> 方法。</p><p>运行时常量池是方法区的一部分，受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError。</p><hr><h4 id="Q8：直接内存是什么？"><a href="#Q8：直接内存是什么？" class="headerlink" title="Q8：直接内存是什么？"></a>Q8：直接内存是什么？</h4><p>直接内存不属于运行时数据区，也不是虚拟机规范定义的内存区域，但这部分内存被频繁使用，而且可能导致内存溢出。</p><p>JDK1.4 中新加入了 NIO 这种基于通道与缓冲区的 IO，它可以使用 Native 函数库直接分配堆外内存，通过一个堆里的 DirectByteBuffer 对象作为内存的引用进行操作，避免了在 Java 堆和 Native堆来回复制数据。</p><p>直接内存的分配不受 Java 堆大小的限制，但还是会受到本机总内存及处理器寻址空间限制，一般配置虚拟机参数时会根据实际内存设置 <code>-Xmx</code> 等参数信息，但经常忽略直接内存，使内存区域总和大于物理内存限制，导致动态扩展时出现 OOM。</p><p>由直接内存导致的内存溢出，一个明显的特征是在 Heap Dump 文件中不会看见明显的异常，如果发现内存溢出后产生的 Dump 文件很小，而程序中又直接或间接使用了直接内存（典型的间接使用就是 NIO），那么就可以考虑检查直接内存方面的原因。</p><hr><h3 id="内存溢出-5"><a href="#内存溢出-5" class="headerlink" title="内存溢出 5"></a>内存溢出 5</h3><h4 id="Q1：内存溢出和内存泄漏的区别？"><a href="#Q1：内存溢出和内存泄漏的区别？" class="headerlink" title="Q1：内存溢出和内存泄漏的区别？"></a>Q1：内存溢出和内存泄漏的区别？</h4><p>内存溢出 OutOfMemory，指程序在申请内存时，没有足够的内存空间供其使用。</p><p>内存泄露 Memory Leak，指程序在申请内存后，无法释放已申请的内存空间，内存泄漏最终将导致内存溢出。</p><hr><h4 id="Q2：堆溢出的原因？"><a href="#Q2：堆溢出的原因？" class="headerlink" title="Q2：堆溢出的原因？"></a>Q2：堆溢出的原因？</h4><p>堆用于存储对象实例，只要不断创建对象并保证 GC Roots 到对象有可达路径避免垃圾回收，随着对象数量的增加，总容量触及最大堆容量后就会 OOM，例如在 while 死循环中一直 new 创建实例。</p><p>堆 OOM 是实际应用中最常见的 OOM，处理方法是通过内存映像分析工具对 Dump 出的堆转储快照分析，确认内存中导致 OOM 的对象是否必要，分清到底是内存泄漏还是内存溢出。</p><p>如果是内存泄漏，通过工具查看泄漏对象到 GC Roots 的引用链，找到泄露对象是通过怎样的引用路径、与哪些 GC Roots 关联才导致无法回收，一般可以准确定位到产生内存泄漏代码的具***置。</p><p>如果不是内存泄漏，即内存中对象都必须存活，应当检查 JVM 堆参数，与机器内存相比是否还有向上调整的空间。再从代码检查是否存在某些对象生命周期过长、持有状态时间过长、存储结构设计不合理等情况，尽量减少程序运行期的内存消耗。</p><hr><h4 id="Q3：栈溢出的原因？"><a href="#Q3：栈溢出的原因？" class="headerlink" title="Q3：栈溢出的原因？"></a>Q3：栈溢出的原因？</h4><p>由于 HotSpot 不区分虚拟机和本地方法栈，设置本地方法栈大小的参数没有意义，栈容量只能由 <code>-Xss</code> 参数来设定，存在两种异常：</p><p><strong>StackOverflowError：</strong> 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 StackOverflowError，例如一个递归方法不断调用自己。该异常有明确错误堆栈可供分析，容易定位到问题所在。</p><p><strong>OutOfMemoryError：</strong> 如果 JVM 栈可以动态扩展，当扩展无法申请到足够内存时会抛出 OutOfMemoryError。HotSpot 不支持虚拟机栈扩展，所以除非在创建线程申请内存时就因无法获得足够内存而出现 OOM，否则在线程运行时是不会因为扩展而导致溢出的。</p><hr><h4 id="Q4：运行时常量池溢出的原因？"><a href="#Q4：运行时常量池溢出的原因？" class="headerlink" title="Q4：运行时常量池溢出的原因？"></a>Q4：运行时常量池溢出的原因？</h4><p>String 的 <code>intern</code> 方法是一个本地方法，作用是如果字符串常量池中已包含一个等于此 String 对象的字符串，则返回池中这个字符串的 String 对象的引用，否则将此 String 对象包含的字符串添加到常量池并返回此 String 对象的引用。</p><p>在 JDK6 及之前常量池分配在永久代，因此可以通过 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 限制永久代大小，间接限制常量池。在 while 死循环中调用 <code>intern</code> 方法导致运行时常量池溢出。在 JDK7 后不会出现该问题，因为存放在永久代的字符串常量池已经被移至堆中。</p><hr><h4 id="Q5：方法区溢出的原因？"><a href="#Q5：方法区溢出的原因？" class="headerlink" title="Q5：方法区溢出的原因？"></a>Q5：方法区溢出的原因？</h4><p>方法区主要存放类型信息，如类名、访问修饰符、常量池、字段描述、方法描述等。只要不断在运行时产生大量类，方法区就会溢出。例如使用 JDK 反射或 CGLib 直接操作字节码在运行时生成大量的类。很多框架如 Spring、Hibernate 等对类增强时都会使用 CGLib 这类字节码技术，增强的类越多就需要越大的方法区保证动态生成的新类型可以载入内存，也就更容易导致方法区溢出。</p><p>JDK8 使用元空间取代永久代，HotSpot 提供了一些参数作为元空间防御措施，例如 <code>-XX:MetaspaceSize</code> 指定元空间初始大小，达到该值会触发 GC 进行类型卸载，同时收集器会对该值进行调整，如果释放大量空间就适当降低该值，如果释放很少空间就适当提高。</p><hr><h3 id="创建对象-5"><a href="#创建对象-5" class="headerlink" title="创建对象 5"></a>创建对象 5</h3><h4 id="Q1：创建对象的过程是什么？"><a href="#Q1：创建对象的过程是什么？" class="headerlink" title="Q1：创建对象的过程是什么？"></a>Q1：创建对象的过程是什么？</h4><p><strong>字节码角度</strong></p><ul><li><strong>NEW：</strong> 如果找不到 Class 对象则进行类加载。加载成功后在堆中分配内存，从 Object 到本类路径上的所有属性都要分配。分配完毕后进行零值设置。最后将指向实例对象的引用变量压入虚拟机栈顶。 </li><li>**DUP： ** 在栈顶复制引用变量，这时栈顶有两个指向堆内实例的引用变量。两个引用变量的目的不同，栈底的引用用于赋值或保存局部变量表，栈顶的引用作为句柄调用相关方法。 </li><li><strong>INVOKESPECIAL：</strong> 通过栈顶的引用变量调用 init 方法。</li></ul><p><strong>执行角度</strong></p><p>① 当 JVM 遇到字节码 new 指令时，首先将检查该指令的参数能否在常量池中定位到一个类的符号引用，并检查引用代表的类是否已被加载、解析和初始化，如果没有就先执行类加载。</p><p>② 在类加载检查通过后虚拟机将为新生对象分配内存。</p><p>③ 内存分配完成后虚拟机将成员变量设为零值，保证对象的实例字段可以不赋初值就使用。</p><p>④ 设置对象头，包括哈希码、GC 信息、锁信息、对象所属类的类元信息等。</p><p>⑤ 执行 init 方法，初始化成员变量，执行实例化代码块，调用类的构造方法，并把堆内对象的首地址赋值给引用变量。</p><hr><h4 id="Q2：对象分配内存的方式有哪些？"><a href="#Q2：对象分配内存的方式有哪些？" class="headerlink" title="Q2：对象分配内存的方式有哪些？"></a>Q2：对象分配内存的方式有哪些？</h4><p>对象所需内存大小在类加载完成后便可完全确定，分配空间的任务实际上等于把一块确定大小的内存块从 Java 堆中划分出来。</p><p><strong>指针碰撞：</strong> 假设 Java 堆内存规整，被使用过的内存放在一边，空闲的放在另一边，中间放着一个指针作为分界指示器，分配内存就是把指针向空闲方向挪动一段与对象大小相等的距离。</p><p><strong>空闲列表：</strong> 如果 Java 堆内存不规整，虚拟机必须维护一个列表记录哪些内存可用，在分配时从列表中找到一块足够大的空间划分给对象并更新列表记录。</p><p>选择哪种分配方式由堆是否规整决定，堆是否规整由垃圾收集器是否有空间压缩能力决定。使用 Serial、ParNew 等收集器时，系统采用指针碰撞；使用 CMS 这种基于清除<a href>算法</a>的垃圾收集器时，采用空间列表。</p><hr><h4 id="Q3：对象分配内存是否线程安全？"><a href="#Q3：对象分配内存是否线程安全？" class="headerlink" title="Q3：对象分配内存是否线程安全？"></a>Q3：对象分配内存是否线程安全？</h4><p>对象创建十分频繁，即使修改一个指针的位置在并发下也不是线程安全的，可能正给对象 A 分配内存，指针还没来得及修改，对象 B 又使用了指针来分配内存。</p><p>解决方法：① CAS 加失败重试保证更新原子性。② 把内存分配按线程划分在不同空间，即每个线程在 Java 堆中预先分配一小块内存，叫做本地线程分配缓冲 TLAB，哪个线程要分配内存就在对应的 TLAB 分配，TLAB 用完了再进行同步。</p><hr><h4 id="Q4：对象的内存布局了解吗？"><a href="#Q4：对象的内存布局了解吗？" class="headerlink" title="Q4：对象的内存布局了解吗？"></a>Q4：对象的内存布局了解吗？</h4><p>对象在堆内存的存储布局可分为对象头、实例数据和对齐填充。</p><p><strong>对象头</strong>占 12B，包括对象标记和类型指针。对象标记存储对象自身的运行时数据，如哈希码、GC 分代年龄、锁标志、偏向线程 ID 等，这部分占 8B，称为 Mark Word。Mark Word 被设计为动态数据结构，以便在极小的空间存储更多数据，根据对象状态复用存储空间。</p><p>类型指针是对象指向它的类型元数据的指针，占 4B。JVM 通过该指针来确定对象是哪个类的实例。</p><p><strong>实例数据</strong>是对象真正存储的有效信息，即本类对象的实例成员变量和所有可见的父类成员变量。存储顺序会受到虚拟机分配策略参数和字段在<a href>源码</a>中定义顺序的影响。相同宽度的字段总是被分配到一起存放，在满足该前提条件的情况下父类中定义的变量会出现在子类之前。</p><p><strong>对齐填充</strong>不是必然存在的，仅起占位符作用。虚拟机的自动内存管理系统要求任何对象的大小必须是 8B 的倍数，对象头已被设为 8B 的 1 或 2 倍，如果对象实例数据部分没有对齐，需要对齐填充补全。</p><hr><h4 id="Q5：对象的访问方式有哪些？"><a href="#Q5：对象的访问方式有哪些？" class="headerlink" title="Q5：对象的访问方式有哪些？"></a>Q5：对象的访问方式有哪些？</h4><p>Java 程序会通过栈上的 reference 引用操作堆对象，访问方式由虚拟机决定，主流访问方式主要有句柄和直接指针。</p><p><strong>句柄：</strong> 堆会划分出一块内存作为句柄池，reference 中存储对象的句柄地址，句柄包含对象实例数据与类型数据的地址信息。优点是 reference 中存储的是稳定句柄地址，在 GC 过程中对象被移动时只会改变句柄的实例数据指针，而 reference 本身不需要修改。</p><p><strong>直接指针：</strong> 堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference 存储对象地址，如果只是访问对象本身就不需要多一次间接访问的开销。优点是速度更快，节省了一次指针定位的时间开销，HotSpot 主要使用直接指针进行对象访问。</p><hr><h3 id="垃圾回收-7"><a href="#垃圾回收-7" class="headerlink" title="垃圾回收 7"></a>垃圾回收 7</h3><h4 id="Q1：如何判断对象是否是垃圾？"><a href="#Q1：如何判断对象是否是垃圾？" class="headerlink" title="Q1：如何判断对象是否是垃圾？"></a>Q1：如何判断对象是否是垃圾？</h4><p><strong>引用计数：</strong>在对象中添加一个引用计数器，如果被引用计数器加 1，引用失效时计数器减 1，如果计数器为 0 则被标记为垃圾。原理简单，效率高，但是在 Java 中很少使用，因为存在对象间循环引用的问题，导致计数器无法清零。</p><p><strong>可达性分析：</strong>主流语言的内存管理都使用可达性分析判断对象是否存活。基本思路是通过一系列称为 GC Roots 的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径称为引用链，如果某个对象到 GC Roots 没有任何引用链相连，则会被标记为垃圾。可作为 GC Roots 的对象包括虚拟机栈和本地方法栈中引用的对象、类静态属性引用的对象、常量引用的对象。</p><hr><h4 id="Q2：Java-的引用有哪些类型？"><a href="#Q2：Java-的引用有哪些类型？" class="headerlink" title="Q2：Java 的引用有哪些类型？"></a>Q2：Java 的引用有哪些类型？</h4><p>JDK1.2 后对引用进行了扩充，按强度分为四种：</p><p><strong>强引用：</strong> 最常见的引用，例如 <code>Object obj = new Object()</code> 就属于强引用。只要对象有强引用指向且 GC Roots 可达，在内存回收时即使濒临内存耗尽也不会被回收。</p><p><strong>软引用：</strong> 弱于强引用，描述非必需对象。在系统将发生内存溢出前，会把软引用关联的对象加入回收范围以获得更多内存空间。用来缓存服务器中间计算结果及不需要实时保存的用户行为等。</p><p><strong>弱引用：</strong> 弱于软引用，描述非必需对象。弱引用关联的对象只能生存到下次 YGC 前，当垃圾收集器开始工作时无论当前内存是否足够都会回收只被弱引用关联的对象。由于 YGC 具有不确定性，因此弱引用何时被回收也不确定。</p><p><strong>虚引用：</strong> 最弱的引用，定义完成后无法通过该引用获取对象。唯一目的就是为了能在对象被回收时收到一个系统通知。虚引用必须与引用队列联合使用，垃圾回收时如果出现虚引用，就会在回收对象前把这个虚引用加入引用队列。</p><hr><h4 id="Q3：有哪些-GC-算法？"><a href="#Q3：有哪些-GC-算法？" class="headerlink" title="Q3：有哪些 GC 算法？"></a>Q3：有哪些 GC <a href>算法</a>？</h4><p><strong>标记-清除<a href>算法</a></strong></p><p>分为标记和清除阶段，首先从每个 GC Roots 出发依次标记有引用关系的对象，最后清除没有标记的对象。</p><p>执行效率不稳定，如果堆包含大量对象且大部分需要回收，必须进行大量标记清除，导致效率随对象数量增长而降低。</p><p>存在内存空间碎片化问题，会产生大量不连续的内存碎片，导致以后需要分配大对象时容易触发 Full GC。</p><p><strong>标记-复制<a href>算法</a></strong></p><p>为了解决内存碎片问题，将可用内存按容量划分为大小相等的两块，每次只使用其中一块。当使用的这块空间用完了，就将存活对象复制到另一块，再把已使用过的内存空间一次清理掉。主要用于进行新生代。</p><p>实现简单、运行高效，解决了内存碎片问题。 代价是可用内存缩小为原来的一半，浪费空间。</p><p>HotSpot 把新生代划分为一块较大的 Eden 和两块较小的 Sur<a href>vivo</a>r，每次分配内存只使用 Eden 和其中一块 Sur<a href>vivo</a>r。垃圾收集时将 Eden 和 Sur<a href>vivo</a>r 中仍然存活的对象一次性复制到另一块 Sur<a href>vivo</a>r 上，然后直接清理掉 Eden 和已用过的那块 Sur<a href>vivo</a>r。HotSpot 默认Eden 和 Sur<a href>vivo</a>r 的大小比例是 8:1，即每次新生代中可用空间为整个新生代的 90%。</p><p><strong>标记-整理<a href>算法</a></strong></p><p>标记-复制<a href>算法</a>在对象存活率高时要进行较多复制操作，效率低。如果不想浪费空间，就需要有额外空间分配担保，应对被使用内存中所有对象都存活的极端情况，所以老年代一般不使用此<a href>算法</a>。</p><p>老年代使用标记-整理<a href>算法</a>，标记过程与标记-清除<a href>算法</a>一样，但不直接清理可回收对象，而是让所有存活对象都向内存空间一端移动，然后清理掉边界以外的内存。</p><p>标记-清除与标记-整理的差异在于前者是一种非移动式<a href>算法</a>而后者是移动式的。如果移动存活对象，尤其是在老年代这种每次回收都有大量对象存活的区域，是一种极为负重的操作，而且移动必须全程暂停用户线程。如果不移动对象就会导致空间碎片问题，只能依赖更复杂的内存分配器和访问器解决。</p><hr><h4 id="Q4：你知道哪些垃圾收集器？"><a href="#Q4：你知道哪些垃圾收集器？" class="headerlink" title="Q4：你知道哪些垃圾收集器？"></a>Q4：你知道哪些垃圾收集器？</h4><p><strong>Serial</strong></p><p>最基础的收集器，使用复制<a href>算法</a>、单线程工作，只用一个处理器或一条线程完成垃圾收集，进行垃圾收集时必须暂停其他所有工作线程。</p><p>Serial 是虚拟机在<a href>客户端</a>模式的默认新生代收集器，简单高效，对于内存受限的环境它是所有收集器中额外内存消耗最小的，对于处理器核心较少的环境，Serial 由于没有线程交互开销，可获得最高的单线程收集效率。</p><p><strong>ParNew</strong></p><p>Serial 的多线程版本，除了使用多线程进行垃圾收集外其余行为完全一致。</p><p>ParNew 是虚拟机在服务端模式的默认新生代收集器，一个重要原因是除了 Serial 外只有它能与 CMS 配合。自从 JDK 9 开始，ParNew 加 CMS 不再是官方推荐的解决方案，官方希望它被 G1 取代。</p><p><strong>Parallel Scavenge</strong></p><p>新生代收集器，基于复制<a href>算法</a>，是可并行的多线程收集器，与 ParNew 类似。</p><p>特点是它的关注点与其他收集器不同，Parallel Scavenge 的目标是达到一个可控制的吞吐量，吞吐量就是处理器用于运行用户代码的时间与处理器消耗总时间的比值。</p><p><strong>Serial Old</strong></p><p>Serial 的老年代版本，单线程工作，使用标记-整理<a href>算法</a>。</p><p>Serial Old 是虚拟机在<a href>客户端</a>模式的默认老年代收集器，用于服务端有两种用途：① JDK5 及之前与 Parallel Scavenge 搭配。② 作为CMS 失败预案。</p><p><strong>Parellel Old</strong></p><p>Parallel Scavenge 的老年代版本，支持多线程，基于标记-整理<a href>算法</a>。JDK6 提供，注重吞吐量可考虑 Parallel Scavenge 加 Parallel Old。</p><p><strong>CMS</strong></p><p>以获取最短回收停顿时间为目标，基于标记-清除<a href>算法</a>，过程相对复杂，分为四个步骤：初始标记、并发标记、重新标记、并发清除。</p><p>初始标记和重新标记需要 STW（Stop The World，系统停顿），初始标记仅是标记 GC Roots 能直接关联的对象，速度很快。并发标记从 GC Roots 的直接关联对象开始遍历整个对象图，耗时较长但不需要停顿用户线程。重新标记则是为了修正并发标记期间因用户程序运作而导致标记产生变动的那部分记录。并发清除清理标记阶段判断的已死亡对象，不需要移动存活对象，该阶段也可与用户线程并发。</p><p>缺点：① 对处理器资源敏感，并发阶段虽然不会导致用户线程暂停，但会降低吞吐量。② 无法处理浮动垃圾，有可能出现并发失败而导致 Full GC。③ 基于标记-清除<a href>算法</a>，产生空间碎片。</p><p><strong>G1</strong></p><p>开创了收集器面向局部收集的设计思路和基于 Region 的内存布局，主要面向服务端，最初设计目标是替换 CMS。</p><p>G1 之前的收集器，垃圾收集目标要么是整个新生代，要么是整个老年代或整个堆。而 G1 可面向堆任何部分来组成回收集进行回收，衡量标准不再是分代，而是哪块内存中存放的垃圾数量最多，回收受益最大。</p><p>跟踪各 Region 里垃圾的价值，价值即回收所获空间大小以及回收所需时间的经验值，在后台维护一个优先级列表，每次根据用户设定允许的收集停顿时间优先处理回收价值最大的 Region。这种方式保证了 G1 在有限时间内获取尽可能高的收集效率。</p><p>G1 运作过程：</p><ul><li><strong>初始标记：</strong>标记 GC Roots 能直接关联到的对象，让下一阶段用户线程并发运行时能正确地在可用 Region 中分配新对象。需要 STW 但耗时很短，在 Minor GC 时同步完成。 </li><li><strong>并发标记：</strong>从 GC Roots 开始对堆中对象进行可达性分析，递归扫描整个堆的对象图。耗时长但可与用户线程并发，扫描完成后要重新处理 SATB 记录的在并发时有变动的对象。 </li><li><strong>最终标记：</strong>对用户线程做短暂暂停，处理并发阶段结束后仍遗留下来的少量 SATB 记录。 </li><li><strong>筛选回收：</strong>对各 Region 的回收价值<a href>排序</a>，根据用户期望停顿时间制定回收计划。必须暂停用户线程，由多条收集线程并行完成。</li></ul><p>可由用户指定期望停顿时间是 G1 的一个强大功能，但该值不能设得太低，一般设置为100~300 ms。</p><hr><h4 id="Q5：ZGC-了解吗？"><a href="#Q5：ZGC-了解吗？" class="headerlink" title="Q5：ZGC 了解吗？"></a>Q5：ZGC 了解吗？</h4><p>JDK11 中加入的具有实验性质的低延迟垃圾收集器，目标是尽可能在不影响吞吐量的前提下，实现在任意堆内存大小都可以把停顿时间限制在 10ms 以内的低延迟。</p><p>基于 Region 内存布局，不设分代，使用了读屏障、染色指针和内存多重映射等技术实现可并发的标记-整理，以低延迟为首要目标。</p><p>ZGC 的 Region 具有动态性，是动态创建和销毁的，并且容量大小也是动态变化的。</p><hr><h4 id="Q6：你知道哪些内存分配与回收策略？"><a href="#Q6：你知道哪些内存分配与回收策略？" class="headerlink" title="Q6：你知道哪些内存分配与回收策略？"></a>Q6：你知道哪些内存分配与回收策略？</h4><p><strong>对象优先在 Eden 区分配</strong></p><p>大多数情况下对象在新生代 Eden 区分配，当 Eden 没有足够空间时将发起一次 Minor GC。</p><p><strong>大对象直接进入老年代</strong></p><p>大对象指需要大量连续内存空间的对象，典型是很长的字符串或数量庞大的数组。大对象容易导致内存还有不少空间就提前触发垃圾收集以获得足够的连续空间。</p><p>HotSpot 提供了 <code>-XX:PretenureSizeThreshold</code> 参数，大于该值的对象直接在老年代分配，避免在 Eden 和 Sur<a href>vivo</a>r 间来回复制。</p><p><strong>长期存活对象进入老年代</strong></p><p>虚拟机给每个对象定义了一个对象年龄计数器，存储在对象头。如果经历过第一次 Minor GC 仍然存活且能被 Sur<a href>vivo</a>r 容纳，该对象就会被移动到 Sur<a href>vivo</a>r 中并将年龄设置为 1。对象在 Sur<a href>vivo</a>r 中每熬过一次 Minor GC 年龄就加 1 ，当增加到一定程度（默认15）就会被晋升到老年代。对象晋升老年代的阈值可通过 <code>-XX:MaxTenuringThreshold</code> 设置。</p><p><strong>动态对象年龄判定</strong></p><p>为了适应不同内存状况，虚拟机不要求对象年龄达到阈值才能晋升老年代，如果在 Sur<a href>vivo</a>r 中相同年龄所有对象大小的总和大于 Sur<a href>vivo</a>r 的一半，年龄不小于该年龄的对象就可以直接进入老年代。</p><p><strong>空间分配担保</strong></p><p>MinorGC 前虚拟机必须检查老年代最大可用连续空间是否大于新生代对象总空间，如果满足则说明这次 Minor GC 确定安全。</p><p>如果不满足，虚拟机会查看 <code>-XX:HandlePromotionFailure</code> 参数是否允许担保失败，如果允许会继续检查老年代最大可用连续空间是否大于历次晋升老年代对象的平均大小，如果满足将冒险尝试一次 Minor GC，否则改成一次 FullGC。</p><p>冒险是因为新生代使用复制<a href>算法</a>，为了内存利用率只使用一个 Sur<a href>vivo</a>r，大量对象在 Minor GC 后仍然存活时，需要老年代进行分配担保，接收 Sur<a href>vivo</a>r 无法容纳的对象。</p><hr><h4 id="Q7：你知道哪些故障处理工具？"><a href="#Q7：你知道哪些故障处理工具？" class="headerlink" title="Q7：你知道哪些故障处理工具？"></a>Q7：你知道哪些故障处理工具？</h4><p><strong>jps：虚拟机进程状况工具</strong></p><p>功能和 ps 命令类似：可以列出正在运行的虚拟机进程，显示虚拟机执行主类名称以及这些进程的本地虚拟机唯一 ID（LVMID)。LVMID 与操作系统的进程 ID（PID）一致，使用 Windows 的任务管理器或 UNIX 的 ps 命令也可以查询到虚拟机进程的 LVMID，但如果同时启动了多个虚拟机进程，必须依赖 jps 命令。</p><p><strong>jstat：虚拟机统计信息监视工具</strong></p><p>用于监视虚拟机各种运行状态信息。可以显示本地或远程虚拟机进程中的类加载、内存、垃圾收集、即时编译器等运行时数据，在没有 GUI 界面的服务器上是运行期定位虚拟机性能问题的常用工具。</p><p>参数含义：S0 和 S1 表示两个 Sur<a href>vivo</a>r，E 表示新生代，O 表示老年代，YGC 表示 Young GC 次数，YGCT 表示 Young GC 耗时，FGC 表示 Full GC 次数，FGCT 表示 Full GC 耗时，GCT 表示 GC 总耗时。</p><p><strong>jinfo：Java 配置信息工具</strong></p><p>实时查看和调整虚拟机各项参数，使用 jps 的 -v 参数可以查看虚拟机启动时显式指定的参数，但如果想知道未显式指定的参数值只能使用 jinfo 的 -flag 查询。</p><p><strong>jmap：Java 内存映像工具</strong></p><p>用于生成堆转储快照，还可以查询 finalize 执行队列、Java 堆和方法区的详细信息，如空间使用率，当前使用的是哪种收集器等。和 jinfo 一样，部分功能在 Windows 受限，除了生成堆转储快照的 -dump 和查看每个类实例的 -histo 外，其余选项只能在 Linux 使用。</p><p><strong>jhat：虚拟机堆转储快照分析工具</strong></p><p>JDK 提供 jhat 与 jmap 搭配使用分析 jmap 生成的堆转储快照。jhat 内置了一个微型的 HTTP&#x2F;Web 服务器，生成堆转储快照的分析结果后可以在浏览器查看。</p><p><strong>jstack：Java 堆栈跟踪工具</strong></p><p>用于生成虚拟机当前时刻的线程快照。线程快照就是当前虚拟机内每一条线程正在执行的方法堆栈的集合，生成线程快照的目的通常是定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间挂起等。线程出现停顿时通过 jstack 查看各个线程的调用堆栈，可以获知没有响应的线程在后台做什么或等什么资源。</p><hr><h3 id="类加载机制-7"><a href="#类加载机制-7" class="headerlink" title="类加载机制 7"></a>类加载机制 7</h3><p>作者：是瑶瑶公主吖<br>链接：<a href="https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post">https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post</a><br>来源：牛客网</p><h4 id="Q1：Java-程序是怎样运行的？"><a href="#Q1：Java-程序是怎样运行的？" class="headerlink" title="Q1：Java 程序是怎样运行的？"></a>Q1：Java 程序是怎样运行的？</h4><ul><li><p>首先通过 Javac 编译器将 <code>.java</code> 转为 JVM 可加载的 <code>.class</code> 字节码文件。</p><p>Javac 是由 Java 编写的程序，编译过程可以分为： ① 词法解析，通过空格分割出单词、操作符、控制符等信息，形成 token 信息流，传递给语法解析器。② 语法解析，把 token 信息流按照 Java 语法规则组装成语法树。③ 语义分析，检查关键字使用是否合理、类型是否匹配、作用域是否正确等。④ 字节码生成，将前面各个步骤的信息转换为字节码。</p><p>字节码必须通过类加载过程加载到 JVM 后才可以执行，执行有三种模式，解释执行、JIT 编译执行、JIT 编译与解释器混合执行（主流 JVM 默认执行的方式）。混合模式的优势在于解释器在启动时先解释执行，省去编译时间。</p></li><li><p>之后通过即时编译器 JIT 把字节码文件编译成本地机器码。</p><p>Java 程序最初都是通过解释器进行解释执行的，当虚拟机发现某个方法或代码块的运行特别频繁，就会认定其为”热点代码”，热点代码的检测主要有基于采样和基于计数器两种方式，为了提高热点代码的执行效率，虚拟机会把它们编译成本地机器码，尽可能对代码优化，在运行时完成这个任务的后端编译器被称为即时编译器。</p></li><li><p>还可以通过静态的提前编译器 AOT 直接把程序编译成与目标机器指令集相关的二进制代码。</p></li></ul><hr><h4 id="Q2：类加载是什么？"><a href="#Q2：类加载是什么？" class="headerlink" title="Q2：类加载是什么？"></a>Q2：类加载是什么？</h4><p>Class 文件中描述的各类信息都需要加载到虚拟机后才能使用。JVM 把描述类的数据从 Class 文件加载到内存，并对数据进行校验、解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这个过程称为虚拟机的类加载机制。</p><p>与编译时需要连接的语言不同，Java 中类型的加载、连接和初始化都是在运行期间完成的，这增加了性能开销，但却提供了极高的扩展性，Java 动态扩展的语言特性就是依赖运行期动态加载和连接实现的。</p><p>一个类型从被加载到虚拟机内存开始，到卸载出内存为止，整个生命周期经历加载、验证、准备、解析、初始化、使用和卸载七个阶段，其中验证、解析和初始化三个部分称为连接。加载、验证、准备、初始化阶段的顺序是确定的，解析则不一定：可能在初始化之后再开始，这是为了支持 Java 的动态绑定。</p><hr><h4 id="Q3：类初始化的情况有哪些？"><a href="#Q3：类初始化的情况有哪些？" class="headerlink" title="Q3：类初始化的情况有哪些？"></a>Q3：类初始化的情况有哪些？</h4><p>① 遇到 <code>new</code>、<code>getstatic</code>、<code>putstatic</code> 或 <code>invokestatic</code> 字节码指令时，还未初始化。典型场景包括 new 实例化对象、读取或设置静态字段、调用静态方法。</p><p>② 对类反射调用时，还未初始化。</p><p>③ 初始化类时，父类还未初始化。</p><p>④ 虚拟机启动时，会先初始化包含 main 方法的主类。</p><p>⑤ 使用 JDK7 的动态语言支持时，如果 MethodHandle 实例的解析结果为指定类型的方法句柄且句柄对应的类还未初始化。</p><p>⑥ 接口定义了默认方法，如果接口的实现类初始化，接口要在其之前初始化。</p><p>其余所有引用类型的方式都不会触发初始化，称为被动引用。被动引用实例：① 子类使用父类的静态字段时，只有父类被初始化。② 通过数组定义使用类。③ 常量在编译期会存入调用类的常量池，不会初始化定义常量的类。</p><p>接口和类加载过程的区别：初始化类时如果父类没有初始化需要初始化父类，但接口初始化时不要求父接口初始化，只有在真正使用父接口时（如引用接口中定义的常量）才会初始化。</p><hr><h4 id="Q4：类加载的过程是什么？"><a href="#Q4：类加载的过程是什么？" class="headerlink" title="Q4：类加载的过程是什么？"></a>Q4：类加载的过程是什么？</h4><p><strong>加载</strong></p><p>该阶段虚拟机需要完成三件事：① 通过一个类的全限定类名获取定义类的二进制字节流。② 将字节流所代表的静态存储结构转化为方法区的运行时数据区。③ 在内存中生成对应该类的 Class 实例，作为方法区这个类的数据访问入口。</p><p><strong>验证</strong></p><p>确保 Class 文件的字节流符合约束。如果虚拟机不检查输入的字节流，可能因为载入有错误或恶意企图的字节流而导致系统受攻击。验证主要包含四个阶段：文件格式验证、元数据验证、字节码验证、符号引用验证。</p><p>验证重要但非必需，因为只有通过与否的区别，通过后对程序运行期没有任何影响。如果代码已被反复使用和验证过，在生产环境就可以考虑关闭大部分验证缩短类加载时间。</p><p><strong>准备</strong></p><p>为类静态变量分配内存并设置零值，该阶段进行的内存分配仅包括类变量，不包括实例变量。如果变量被 final 修饰，编译时 Javac 会为变量生成 ConstantValue 属性，准备阶段虚拟机会将变量值设为代码值。</p><p><strong>解析</strong></p><p>将常量池内的符号引用替换为直接引用。</p><p><strong>符号引用</strong>以一组符号描述引用目标，可以是任何形式的字面量，只要使用时能无歧义地定位目标即可。与虚拟机内存布局无关，引用目标不一定已经加载到虚拟机内存。</p><p><strong>直接引用</strong>是可以直接指向目标的指针、相对偏移量或能间接定位到目标的句柄。和虚拟机的内存布局相关，引用目标必须已在虚拟机的内存中存在。</p><p><strong>初始化</strong></p><p>直到该阶段 JVM 才开始执行类中编写的代码。准备阶段时变量赋过零值，初始化阶段会根据程序员的编码去初始化类变量和其他资源。初始化阶段就是执行类构造方法中的 <code>&lt;client&gt;</code> 方法，该方法是 Javac 自动生成的。</p><hr><h4 id="Q5：有哪些类加载器？"><a href="#Q5：有哪些类加载器？" class="headerlink" title="Q5：有哪些类加载器？"></a>Q5：有哪些类加载器？</h4><p>自 JDK1.2 起 Java 一直保持三层类加载器：</p><ul><li><p><strong>启动类加载器</strong></p><p>在 JVM 启动时创建，负责加载最核心的类，例如 Object、System 等。无法被程序直接引用，如果需要把加载委派给启动类加载器，直接使用 null 代替即可，因为启动类加载器通常由操作系统实现，并不存在于 JVM 体系。</p></li><li><p><strong>平台类加载器</strong></p><p>从 JDK9 开始从扩展类加载器更换为平台类加载器，负载加载一些扩展的系统类，比如 XML、加密、压缩相关的功能类等。</p></li><li><p><strong>应用类加载器</strong></p><p>也称系统类加载器，负责加载用户类路径上的类库，可以直接在代码中使用。如果没有自定义类加载器，一般情况下应用类加载器就是默认的类加载器。自定义类加载器通过继承 ClassLoader 并重写 <code>findClass</code> 方法实现。</p></li></ul><hr><h4 id="Q6：双亲委派模型是什么？"><a href="#Q6：双亲委派模型是什么？" class="headerlink" title="Q6：双亲委派模型是什么？"></a>Q6：双亲委派模型是什么？</h4><p>类加载器具有等级制度但非继承关系，以组合的方式复用父加载器的功能。双亲委派模型要求除了顶层的启动类加载器外，其余类加载器都应该有自己的父加载器。</p><p>一个类加载器收到了类加载请求，它不会自己去尝试加载，而将该请求委派给父加载器，每层的类加载器都是如此，因此所有加载请求最终都应该传送到启动类加载器，只有当父加载器反馈无法完成请求时，子加载器才会尝试。</p><p>类跟随它的加载器一起具备了有优先级的层次关系，确保某个类在各个类加载器环境中都是同一个，保证程序的稳定性。</p><hr><h4 id="Q7：如何判断两个类是否相等？"><a href="#Q7：如何判断两个类是否相等？" class="headerlink" title="Q7：如何判断两个类是否相等？"></a>Q7：如何判断两个类是否相等？</h4><p>任意一个类都必须由类加载器和这个类本身共同确立其在虚拟机中的唯一性。</p><p>两个类只有由同一类加载器加载才有比较意义，否则即使两个类来源于同一个 Class 文件，被同一个 JVM 加载，只要类加载器不同，这两个类就必定不相等。</p><hr><h2 id="并发-39"><a href="#并发-39" class="headerlink" title="并发 39"></a>并发 39</h2><h3 id="JMM-8"><a href="#JMM-8" class="headerlink" title="JMM 8"></a>JMM 8</h3><p>作者：是瑶瑶公主吖<br>链接：<a href="https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post">https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post</a><br>来源：牛客网</p><h4 id="Q1：JMM-的作用是什么？"><a href="#Q1：JMM-的作用是什么？" class="headerlink" title="Q1：JMM 的作用是什么？"></a>Q1：JMM 的作用是什么？</h4><p>Java 线程的通信由 JMM 控制，JMM 的主要目的是定义程序中各种变量的访问规则。变量包括实例字段、静态字段，但不包括局部变量与方法参数，因为它们是线程私有的，不存在多线程竞争。JMM 遵循一个基本原则：只要不改变程序执行结果，编译器和处理器怎么优化都行。例如编译器分析某个锁只会单线程访问就消除锁，某个 volatile 变量只会单线程访问就把它当作普通变量。</p><p>JMM 规定所有变量都存储在主内存，每条线程有自己的工作内存，工作内存中保存被该线程使用的变量的主内存副本，线程对变量的所有操作都必须在工作空间进行，不能直接读写主内存数据。不同线程间无法直接访问对方工作内存中的变量，线程通信必须经过主内存。</p><p>关于主内存与工作内存的交互，即变量如何从主内存拷贝到工作内存、从工作内存同步回主内存，JMM 定义了 8 种原子操作：</p><table><thead><tr><th>操作</th><th>作用变量范围</th><th>作用</th></tr></thead><tbody><tr><td>lock</td><td>主内存</td><td>把变量标识为线程独占状态</td></tr><tr><td>unlock</td><td>主内存</td><td>释放处于锁定状态的变量</td></tr><tr><td>read</td><td>主内存</td><td>把变量值从主内存传到工作内存</td></tr><tr><td>load</td><td>工作内存</td><td>把 read 得到的值放入工作内存的变量副本</td></tr><tr><td>user</td><td>工作内存</td><td>把工作内存中的变量值传给执行引擎</td></tr><tr><td>assign</td><td>工作内存</td><td>把从执行引擎接收的值赋给工作内存变量</td></tr><tr><td>store</td><td>工作内存</td><td>把工作内存的变量值传到主内存</td></tr><tr><td>write</td><td>主内存</td><td>把 store 取到的变量值放入主内存变量中</td></tr></tbody></table><hr><h4 id="Q2：as-if-serial-是什么？"><a href="#Q2：as-if-serial-是什么？" class="headerlink" title="Q2：as-if-serial 是什么？"></a>Q2：as-if-serial 是什么？</h4><p>不管怎么重<a href>排序</a>，单线程程序的执行结果不能改变，编译器和处理器必须遵循 as-if-serial 语义。</p><p>为了遵循 as-if-serial，编译器和处理器不会对存在数据依赖关系的操作重<a href>排序</a>，因为这种重<a href>排序</a>会改变执行结果。但是如果操作之间不存在数据依赖关系，这些操作就可能被编译器和处理器重<a href>排序</a>。</p><p>as-if-serial 把单线程程序保护起来，给程序员一种幻觉：单线程程序是按程序的顺序执行的。</p><hr><h4 id="Q3：happens-before-是什么？"><a href="#Q3：happens-before-是什么？" class="headerlink" title="Q3：happens-before 是什么？"></a>Q3：happens-before 是什么？</h4><p>先行发生原则，JMM 定义的两项操作间的偏序关系，是判断数据是否存在竞争的重要手段。</p><p>JMM 将 happens-before 要求禁止的重<a href>排序</a>按是否会改变程序执行结果分为两类。对于会改变结果的重<a href>排序</a> JMM 要求编译器和处理器必须禁止，对于不会改变结果的重<a href>排序</a>，JMM 不做要求。 </p><p>JMM 存在一些天然的 happens-before 关系，无需任何同步器协助就已经存在。如果两个操作的关系不在此列，并且无法从这些规则推导出来，它们就没有顺序性保障，虚拟机可以对它们随意进行重<a href>排序</a>。</p><ul><li><strong>程序次序规则：</strong>一个线程内写在前面的操作先行发生于后面的。 </li><li><strong>管程锁定规则：</strong> unlock 操作先行发生于后面对同一个锁的 lock 操作。 </li><li><strong>volatile 规则：</strong>对 volatile 变量的写操作先行发生于后面的读操作。 </li><li><strong>线程启动规则：</strong>线程的 <code>start</code> 方法先行发生于线程的每个动作。 </li><li><strong>线程终止规则：</strong>线程中所有操作先行发生于对线程的终止检测。 </li><li><strong>对象终结规则：</strong>对象的初始化先行发生于 <code>finalize</code> 方法。 </li><li><strong>传递性：</strong>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C 。</li></ul><hr><h4 id="Q4：as-if-serial-和-happens-before-有什么区别？"><a href="#Q4：as-if-serial-和-happens-before-有什么区别？" class="headerlink" title="Q4：as-if-serial 和 happens-before 有什么区别？"></a>Q4：as-if-serial 和 happens-before 有什么区别？</h4><p>as-if-serial 保证单线程程序的执行结果不变，happens-before 保证正确同步的多线程程序的执行结果不变。</p><p>这两种语义的目的都是为了在不改变程序执行结果的前提下尽可能提高程序执行并行度。</p><hr><h4 id="Q5：什么是指令重排序？"><a href="#Q5：什么是指令重排序？" class="headerlink" title="Q5：什么是指令重排序？"></a>Q5：什么是指令重<a href>排序</a>？</h4><p>为了提高性能，编译器和处理器通常会对指令进行重<a href>排序</a>，重<a href>排序</a>指从源代码到指令序列的重<a href>排序</a>，分为三种：① 编译器优化的重<a href>排序</a>，编译器在不改变单线程程序语义的前提下可以重排语句的执行顺序。② 指令级并行的重<a href>排序</a>，如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。③ 内存系统的重<a href>排序</a>。</p><hr><h4 id="Q6：原子性、可见性、有序性分别是什么？"><a href="#Q6：原子性、可见性、有序性分别是什么？" class="headerlink" title="Q6：原子性、可见性、有序性分别是什么？"></a>Q6：原子性、可见性、有序性分别是什么？</h4><p><strong>原子性</strong></p><p>基本数据类型的访问都具备原子性，例外就是 long 和 double，虚拟机将没有被 volatile 修饰的 64 位数据操作划分为两次 32 位操作。</p><p>如果应用场景需要更大范围的原子性保证，JMM 还提供了 lock 和 unlock 操作满足需求，尽管 JVM 没有把这两种操作直接开放给用户使用，但是提供了更高层次的字节码指令 monitorenter 和 monitorexit，这两个字节码指令反映到 Java 代码中就是 synchronized。</p><p><strong>可见性</strong></p><p>可见性指当一个线程修改了共享变量时，其他线程能够立即得知修改。JMM 通过在变量修改后将值同步回主内存，在变量读取前从主内存刷新的方式实现可见性，无论普通变量还是 volatile 变量都是如此，区别是 volatile 保证新值能立即同步到主内存以及每次使用前立即从主内存刷新。</p><p>除了 volatile 外，synchronized 和 final 也可以保证可见性。同步块可见性由”对一个变量执行 unlock 前必须先把此变量同步回主内存，即先执行 store 和 write”这条规则获得。final 的可见性指：被 final 修饰的字段在构造方法中一旦初始化完成，并且构造方法没有把 this 引用传递出去，那么其他线程就能看到 final 字段的值。</p><p><strong>有序性</strong></p><p>有序性可以总结为：在本线程内观察所有操作是有序的，在一个线程内观察另一个线程，所有操作都是无序的。前半句指 as-if-serial 语义，后半句指指令重<a href>排序</a>和工作内存与主内存延迟现象。</p><p>Java 提供 volatile 和 synchronized 保证有序性，volatile 本身就包含禁止指令重<a href>排序</a>的语义，而 synchronized 保证一个变量在同一时刻只允许一条线程对其进行 lock 操作，确保持有同一个锁的两个同步块只能串行进入。</p><hr><h4 id="Q7：谈一谈-volatile"><a href="#Q7：谈一谈-volatile" class="headerlink" title="Q7：谈一谈 volatile"></a>Q7：谈一谈 volatile</h4><p>JMM 为 volatile 定义了一些特殊访问规则，当变量被定义为 volatile 后具备两种特性：</p><ul><li><p><strong>保证变量对所有线程可见</strong></p><p>当一条线程修改了变量值，新值对于其他线程来说是立即可以得知的。volatile 变量在各个线程的工作内存中不存在一致性问题，但 Java 的运算操作符并非原子操作，导致 volatile 变量运算在并发下仍不安全。</p></li><li><p><strong>禁止指令重<a href>排序</a>优化</strong></p><p>使用 volatile 变量进行写操作，汇编指令带有 lock 前缀，相当于一个内存屏障，后面的指令不能重排到内存屏障之前。</p><p>使用 lock 前缀引发两件事：① 将当前处理器缓存行的数据写回系统内存。②使其他处理器的缓存无效。相当于对缓存变量做了一次 store 和 write 操作，让 volatile 变量的修改对其他处理器立即可见。</p></li></ul><p><strong>静态变量 i 执行多线程 i++ 的不安全问题</strong></p><p>自增语句由 4 条字节码指令构成的，依次为 <code>getstatic</code>、<code>iconst_1</code>、<code>iadd</code>、<code>putstatic</code>，当 <code>getstatic</code> 把 i 的值取到操作栈顶时，volatile 保证了 i 值在此刻正确，但在执行 <code>iconst_1</code>、<code>iadd</code> 时，其他线程可能已经改变了 i 值，操作栈顶的值就变成了过期数据，所以 <code>putstatic</code> 执行后就可能把较小的 i 值同步回了主内存。 </p><p><strong>适用场景</strong></p><p>① 运算结果并不依赖变量的当前值。② 一写多读，只有单一的线程修改变量值。</p><p><strong>内存语义</strong></p><p>写一个 volatile 变量时，把该线程工作内存中的值刷新到主内存。</p><p>读一个 volatile 变量时，把该线程工作内存值置为无效，从主内存读取。</p><p><strong>指令重<a href>排序</a>特点</strong></p><p>第二个操作是 volatile 写，不管第一个操作是什么都不能重<a href>排序</a>，确保写之前的操作不会被重<a href>排序</a>到写之后。</p><p>第一个操作是 volatile 读，不管第二个操作是什么都不能重<a href>排序</a>，确保读之后的操作不会被重<a href>排序</a>到读之前。</p><p>第一个操作是 volatile 写，第二个操作是 volatile 读不能重<a href>排序</a>。</p><p><strong>JSR-133 增强 volatile 语义的原因</strong></p><p>在旧的内存模型中，虽然不允许 volatile 变量间重<a href>排序</a>，但允许 volatile 变量与普通变量重<a href>排序</a>，可能导致内存不可见问题。JSR-133 严格限制编译器和处理器对 volatile 变量与普通变量的重<a href>排序</a>，确保 volatile 的写-读和锁的释放-获取具有相同的内存语义。</p><hr><h4 id="Q8：final-可以保证可见性吗？"><a href="#Q8：final-可以保证可见性吗？" class="headerlink" title="Q8：final 可以保证可见性吗？"></a>Q8：final 可以保证可见性吗？</h4><p>final 可以保证可见性，被 final 修饰的字段在构造方法中一旦被初始化完成，并且构造方法没有把 this 引用传递出去，在其他线程中就能看见 final 字段值。</p><p>在旧的 JMM 中，一个严重缺陷是线程可能看到 final 值改变。比如一个线程看到一个 int 类型 final 值为 0，此时该值是未初始化前的零值，一段时间后该值被某线程初始化，再去读这个 final 值会发现值变为 1。</p><p>为修复该漏洞，JSR-133 为 final 域增加重<a href>排序</a>规则：只要对象是正确构造的（被构造对象的引用在构造方法中没有逸出），那么不需要使用同步就可以保证任意线程都能看到这个 final 域初始化后的值。</p><p><strong>写 final 域重<a href>排序</a>规则</strong></p><p>禁止把 final 域的写重<a href>排序</a>到构造方法之外，编译器会在 final 域的写后，构造方法的 return 前，插入一个 Store Store 屏障。确保在对象引用为任意线程可见之前，对象的 final 域已经初始化过。</p><p><strong>读 final 域重<a href>排序</a>规则</strong></p><p>在一个线程中，初次读对象引用和初次读该对象包含的 final 域，JMM 禁止处理器重<a href>排序</a>这两个操作。编译器在读 final 域操作的前面插入一个 Load Load 屏障，确保在读一个对象的 final 域前一定会先读包含这个 final 域的对象引用。</p><hr><h3 id="锁-17"><a href="#锁-17" class="headerlink" title="锁 17"></a>锁 17</h3><h4 id="Q1：谈一谈-synchronized"><a href="#Q1：谈一谈-synchronized" class="headerlink" title="Q1：谈一谈 synchronized"></a>Q1：谈一谈 synchronized</h4><p>每个 Java 对象都有一个关联的 monitor，使用 synchronized 时 JVM 会根据使用环境找到对象的 monitor，根据 monitor 的状态进行加解锁的判断。如果成功加锁就成为该 monitor 的唯一持有者，monitor 在被释放前不能再被其他线程获取。</p><p>同步代码块使用 monitorenter 和 monitorexit 这两个字节码指令获取和释放 monitor。这两个字节码指令都需要一个引用类型的参数指明要锁定和解锁的对象，对于同步普通方法，锁是当前实例对象；对于静态同步方法，锁是当前类的 Class 对象；对于同步方法块，锁是 synchronized 括号里的对象。</p><p>执行 monitorenter 指令时，首先尝试获取对象锁。如果这个对象没有被锁定，或当前线程已经持有锁，就把锁的计数器加 1，执行 monitorexit 指令时会将锁计数器减 1。一旦计数器为 0 锁随即就被释放。</p><p>例如有两个线程 A、B 竞争 monitor，当 A 竞争到锁时会将 monitor 中的 owner 设置为 A，把 B 阻塞并放到等待资源的 ContentionList 队列。ContentionList 中的部分线程会进入 EntryList，EntryList 中的线程会被指定为 OnDeck 竞争候选者，如果获得了锁资源将进入 Owner 状态，释放锁后进入 !Owner 状态。被阻塞的线程会进入 WaitSet。</p><p>被 synchronized 修饰的同步块对一条线程来说是可重入的，并且同步块在持有锁的线程释放锁前会阻塞其他线程进入。从执行成本的角度看，持有锁是一个重量级的操作。Java 线程是映射到操作系统的内核线程上的，如果要阻塞或唤醒一条线程，需要操作系统帮忙完成，不可避免用户态到核心态的转换。</p><p><strong>不公平的原因</strong></p><p>所有收到锁请求的线程首先自旋，如果通过自旋也没有获取锁将被放入 ContentionList，该做法对于已经进入队列的线程不公平。</p><p>为了防止 ContentionList 尾部的元素被大量线程进行 CAS 访问影响性能，Owner 线程会在释放锁时将 ContentionList 的部分线程移动到 EntryList 并指定某个线程为 OnDeck 线程，该行为叫做竞争切换，牺牲了公平性但提高了性能。</p><hr><h4 id="Q2：锁优化有哪些策略？"><a href="#Q2：锁优化有哪些策略？" class="headerlink" title="Q2：锁优化有哪些策略？"></a>Q2：锁优化有哪些策略？</h4><p>JDK 6 对 synchronized 做了很多优化，引入了自适应自旋、锁消除、锁粗化、偏向锁和轻量级锁等提高锁的效率，锁一共有 4 个状态，级别从低到高依次是：无锁、偏向锁、轻量级锁和重量级锁，状态会随竞争情况升级。锁可以升级但不能降级，这种只能升级不能降级的锁策略是为了提高锁获得和释放的效率。</p><hr><h4 id="Q3：自旋锁是什么？"><a href="#Q3：自旋锁是什么？" class="headerlink" title="Q3：自旋锁是什么？"></a>Q3：自旋锁是什么？</h4><p>同步对性能最大的影响是阻塞，挂起和恢复线程的操作都需要转入内核态完成。许多应用上共享数据的锁定只会持续很短的时间，为了这段时间去挂起和恢复线程并不值得。如果机器有多个处理器核心，我们可以让后面请求锁的线程稍等一会，但不放弃处理器的执行时间，看看持有锁的线程是否很快会释放锁。为了让线程等待只需让线程执行一个忙循环，这项技术就是自旋锁。</p><p>自旋锁在 JDK1.4 就已引入，默认关闭，在 JDK6 中改为默认开启。自旋不能代替阻塞，虽然避免了线程切换开销，但要占用处理器时间，如果锁被占用的时间很短，自旋的效果就会非常好，反之只会白白消耗处理器资源。如果自旋超过了限定的次数仍然没有成功获得锁，就应挂起线程，自旋默认限定次数是 10。</p><hr><h4 id="Q4：什么是自适应自旋？"><a href="#Q4：什么是自适应自旋？" class="headerlink" title="Q4：什么是自适应自旋？"></a>Q4：什么是自适应自旋？</h4><p>JDK6 对自旋锁进行了优化，自旋时间不再固定，而是由前一次的自旋时间及锁拥有者的状态决定。</p><p>如果在同一个锁上，自旋刚刚成功获得过锁且持有锁的线程正在运行，虚拟机会认为这次自旋也很可能成功，进而允许自旋持续更久。如果自旋很少成功，以后获取锁时将可能直接省略掉自旋，避免浪费处理器资源。</p><p>有了自适应自旋，随着程序运行时间的增长，虚拟机对程序锁的状况预测就会越来越精准。</p><hr><h4 id="Q5：锁消除是什么？"><a href="#Q5：锁消除是什么？" class="headerlink" title="Q5：锁消除是什么？"></a>Q5：锁消除是什么？</h4><p>锁消除指即时编译器对检测到不可能存在共享数据竞争的锁进行消除。</p><p>主要判定依据来源于逃逸分析，如果判断一段代码中堆上的所有数据都只被一个线程访问，就可以当作栈上的数据对待，认为它们是线程私有的而无须同步。</p><hr><h4 id="Q6：锁粗化是什么？"><a href="#Q6：锁粗化是什么？" class="headerlink" title="Q6：锁粗化是什么？"></a>Q6：锁粗化是什么？</h4><p>原则需要将同步块的作用范围限制得尽量小，只在共享数据的实际作用域中进行同步，这是为了使等待锁的线程尽快拿到锁。</p><p>但如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之外的，即使没有线程竞争也会导致不必要的性能消耗。因此如果虚拟机探测到有一串零碎的操作都对同一个对象加锁，将会把同步的范围扩展到整个操作序列的外部。</p><hr><h4 id="Q7：偏向锁是什么？"><a href="#Q7：偏向锁是什么？" class="headerlink" title="Q7：偏向锁是什么？"></a>Q7：偏向锁是什么？</h4><p>偏向锁是为了在没有竞争的情况下减少锁开销，锁会偏向于第一个获得它的线程，如果在执行过程中锁一直没有被其他线程获取，则持有偏向锁的线程将不需要进行同步。</p><p>当锁对象第一次被线程获取时，虚拟机会将对象头中的偏向模式设为 1，同时使用 CAS 把获取到锁的线程 ID 记录在对象的 Mark Word 中。如果 CAS 成功，持有偏向锁的线程以后每次进入锁相关的同步块都不再进行任何同步操作。</p><p>一旦有其他线程尝试获取锁，偏向模式立即结束，根据锁对象是否处于锁定状态决定是否撤销偏向，后续同步按照轻量级锁那样执行。</p><hr><h4 id="Q8：轻量级锁是什么？"><a href="#Q8：轻量级锁是什么？" class="headerlink" title="Q8：轻量级锁是什么？"></a>Q8：轻量级锁是什么？</h4><p>轻量级锁是为了在没有竞争的前提下减少重量级锁使用操作系统互斥量产生的性能消耗。</p><p>在代码即将进入同步块时，如果同步对象没有被锁定，虚拟机将在当前线程的栈帧中建立一个锁记录空间，存储锁对象目前 Mark Word 的拷贝。然后虚拟机使用 CAS 尝试把对象的 Mark Word 更新为指向锁记录的指针，如果更新成功即代表该线程拥有了锁，锁标志位将转变为 00，表示处于轻量级锁定状态。</p><p>如果更新失败就意味着至少存在一条线程与当前线程竞争。虚拟机检查对象的 Mark Word 是否指向当前线程的栈帧，如果是则说明当前线程已经拥有了锁，直接进入同步块继续执行，否则说明锁对象已经被其他线程抢占。如果出现两条以上线程争用同一个锁，轻量级锁就不再有效，将膨胀为重量级锁，锁标志状态变为 10，此时Mark Word 存储的就是指向重量级锁的指针，后面等待锁的线程也必须阻塞。</p><p>解锁同样通过 CAS 进行，如果对象 Mark Word 仍然指向线程的锁记录，就用 CAS 把对象当前的 Mark Word 和线程复制的 Mark Word 替换回来。假如替换成功同步过程就顺利完成了，如果失败则说明有其他线程尝试过获取该锁，就要在释放锁的同时唤醒被挂起的线程。</p><hr><h4 id="Q9：偏向锁、轻量级锁和重量级锁的区别？"><a href="#Q9：偏向锁、轻量级锁和重量级锁的区别？" class="headerlink" title="Q9：偏向锁、轻量级锁和重量级锁的区别？"></a>Q9：偏向锁、轻量级锁和重量级锁的区别？</h4><p>偏向锁的优点是加解锁不需要额外消耗，和执行非同步方法比仅存在纳秒级差距，缺点是如果存在锁竞争会带来额外锁撤销的消耗，适用只有一个线程访问同步代码块的场景。</p><p>轻量级锁的优点是竞争线程不阻塞，程序响应速度快，缺点是如果线程始终得不到锁会自旋消耗 CPU，适用追求响应时间、同步代码块执行快的场景。</p><p>重量级锁的优点是线程竞争不使用自旋不消耗CPU，缺点是线程会阻塞，响应时间慢，适应追求吞吐量、同步代码块执行慢的场景。</p><hr><h4 id="Q10：Lock-和-synchronized-有什么区别？"><a href="#Q10：Lock-和-synchronized-有什么区别？" class="headerlink" title="Q10：Lock 和 synchronized 有什么区别？"></a>Q10：Lock 和 synchronized 有什么区别？</h4><p>Lock 接是 juc 包的顶层接口，基于Lock 接口，用户能够以非块结构来实现互斥同步，摆脱了语言特性束缚，在类库层面实现同步。Lock 并未用到 synchronized，而是利用了 volatile 的可见性。</p><p>重入锁 ReentrantLock 是 Lock 最常见的实现，与 synchronized 一样可重入，不过它增加了一些高级功能：</p><ul><li>**等待可中断： **持有锁的线程长期不释放锁时，正在等待的线程可以选择放弃等待而处理其他事情。 </li><li><strong>公平锁：</strong> 公平锁指多个线程在等待同一个锁时，必须按照申请锁的顺序来依次获得锁，而非公平锁不保证这一点，在锁被释放时，任何线程都有机会获得锁。synchronized 是非公平的，ReentrantLock 在默认情况下是非公平的，可以通过构造方法指定公平锁。一旦使用了公平锁，性能会急剧下降，影响吞吐量。 </li><li><strong>锁绑定多个条件：</strong> 一个 ReentrantLock 可以同时绑定多个 Condition。synchronized 中锁对象的 <code>wait</code> 跟 <code>notify</code> 可以实现一个隐含条件，如果要和多个条件关联就不得不额外添加锁，而 ReentrantLock 可以多次调用 <code>newCondition</code> 创建多个条件。</li></ul><p>一般优先考虑使用 synchronized：① synchronized 是语法层面的同步，足够简单。② Lock 必须确保在 finally 中释放锁，否则一旦抛出异常有可能永远不会释放锁。使用 synchronized 可以由 JVM 来确保即使出现异常锁也能正常释放。③ 尽管 JDK5 时 ReentrantLock 的性能优于 synchronized，但在 JDK6 进行锁优化后二者的性能基本持平。从长远来看 JVM 更容易针对synchronized 优化，因为 JVM 可以在线程和对象的元数据中记录 synchronized 中锁的相关信息，而使用 Lock 的话 JVM 很难得知具体哪些锁对象是由特定线程持有的。</p><hr><h4 id="Q11：ReentrantLock-的可重入是怎么实现的？"><a href="#Q11：ReentrantLock-的可重入是怎么实现的？" class="headerlink" title="Q11：ReentrantLock 的可重入是怎么实现的？"></a>Q11：ReentrantLock 的可重入是怎么实现的？</h4><p>以非公平锁为例，通过 <code>nonfairTryAcquire</code> 方法获取锁，该方法增加了再次获取同步状态的处理逻辑：判断当前线程是否为获取锁的线程来决定获取是否成功，如果是获取锁的线程再次请求则将同步状态值增加并返回 true，表示获取同步状态成功。</p><p>成功获取锁的线程再次获取锁将增加同步状态值，释放同步状态时将减少同步状态值。如果锁被获取了 n 次，那么前 n-1 次 <code>tryRelease</code> 方法必须都返回 fasle，只有同步状态完全释放才能返回 true，该方法将同步状态是否为 0 作为最终释放条件，释放时将占有线程设置为null 并返回 true。</p><p>对于非公平锁只要 CAS 设置同步状态成功则表示当前线程获取了锁，而公平锁则不同。公平锁使用 <code>tryAcquire</code> 方法，该方法与<code>nonfairTryAcquire</code> 的唯一区别就是判断条件中多了对同步队列中当前节点是否有前驱节点的判断，如果该方法返回 true 表示有线程比当前线程更早请求锁，因此需要等待前驱线程获取并释放锁后才能获取锁。</p><hr><h4 id="Q12：什么是读写锁？"><a href="#Q12：什么是读写锁？" class="headerlink" title="Q12：什么是读写锁？"></a>Q12：什么是读写锁？</h4><p>ReentrantLock 是排他锁，同一时刻只允许一个线程访问，读写锁在同一时刻允许多个读线程访问，在写线程访问时，所有的读写线程均阻塞。读写锁维护了一个读锁和一个写锁，通过分离读写锁使并发性相比排他锁有了很大提升。</p><p>读写锁依赖 AQS 来实现同步功能，读写状态就是其同步器的同步状态。读写锁的自定义同步器需要在同步状态，即一个 int 变量上维护多个读线程和一个写线程的状态。读写锁将变量切分成了两个部分，高 16 位表示读，低 16 位表示写。</p><p>写锁是可重入排他锁，如果当前线程已经获得了写锁则增加写状态，如果当前线程在获取写锁时，读锁已经被获取或者该线程不是已经获得写锁的线程则进入等待。写锁的释放与 ReentrantLock 的释放类似，每次释放减少写状态，当写状态为 0 时表示写锁已被释放。</p><p>读锁是可重入共享锁，能够被多个线程同时获取，在没有其他写线程访问时，读锁总会被成功获取。如果当前线程已经获取了读锁，则增加读状态。如果当前线程在获取读锁时，写锁已被其他线程获取则进入等待。读锁每次释放会减少读状态，减少的值是（1&lt;&lt;16），读锁的释放是线程安全的。</p><p><strong>锁降级</strong>指把持住当前拥有的写锁，再获取读锁，随后释放先前拥有的写锁。</p><p>锁降级中读锁的获取是必要的，这是为了保证数据可见性，如果当前线程不获取读锁而直接释放写锁，假设此刻另一个线程 A 获取写锁修改了数据，当前线程无法感知线程 A 的数据更新。如果当前线程获取读锁，遵循锁降级的步骤，A 将被阻塞，直到当前线程使用数据并释放读锁之后，线程 A 才能获取写锁进行数据更新。</p><hr><h4 id="Q13：AQS-了解吗？"><a href="#Q13：AQS-了解吗？" class="headerlink" title="Q13：AQS 了解吗？"></a>Q13：AQS 了解吗？</h4><p>AQS 队列同步器是用来构建锁或其他同步组件的基础框架，它使用一个 volatile int state 变量作为共享资源，如果线程获取资源失败，则进入同步队列等待；如果获取成功就执行临界区代码，释放资源时会通知同步队列中的等待线程。</p><p>同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，对同步状态进行更改需要使用同步器提供的 3个方法 <code>getState</code>、<code>setState</code> 和 <code>compareAndSetState</code> ，它们保证状态改变是安全的。子类推荐被定义为自定义同步组件的静态内部类，同步器自身没有实现任何同步接口，它仅仅定义若干同步状态获取和释放的方法，同步器既支持独占式也支持共享式。</p><p>同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。锁面向使用者，定义了使用者与锁交互的接口，隐藏实现细节；同步器面向锁的实现者，简化了锁的实现方式，屏蔽了同步状态管理、线程排队、等待与唤醒等底层操作。</p><p>每当有新线程请求资源时都会进入一个等待队列，只有当持有锁的线程释放锁资源后该线程才能持有资源。等待队列通过双向<a href>链表</a>实现，线程被封装在<a href>链表</a>的 Node 节点中，Node 的等待状态包括：CANCELLED（线程已取消）、SIGNAL（线程需要唤醒）、CONDITION （线程正在等待）、PROPAGATE（后继节点会传播唤醒操作，只在共享模式下起作用）。</p><hr><h4 id="Q14：AQS-有哪两种模式？"><a href="#Q14：AQS-有哪两种模式？" class="headerlink" title="Q14：AQS 有哪两种模式？"></a>Q14：AQS 有哪两种模式？</h4><p><strong>独占模式</strong>表示锁只会被一个线程占用，其他线程必须等到持有锁的线程释放锁后才能获取锁，同一时间只能有一个线程获取到锁。</p><p><strong>共享模式</strong>表示多个线程获取同一个锁有可能成功，ReadLock 就采用共享模式。</p><p>独占模式通过 acquire 和 release 方法获取和释放锁，共享模式通过 acquireShared 和 releaseShared 方法获取和释放锁。</p><hr><h4 id="Q15：AQS-独占式获取-x2F-释放锁的原理？"><a href="#Q15：AQS-独占式获取-x2F-释放锁的原理？" class="headerlink" title="Q15：AQS 独占式获取&#x2F;释放锁的原理？"></a>Q15：AQS 独占式获取&#x2F;释放锁的原理？</h4><p>获取同步状态时，调用 <code>acquire</code> 方法，维护一个同步队列，使用 <code>tryAcquire</code> 方法安全地获取线程同步状态，获取失败的线程会被构造同步节点并通过 <code>addWaiter</code> 方法加入到同步队列的尾部，在队列中自旋。之后调用 <code>acquireQueued</code> 方法使得该节点以死循环的方式获取同步状态，如果获取不到则阻塞，被阻塞线程的唤醒主要依靠前驱节点的出队或被中断实现，移出队列或停止自旋的条件是前驱节点是头结点且成功获取了同步状态。</p><p>释放同步状态时，同步器调用 <code>tryRelease</code> 方法释放同步状态，然后调用 <code>unparkSuccessor</code> 方法唤醒头节点的后继节点，使后继节点重新尝试获取同步状态。</p><hr><h4 id="Q16：为什么只有前驱节点是头节点时才能尝试获取同步状态？"><a href="#Q16：为什么只有前驱节点是头节点时才能尝试获取同步状态？" class="headerlink" title="Q16：为什么只有前驱节点是头节点时才能尝试获取同步状态？"></a>Q16：为什么只有前驱节点是头节点时才能尝试获取同步状态？</h4><p>头节点是成功获取到同步状态的节点，后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点。</p><p>目的是维护同步队列的 FIFO 原则，节点和节点在循环检查的过程中基本不通信，而是简单判断自己的前驱是否为头节点，这样就使节点的释放规则符合 FIFO，并且也便于对过早通知的处理，过早通知指前驱节点不是头节点的线程由于中断被唤醒。</p><hr><h4 id="Q17：AQS-共享式式获取-x2F-释放锁的原理？"><a href="#Q17：AQS-共享式式获取-x2F-释放锁的原理？" class="headerlink" title="Q17：AQS 共享式式获取&#x2F;释放锁的原理？"></a>Q17：AQS 共享式式获取&#x2F;释放锁的原理？</h4><p>获取同步状态时，调用 <code>acquireShared</code> 方法，该方法调用 <code>tryAcquireShared</code> 方法尝试获取同步状态，返回值为 int 类型，返回值不小于于 0 表示能获取同步状态。因此在共享式获取锁的自旋过程中，成功获取同步状态并退出自旋的条件就是该方法的返回值不小于0。</p><p>释放同步状态时，调用 <code>releaseShared</code> 方法，释放后会唤醒后续处于等待状态的节点。它和独占式的区别在于 <code>tryReleaseShared</code> 方法必须确保同步状态安全释放，通过循环 CAS 保证，因为释放同步状态的操作会同时来自多个线程。</p><hr><h3 id="线程-13"><a href="#线程-13" class="headerlink" title="线程 13"></a>线程 13</h3><p>作者：是瑶瑶公主吖<br>链接：<a href="https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post">https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post</a><br>来源：牛客网</p><h4 id="Q1：线程的生命周期有哪些状态？"><a href="#Q1：线程的生命周期有哪些状态？" class="headerlink" title="Q1：线程的生命周期有哪些状态？"></a>Q1：线程的生命周期有哪些状态？</h4><p>NEW：新建状态，线程被创建且未启动，此时还未调用 <code>start</code> 方法。</p><p>RUNNABLE：Java 将操作系统中的就绪和运行两种状态统称为 RUNNABLE，此时线程有可能在等待时间片，也有可能在执行。</p><p>BLOCKED：阻塞状态，可能由于锁被其他线程占用、调用了 <code>sleep</code> 或 <code>join</code> 方法、执行了 <code>wait</code>方法等。</p><p>WAITING：等待状态，该状态线程不会被分配 CPU 时间片，需要其他线程通知或中断。可能由于调用了无参的 <code>wait</code> 和 <code>join</code> 方法。</p><p>TIME_WAITING：限期等待状态，可以在指定时间内自行返回。导可能由于调用了带参的 <code>wait</code> 和 <code>join</code> 方法。</p><p>TERMINATED：终止状态，表示当前线程已执行完毕或异常退出。</p><hr><h4 id="Q2：线程的创建方式有哪些？"><a href="#Q2：线程的创建方式有哪些？" class="headerlink" title="Q2：线程的创建方式有哪些？"></a>Q2：线程的创建方式有哪些？</h4><p>① 继承 Thread 类并重写 run 方法。实现简单，但不符合里氏替换原则，不可以继承其他类。</p><p>② 实现 Runnable 接口并重写 run 方法。避免了单继承局限性，编程更加灵活，实现解耦。</p><p>③实现 Callable 接口并重写 call 方法。可以获取线程执行结果的返回值，并且可以抛出异常。</p><hr><h4 id="Q3：线程有哪些方法？"><a href="#Q3：线程有哪些方法？" class="headerlink" title="Q3：线程有哪些方法？"></a>Q3：线程有哪些方法？</h4><p>① <code>sleep</code> 方***导致当前线程进入休眠状态，与 <code>wait</code> 不同的是该方法不会释放锁资源，进入的是 TIMED-WAITING 状态。</p><p>② <code>yiled</code> 方法使当前线程让出 CPU 时间片给优先级相同或更高的线程，回到 RUNNABLE 状态，与其他线程一起重新竞争CPU时间片。</p><p>③ <code>join</code> 方法用于等待其他线程运行终止，如果当前线程调用了另一个线程的 join 方法，则当前线程进入阻塞状态，当另一个线程结束时当前线程才能从阻塞状态转为就绪态，等待获取CPU时间片。底层使用的是wait，也会释放锁。</p><hr><h4 id="Q4：什么是守护线程？"><a href="#Q4：什么是守护线程？" class="headerlink" title="Q4：什么是守护线程？"></a>Q4：什么是守护线程？</h4><p>守护线程是一种支持型线程，可以通过 <code>setDaemon(true)</code> 将线程设置为守护线程，但必须在线程启动前设置。</p><p>守护线程被用于完成支持性工作，但在 JVM 退出时守护线程中的 finally 块不一定执行，因为 JVM 中没有非守护线程时需要立即退出，所有守护线程都将立即终止，不能靠在守护线程使用 finally 确保关闭资源。</p><hr><h4 id="Q5：线程通信的方式有哪些？"><a href="#Q5：线程通信的方式有哪些？" class="headerlink" title="Q5：线程通信的方式有哪些？"></a>Q5：线程通信的方式有哪些？</h4><p>命令式编程中线程的通信机制有两种，共享内存和消息传递。在共享内存的并发模型里线程间共享程序的公共状态，通过写-读内存中的公共状态进行隐式通信。在消息传递的并发模型里线程间没有公共状态，必须通过发送消息来显式通信。Java 并发采用共享内存模型，线程之间的通信总是隐式进行，整个通信过程对程序员完全透明。</p><p><strong>volatile</strong> 告知程序任何对变量的读需要从主内存中获取，写必须同步刷新回主内存，保证所有线程对变量访问的可见性。</p><p><strong>synchronized</strong> 确保多个线程在同一时刻只能有一个处于方法或同步块中，保证线程对变量访问的原子性、可见性和有序性。</p><p><strong>等待通知机制</strong>指一个线程 A 调用了对象的 <code>wait</code> 方法进入等待状态，另一线程 B 调用了对象的 <code>notify/notifyAll</code> 方法，线程 A 收到通知后结束阻塞并执行后序操作。对象上的 <code>wait</code> 和 <code>notify/notifyAll</code> 如同开关信号，完成等待方和通知方的交互。</p><p>如果一个线程执行了某个线程的 <code>join</code> 方法，这个线程就会阻塞等待执行了 <code>join</code> 方法的线程终止，这里涉及等待&#x2F;通知机制。<code>join</code> 底层通过 <code>wait</code> 实现，线程终止时会调用自身的 <code>notifyAll</code> 方法，通知所有等待在该线程对象上的线程。</p><p><strong>管道 IO 流</strong>用于线程间数据传输，媒介为内存。PipedOutputStream 和 PipedWriter 是输出流，相当于生产者，PipedInputStream 和 PipedReader 是输入流，相当于消费者。管道流使用一个默认大小为 1KB 的循环缓冲数组。输入流从缓冲数组读数据，输出流往缓冲数组中写数据。当数组已满时，输出流所在线程阻塞；当数组首次为空时，输入流所在线程阻塞。</p><p><strong>ThreadLocal</strong> 是线程共享变量，但它可以为每个线程创建单独的副本，副本值是线程私有的，互相之间不影响。</p><hr><h4 id="Q6：线程池有什么好处？"><a href="#Q6：线程池有什么好处？" class="headerlink" title="Q6：线程池有什么好处？"></a>Q6：线程池有什么好处？</h4><p>降低资源消耗，复用已创建的线程，降低开销、控制最大并发数。</p><p>隔离线程环境，可以配置独立线程池，将较慢的线程与较快的隔离开，避免相互影响。</p><p>实现任务线程队列缓冲策略和拒绝机制。</p><p>实现某些与时间相关的功能，如定时执行、周期执行等。</p><hr><h4 id="Q7：线程池处理任务的流程？"><a href="#Q7：线程池处理任务的流程？" class="headerlink" title="Q7：线程池处理任务的流程？"></a>Q7：线程池处理任务的流程？</h4><p>① 核心线程池未满，创建一个新的线程执行任务，此时 workCount &lt; corePoolSize。</p><p>② 如果核心线程池已满，工作队列未满，将线程存储在工作队列，此时 workCount &gt;&#x3D; corePoolSize。</p><p>③ 如果工作队列已满，线程数小于最大线程数就创建一个新线程处理任务，此时 workCount &lt; maximumPoolSize，这一步也需要获取全局锁。</p><p>④ 如果超过大小线程数，按照拒绝策略来处理任务，此时 workCount &gt; maximumPoolSize。</p><p>线程池创建线程时，会将线程封装成工作线程 Worker，Worker 在执行完任务后还会循环获取工作队列中的任务来执行。</p><hr><h4 id="Q8：有哪些创建线程池的方法？"><a href="#Q8：有哪些创建线程池的方法？" class="headerlink" title="Q8：有哪些创建线程池的方法？"></a>Q8：有哪些创建线程池的方法？</h4><p>可以通过 Executors 的静态工厂方法创建线程池：</p><p>① <code>newFixedThreadPool</code>，固定大小的线程池，核心线程数也是最大线程数，不存在空闲线程，<a href>keep</a>AliveTime &#x3D; 0。该线程池使用的工作队列是无界阻塞队列 LinkedBlockingQueue，适用于负载较重的服务器。</p><p>② <code>newSingleThreadExecutor</code>，使用单线程，相当于单线程串行执行所有任务，适用于需要保证顺序执行任务的场景。</p><p>③ <code>newCachedThreadPool</code>，maximumPoolSize 设置为 Integer 最大值，是高度可伸缩的线程池。该线程池使用的工作队列是没有容量的 SynchronousQueue，如果主线程提交任务的速度高于线程处理的速度，线程池会不断创建新线程，极端情况下会创建过多线程而耗尽CPU 和内存资源。适用于执行很多短期异步任务的小程序或负载较轻的服务器。</p><p>④ <code>newScheduledThreadPool</code>：线程数最大为 Integer 最大值，存在 OOM 风险。支持定期及周期性任务执行，适用需要多个后台线程执行周期任务，同时需要限制线程数量的场景。相比 Timer 更安全，功能更强，与 <code>newCachedThreadPool</code> 的区别是不回收工作线程。</p><p>⑤ <code>newWorkStealingPool</code>：JDK8 引入，创建持有足够线程的线程池支持给定的并行度，通过多个队列减少竞争。</p><hr><h4 id="Q9：创建线程池有哪些参数？"><a href="#Q9：创建线程池有哪些参数？" class="headerlink" title="Q9：创建线程池有哪些参数？"></a>Q9：创建线程池有哪些参数？</h4><p>① corePoolSize：常驻核心线程数，如果为 0，当执行完任务没有任何请求时会消耗线程池；如果大于 0，即使本地任务执行完，核心线程也不会被销毁。该值设置过大会浪费资源，过小会导致线程的频繁创建与销毁。</p><p>② maximumPoolSize：线程池能够容纳同时执行的线程最大数，必须大于等于 1，如果与核心线程数设置相同代表固定大小线程池。</p><p>③ <a href>keep</a>AliveTime：线程空闲时间，线程空闲时间达到该值后会被销毁，直到只剩下 corePoolSize 个线程为止，避免浪费内存资源。</p><p>④ unit：<a href>keep</a>AliveTime 的时间单位。</p><p>⑤ workQueue：工作队列，当线程请求数大于等于 corePoolSize 时线程会进入阻塞队列。</p><p>⑥ threadFactory：线程工厂，用来生产一组相同任务的线程。可以给线程命名，有利于分析错误。</p><p>⑦ handler：拒绝策略，默认使用 AbortPolicy 丢弃任务并抛出异常，CallerRunsPolicy 表示重新尝试提交该任务，DiscardOldestPolicy 表示抛弃队列里等待最久的任务并把当前任务加入队列，DiscardPolicy 表示直接抛弃当前任务但不抛出异常。</p><hr><h4 id="Q10：如何关闭线程池？"><a href="#Q10：如何关闭线程池？" class="headerlink" title="Q10：如何关闭线程池？"></a>Q10：如何关闭线程池？</h4><p>可以调用 <code>shutdown</code> 或 <code>shutdownNow</code> 方法关闭线程池，原理是遍历线程池中的工作线程，然后逐个调用线程的 <code>interrupt</code> 方法中断线程，无法响应中断的任务可能永远无法终止。</p><p>区别是 <code>shutdownNow</code> 首先将线程池的状态设为 STOP，然后尝试停止正在执行或暂停任务的线程，并返回等待执行任务的列表。而 <code>shutdown</code> 只是将线程池的状态设为 SHUTDOWN，然后中断没有正在执行任务的线程。</p><p>通常调用 <code>shutdown</code> 来关闭线程池，如果任务不一定要执行完可调用 <code>shutdownNow</code>。</p><hr><h4 id="Q11：线程池的选择策略有什么？"><a href="#Q11：线程池的选择策略有什么？" class="headerlink" title="Q11：线程池的选择策略有什么？"></a>Q11：线程池的选择策略有什么？</h4><p>可以从以下角度分析：①任务性质：CPU 密集型、IO 密集型和混合型。②任务优先级。③任务执行时间。④任务依赖性：是否依赖其他资源，如数据库连接。</p><p>性质不同的任务可用不同规模的线程池处理，CPU 密集型任务应配置尽可能小的线程，如配置 N<del>cpu</del>+1 个线程的线程池。由于 IO 密集型任务线程并不是一直在执行任务，应配置尽可能多的线程，如 2*N<del>cpu</del>。混合型的任务，如果可以拆分，将其拆分为一个 CPU 密集型任务和一个 IO 密集型任务，只要两个任务执行的时间相差不大那么分解后的吞吐量将高于串行执行的吞吐量，如果相差太大则没必要分解。</p><p>优先级不同的任务可以使用优先级队列 PriorityBlockingQueue 处理。</p><p>执行时间不同的任务可以交给不同规模的线程池处理，或者使用优先级队列让执行时间短的任务先执行。</p><p>依赖数据库连接池的任务，由于线程提交 SQL 后需要等待数据库返回的结果，等待的时间越长 CPU 空闲的时间就越长，因此线程数应该尽可能地设置大一些，提高 CPU 的利用率。</p><p>建议使用有界队列，能增加系统的稳定性和预警能力，可以根据需要设置的稍微大一些。</p><hr><h4 id="Q12：阻塞队列有哪些选择"><a href="#Q12：阻塞队列有哪些选择" class="headerlink" title="Q12：阻塞队列有哪些选择?"></a>Q12：阻塞队列有哪些选择?</h4><p>阻塞队列支持阻塞插入和移除，当队列满时，阻塞插入元素的线程直到队列不满。当队列为空时，获取元素的线程会被阻塞直到队列非空。阻塞队列常用于生产者和消费者的场景，阻塞队列就是生产者用来存放元素，消费者用来获取元素的容器。</p><p><strong>Java 中的阻塞队列</strong></p><p>ArrayBlockingQueue，由数组组成的有界阻塞队列，默认情况下不保证线程公平，有可能先阻塞的线程最后才访问队列。</p><p>LinkedBlockingQueue，由<a href>链表</a>结构组成的有界阻塞队列，队列的默认和最大长度为 Integer 最大值。</p><p>PriorityBlockingQueue，支持优先级的无界阻塞队列，默认情况下元素按照升序<a href>排序</a>。可自定义 <code>compareTo</code> 方法指定<a href>排序</a>规则，或者初始化时指定 Comparator <a href>排序</a>，不能保证同优先级元素的顺序。</p><p>DelayQueue，支持延时获取元素的无界阻塞队列，使用优先级队列实现。创建元素时可以指定多久才能从队列中获取当前元素，只有延迟期满时才能从队列中获取元素，适用于缓存和定时调度。</p><p>SynchronousQueue，不存储元素的阻塞队列，每一个 put 必须等待一个 take。默认使用非公平策略，也支持公平策略，适用于传递性场景，吞吐量高。</p><p>LinkedTransferQueue，<a href>链表</a>组成的无界阻塞队列，相对于其他阻塞队列多了 <code>tryTransfer</code> 和 <code>transfer</code> 方法。<code>transfer</code>方法：如果当前有消费者正等待接收元素，可以把生产者传入的元素立刻传输给消费者，否则会将元素放在队列的尾节点并等到该元素被消费者消费才返回。<code>tryTransfer</code> 方法用来试探生产者传入的元素能否直接传给消费者，如果没有消费者等待接收元素则返回 false，和 <code>transfer</code> 的区别是无论消费者是否消费都会立即返回。</p><p>LinkedBlockingDeque，<a href>链表</a>组成的双向阻塞队列，可从队列的两端插入和移出元素，多线程同时入队时减少了竞争。</p><p><strong>实现原理</strong></p><p>使用通知模式实现，生产者往满的队列里添加元素时会阻塞，当消费者消费后，会通知生产者当前队列可用。当往队列里插入一个元素，如果队列不可用，阻塞生产者主要通过 LockSupport 的 <code>park</code> 方法实现，不同操作系统中实现方式不同，在 Linux 下使用的是系统方法 <code>pthread_cond_wait</code> 实现。</p><hr><h4 id="Q13：谈一谈-ThreadLocal"><a href="#Q13：谈一谈-ThreadLocal" class="headerlink" title="Q13：谈一谈 ThreadLocal"></a>Q13：谈一谈 ThreadLocal</h4><p>ThreadLoacl 是线程共享变量，主要用于一个线程内跨类、方法传递数据。ThreadLoacl 有一个静态内部类 ThreadLocalMap，其 Key 是 ThreadLocal 对象，值是 Entry 对象，Entry 中只有一个 Object 类的 vaule 值。ThreadLocal 是线程共享的，但 ThreadLocalMap 是每个线程私有的。ThreadLocal 主要有 set、get 和 remove 三个方法。</p><p><strong>set 方法</strong></p><p>首先获取当前线程，然后再获取当前线程对应的 ThreadLocalMap 类型的对象 map。如果 map 存在就直接设置值，key 是当前的 ThreadLocal 对象，value 是传入的参数。</p><p>如果 map 不存在就通过 <code>createMap</code> 方法为当前线程创建一个 ThreadLocalMap 对象再设置值。</p><p><strong>get 方法</strong></p><p>首先获取当前线程，然后再获取当前线程对应的 ThreadLocalMap 类型的对象 map。如果 map 存在就以当前 ThreadLocal 对象作为 key 获取 Entry 类型的对象 e，如果 e 存在就返回它的 value 属性。</p><p>如果 e 不存在或者 map 不存在，就调用 <code>setInitialValue</code> 方法先为当前线程创建一个 ThreadLocalMap 对象然后返回默认的初始值 null。</p><p><strong>remove 方法</strong></p><p>首先通过当前线程获取其对应的 ThreadLocalMap 类型的对象 m，如果 m 不为空，就解除 ThreadLocal 这个 key 及其对应的 value 值的联系。</p><p><strong>存在的问题</strong></p><p>线程复用会产生脏数据，由于线程池会重用 Thread 对象，因此与 Thread 绑定的 ThreadLocal 也会被重用。如果没有调用 remove 清理与线程相关的 ThreadLocal 信息，那么假如下一个线程没有调用 set 设置初始值就可能 get 到重用的线程信息。</p><p>ThreadLocal 还存在内存泄漏的问题，由于 ThreadLocal 是弱引用，但 Entry 的 value 是强引用，因此当 ThreadLocal 被垃圾回收后，value 依旧不会被释放。因此需要及时调用 remove 方法进行清理操作。</p><hr><h3 id="JUC-11"><a href="#JUC-11" class="headerlink" title="JUC 11"></a>JUC 11</h3><p>作者：是瑶瑶公主吖<br>链接：<a href="https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post">https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post</a><br>来源：牛客网</p><h4 id="Q1：什么是-CAS？"><a href="#Q1：什么是-CAS？" class="headerlink" title="Q1：什么是 CAS？"></a>Q1：什么是 CAS？</h4><p>CAS 表示 Compare And Swap，比较并交换，CAS 需要三个操作数，分别是内存位置 V、旧的预期值 A 和准备设置的新值 B。CAS 指令执行时，当且仅当 V 符合 A 时，处理器才会用 B 更新 V 的值，否则它就不执行更新。但不管是否更新都会返回 V 的旧值，这些处理过程是原子操作，执行期间不会被其他线程打断。</p><p>在 JDK 5 后，Java 类库中才开始使用 CAS 操作，该操作由 Unsafe 类里的 <code>compareAndSwapInt</code> 等几个方法包装提供。HotSpot 在内部对这些方法做了特殊处理，即时编译的结果是一条平台相关的处理器 CAS 指令。Unsafe 类不是给用户程序调用的类，因此 JDK9 前只有 Java 类库可以使用 CAS，譬如 juc 包里的 AtomicInteger类中 <code>compareAndSet</code> 等方法都使用了Unsafe 类的 CAS 操作实现。</p><hr><h4 id="Q2：CAS-有什么问题？"><a href="#Q2：CAS-有什么问题？" class="headerlink" title="Q2：CAS 有什么问题？"></a>Q2：CAS 有什么问题？</h4><p>CAS 从语义上来说存在一个逻辑漏洞：如果 V 初次读取时是 A，并且在准备赋值时仍为 A，这依旧不能说明它没有被其他线程更改过，因为这段时间内假设它的值先改为 B 又改回 A，那么 CAS 操作就会误认为它从来没有被改变过。</p><p>这个漏洞称为 ABA 问题，juc 包提供了一个 AtomicStampedReference，原子更新带有版本号的引用类型，通过控制变量值的版本来解决 ABA 问题。大部分情况下 ABA 不会影响程序并发的正确性，如果需要解决，传统的互斥同步可能会比原子类更高效。</p><hr><h4 id="Q3：有哪些原子类？"><a href="#Q3：有哪些原子类？" class="headerlink" title="Q3：有哪些原子类？"></a>Q3：有哪些原子类？</h4><p>JDK 5 提供了 java.util.concurrent.atomic 包，这个包中的原子操作类提供了一种用法简单、性能高效、线程安全地更新一个变量的方式。到 JDK 8 该包共有17个类，依据作用分为四种：原子更新基本类型类、原子更新数组类、原子更新引用类以及原子更新字段类，atomic 包里的类基本都是使用 Unsafe 实现的包装类。</p><p>AtomicInteger 原子更新整形、 AtomicLong 原子更新长整型、AtomicBoolean 原子更新布尔类型。</p><p>AtomicIntegerArray，原子更新整形数组里的元素、 AtomicLongArray 原子更新长整型数组里的元素、 AtomicReferenceArray 原子更新引用类型数组里的元素。</p><p>AtomicReference 原子更新引用类型、AtomicMarkableReference 原子更新带有标记位的引用类型，可以绑定一个 boolean 标记、 AtomicStampedReference 原子更新带有版本号的引用类型，关联一个整数值作为版本号，解决 ABA 问题。</p><p>AtomicIntegerFieldUpdater 原子更新整形字段的更新器、 AtomicLongFieldUpdater 原子更新长整形字段的更新器AtomicReferenceFieldUpdater 原子更新引用类型字段的更新器。</p><hr><h4 id="Q4：AtomicIntger-实现原子更新的原理是什么？"><a href="#Q4：AtomicIntger-实现原子更新的原理是什么？" class="headerlink" title="Q4：AtomicIntger 实现原子更新的原理是什么？"></a>Q4：AtomicIntger 实现原子更新的原理是什么？</h4><p>AtomicInteger 原子更新整形、 AtomicLong 原子更新长整型、AtomicBoolean 原子更新布尔类型。</p><p><code>getAndIncrement</code> 以原子方式将当前的值加 1，首先在 for 死循环中取得 AtomicInteger 里存储的数值，第二步对 AtomicInteger 当前的值加 1 ，第三步调用 <code>compareAndSet</code> 方法进行原子更新，先检查当前数值是否等于 expect，如果等于则说明当前值没有被其他线程修改，则将值更新为 next，否则会更新失败返回 false，程序会进入 for 循环重新进行 <code>compareAndSet</code> 操作。</p><p>atomic 包中只提供了三种基本类型的原子更新，atomic 包里的类基本都是使用 Unsafe 实现的，Unsafe 只提供三种 CAS 方法：<code>compareAndSwapInt</code>、<code>compareAndSwapLong</code> 和 <code>compareAndSwapObject</code>，例如原子更新 Boolean 是先转成整形再使用 <code>compareAndSwapInt</code> 。</p><hr><h4 id="Q5：CountDownLatch-是什么？"><a href="#Q5：CountDownLatch-是什么？" class="headerlink" title="Q5：CountDownLatch 是什么？"></a>Q5：CountDownLatch 是什么？</h4><p>CountDownLatch 是基于执行时间的同步类，允许一个或多个线程等待其他线程完成操作，构造方法接收一个 int 参数作为计数器，如果要等待 n 个点就传入 n。每次调用 <code>countDown</code> 方法时计数器减 1，<code>await</code> 方***阻塞当前线程直到计数器变为0，由于 <code>countDown</code> 方法可用在任何地方，所以 n 个点既可以是 n 个线程也可以是一个线程里的 n 个执行步骤。</p><hr><h4 id="Q6：-CyclicBarrier-是什么？"><a href="#Q6：-CyclicBarrier-是什么？" class="headerlink" title="Q6： CyclicBarrier 是什么？"></a>Q6： CyclicBarrier 是什么？</h4><p>循环屏障是基于同步到达某个点的信号量触发机制，作用是让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障才会解除。构造方法中的参数表示拦截线程数量，每个线程调用 <code>await</code> 方法告诉 CyclicBarrier 自己已到达屏障，然后被阻塞。还支持在构造方法中传入一个 Runnable 任务，当线程到达屏障时会优先执行该任务。适用于多线程计算数据，最后合并计算结果的应用场景。</p><p>CountDownLacth 的计数器只能用一次，而 CyclicBarrier 的计数器可使用 <code>reset</code> 方法重置，所以 CyclicBarrier 能处理更为复杂的业务场景，例如计算错误时可用重置计数器重新计算。</p><hr><h4 id="Q7：Semaphore-是什么？"><a href="#Q7：Semaphore-是什么？" class="headerlink" title="Q7：Semaphore 是什么？"></a>Q7：Semaphore 是什么？</h4><p>信号量用来控制同时访问特定资源的线程数量，通过协调各个线程以保证合理使用公共资源。信号量可以用于流量控制，特别是公共资源有限的应用场景，比如数据库连接。</p><p>Semaphore 的构造方法参数接收一个 int 值，表示可用的许可数量即最大并发数。使用 <code>acquire</code> 方法获得一个许可证，使用 <code>release</code> 方法归还许可，还可以用 <code>tryAcquire</code> 尝试获得许可。</p><hr><h4 id="Q8：-Exchanger-是什么？"><a href="#Q8：-Exchanger-是什么？" class="headerlink" title="Q8： Exchanger 是什么？"></a>Q8： Exchanger 是什么？</h4><p>交换者是用于线程间协作的工具类，用于进行线程间的数据交换。它提供一个同步点，在这个同步点两个线程可以交换彼此的数据。</p><p>两个线程通过 <code>exchange</code> 方法交换数据，第一个线程执行 <code>exchange</code> 方法后会阻塞等待第二个线程执行该方法，当两个线程都到达同步点时这两个线程就可以交换数据，将本线程生产出的数据传递给对方。应用场景包括遗传<a href>算法</a>、校对工作等。</p><hr><h4 id="P9：JDK7-的-ConcurrentHashMap-原理？"><a href="#P9：JDK7-的-ConcurrentHashMap-原理？" class="headerlink" title="P9：JDK7 的 ConcurrentHashMap 原理？"></a>P9：JDK7 的 ConcurrentHashMap 原理？</h4><p>ConcurrentHashMap 用于解决 HashMap 的线程不安全和 HashTable 的并发效率低，HashTable 之所以效率低是因为所有线程都必须竞争同一把锁，假如容器里有多把锁，每一把锁用于锁容器的部分数据，那么多线程访问容器不同数据段的数据时，线程间就不会存在锁竞争，从而有效提高并发效率，这就是 ConcurrentHashMap 的锁分段技术。首先将数据分成 Segment 数据段，然后给每一个数据段配一把锁，当一个线程占用锁访问其中一个段的数据时，其他段的数据也能被其他线程访问。</p><p>get 实现简单高效，先经过一次再散列，再用这个散列值通过散列运算定位到 Segment，最后通过散列<a href>算法</a>定位到元素。get 的高效在于不需要加锁，除非读到空值才会加锁重读。get 方法中将共享变量定义为 volatile，在 get 操作里只需要读所以不用加锁。</p><p>put 必须加锁，首先定位到 Segment，然后进行插入操作，第一步判断是否需要对 Segment 里的 HashEntry 数组进行扩容，第二步定位添加元素的位置，然后将其放入数组。</p><p>size 操作用于统计元素的数量，必须统计每个 Segment 的大小然后求和，在统计结果累加的过程中，之前累加过的 count 变化几率很小，因此先尝试两次通过不加锁的方式统计结果，如果统计过程中容器大小发生了变化，再加锁统计所有 Segment 大小。判断容器是否发生变化根据 modCount 确定。</p><hr><h4 id="P10：JDK8-的-ConcurrentHashMap-原理？"><a href="#P10：JDK8-的-ConcurrentHashMap-原理？" class="headerlink" title="P10：JDK8 的 ConcurrentHashMap 原理？"></a>P10：JDK8 的 ConcurrentHashMap 原理？</h4><p>主要对 JDK7 做了三点改造：① 取消分段锁机制，进一步降低冲突概率。② 引入<a href>红黑树</a>结构，同一个哈希槽上的元素个数超过一定阈值后，单向<a href>链表</a>改为<a href>红黑树</a>结构。③ 使用了更加优化的方式统计集合内的元素数量。具体优化表现在：在 put、resize 和 size 方法中设计元素总数的更新和计算都避免了锁，使用 CAS 代替。</p><p>get 同样不需要同步，put 操作时如果没有出现哈希冲突，就使用 CAS 添加元素，否则使用 synchronized 加锁添加元素。</p><p>当某个槽内的元素个数达到 7 且 table 容量不小于 64 时，<a href>链表</a>转为<a href>红黑树</a>。当某个槽内的元素减少到 6 时，由<a href>红黑树</a>重新转为<a href>链表</a>。在转化过程中，使用同步块锁住当前槽的首元素，防止其他线程对当前槽进行增删改操作，转化完成后利用 CAS 替换原有<a href>链表</a>。由于 TreeNode 节点也存储了 next 引用，因此<a href>红黑树</a>转为<a href>链表</a>很简单，只需从 first 元素开始遍历所有节点，并把节点从 TreeNode 转为 Node 类型即可，当构造好新<a href>链表</a>后同样用 CAS 替换<a href>红黑树</a>。</p><hr><h4 id="P11：ArrayList-的线程安全集合是什么？"><a href="#P11：ArrayList-的线程安全集合是什么？" class="headerlink" title="P11：ArrayList 的线程安全集合是什么？"></a>P11：ArrayList 的线程安全集合是什么？</h4><p>可以使用 CopyOnWriteArrayList 代替 ArrayList，它实现了读写分离。写操作复制一个新的集合，在新集合内添加或删除元素，修改完成后再将原集合的引用指向新集合。这样做的好处是可以高并发地进行读写操作而不需要加锁，因为当前集合不会添加任何元素。使用时注意尽量设置容量初始值，并且可以使用批量添加或删除，避免多次扩容，比如只增加一个元素却复制整个集合。</p><p>适合读多写少，单个添加时效率极低。CopyOnWriteArrayList 是 fail-safe 的，并发包的集合都是这种机制，fail-safe 在安全的副本上遍历，集合修改与副本遍历没有任何关系，缺点是无法读取最新数据。这也是 CAP 理论中 C 和 A 的矛盾，即一致性与可用性的矛盾。</p><hr><h2 id="框架-27"><a href="#框架-27" class="headerlink" title="框架 27"></a>框架 27</h2><h3 id="Spring-IoC-11"><a href="#Spring-IoC-11" class="headerlink" title="Spring IoC 11"></a>Spring IoC 11</h3><h4 id="Q1：IoC-是什么？"><a href="#Q1：IoC-是什么？" class="headerlink" title="Q1：IoC 是什么？"></a>Q1：IoC 是什么？</h4><p>IoC 即控制反转，简单来说就是把原来代码里需要实现的对象创建、依赖反转给容器来帮忙实现，需要创建一个容器并且需要一种描述让容器知道要创建的对象间的关系，在 Spring 中管理对象及其依赖关系是通过 Spring 的 IoC 容器实现的。</p><p>IoC 的实现方式有依赖注入和依赖查找，由于依赖查找使用的很少，因此 IoC 也叫做依赖注入。依赖注入指对象被动地接受依赖类而不用自己主动去找，对象不是从容器中查找它依赖的类，而是在容器实例化对象时主动将它依赖的类注入给它。假设一个 Car 类需要一个 Engine 的对象，那么一般需要需要手动 new 一个 Engine，利用 IoC 就只需要定义一个私有的 Engine 类型的成员变量，容器会在运行时自动创建一个 Engine 的实例对象并将引用自动注入给成员变量。</p><hr><h4 id="Q2：IoC-容器初始化过程？"><a href="#Q2：IoC-容器初始化过程？" class="headerlink" title="Q2：IoC 容器初始化过程？"></a>Q2：IoC 容器初始化过程？</h4><p><strong>基于 XML 的容器初始化</strong></p><p>当创建一个 ClassPathXmlApplicationContext 时，构造方法做了两件事：① 调用父容器的构造方法为容器设置好 Bean 资源加载器。② 调用父类的 <code>setConfigLocations</code> 方法设置 Bean 配置信息的定位路径。</p><p>ClassPathXmlApplicationContext 通过调用父类 AbstractApplicationContext 的 <code>refresh</code> 方法启动整个 IoC 容器对 Bean 定义的载入过程，<code>refresh</code> 是一个模板方法，规定了 IoC 容器的启动流程。在创建 IoC 容器前如果已有容器存在，需要把已有的容器销毁，保证在 <code>refresh</code> 方法后使用的是新创建的 IoC 容器。</p><p>容器创建后通过 <code>loadBeanDefinitions</code> 方法加载 Bean 配置资源，该方法做两件事：① 调用资源加载器的方法获取要加载的资源。② 真正执行加载功能，由子类 XmlBeanDefinitionReader 实现。加载资源时首先解析配置文件路径，读取配置文件的内容，然后通过 XML 解析器将 Bean 配置信息转换成文档对象，之后按照 Spring Bean 的定义规则对文档对象进行解析。</p><p>Spring IoC 容器中注册解析的 Bean 信息存放在一个 HashMap 集合中，key 是字符串，值是 BeanDefinition，注册过程中需要使用 synchronized 保证线程安全。当配置信息中配置的 Bean 被解析且被注册到 IoC 容器中后，初始化就算真正完成了，Bean 定义信息已经可以使用且可被检索。Spring IoC 容器的作用就是对这些注册的 Bean 定义信息进行处理和维护，注册的 Bean 定义信息是控制反转和依赖注入的基础。</p><p><strong>基于注解的容器初始化</strong></p><p>分为两种：① 直接将注解 Bean 注册到容器中，可以在初始化容器时注册，也可以在容器创建之后手动注册，然后刷新容器使其对注册的注解 Bean 进行处理。② 通过扫描指定的包及其子包的所有类处理，在初始化注解容器时指定要自动扫描的路径。</p><hr><h4 id="Q3：依赖注入的实现方法有哪些？"><a href="#Q3：依赖注入的实现方法有哪些？" class="headerlink" title="Q3：依赖注入的实现方法有哪些？"></a>Q3：依赖注入的实现方法有哪些？</h4><p><strong>构造方法注入：</strong> IoC Service Provider 会检查被注入对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。这种方法的优点是在对象构造完成后就处于就绪状态，可以马上使用。缺点是当依赖对象较多时，构造方法的参数列表会比较长，构造方法无法被继承，无法设置默认值。对于非必需的依赖处理可能需要引入多个构造方法，参数数量的变动可能会造成维护的困难。</p><p><strong>setter 方法注入：</strong> 当前对象只需要为其依赖对象对应的属性添加 setter 方法，就可以通过 setter 方法将依赖对象注入到被依赖对象中。setter 方法注入在描述性上要比构造方法注入强，并且可以被继承，允许设置默认值。缺点是无法在对象构造完成后马上进入就绪状态。</p><p><strong>接口注入：</strong> 必须实现某个接口，接口提供方法来为其注入依赖对象。使用少，因为它强制要求被注入对象实现不必要接口，侵入性强。</p><hr><h4 id="Q4：依赖注入的相关注解？"><a href="#Q4：依赖注入的相关注解？" class="headerlink" title="Q4：依赖注入的相关注解？"></a>Q4：依赖注入的相关注解？</h4><p><code>@Autowired</code>：自动按类型注入，如果有多个匹配则按照指定 Bean 的 id 查找，查找不到会报错。</p><p><code>@Qualifier</code>：在自动按照类型注入的基础上再按照 Bean 的 id 注入，给变量注入时必须搭配 <code>@Autowired</code>，给方法注入时可单独使用。</p><p><code>@Resource</code> ：直接按照 Bean 的 id 注入，只能注入 Bean 类型。</p><p><code>@Value</code> ：用于注入基本数据类型和 String 类型。</p><hr><h4 id="Q5：依赖注入的过程？"><a href="#Q5：依赖注入的过程？" class="headerlink" title="Q5：依赖注入的过程？"></a>Q5：依赖注入的过程？</h4><p><code>getBean</code> 方法获取 Bean 实例，该方***调用 <code>doGetBean</code> ，<code>doGetBean</code> 真正实现从 IoC 容器获取 Bean 的功能，也是触发依赖注入的地方。</p><p>具体创建 Bean 对象的过程由 ObjectFactory 的 <code>createBean</code> 完成，该方法主要通过 <code>createBeanInstance</code> 方法生成 Bean 包含的 Java 对象实例和 <code>populateBean</code> 方法对 Bean 属性的依赖注入进行处理。</p><p>在 <code>populateBean</code>方法中，注入过程主要分为两种情况：① 属性值类型不需要强制转换时，不需要解析属性值，直接进行依赖注入。② 属性值类型需要强制转换时，首先解析属性值，然后对解析后的属性值进行依赖注入。依赖注入的过程就是将 Bean 对象实例设置到它所依赖的 Bean 对象属性上，真正的依赖注入是通过 <code>setPropertyValues</code> 方法实现的，该方法使用了委派模式。</p><p>BeanWrapperImpl 类负责对完成初始化的 Bean 对象进行依赖注入，对于非集合类型属性，使用 JDK 反射，通过属性的 setter 方法为属性设置注入后的值。对于集合类型的属性，将属性值解析为目标类型的集合后直接赋值给属性。</p><p>当容器对 Bean 的定位、载入、解析和依赖注入全部完成后就不再需要手动创建对象，IoC 容器会自动为我们创建对象并且注入依赖。</p><hr><h4 id="Q6：Bean-的生命周期？"><a href="#Q6：Bean-的生命周期？" class="headerlink" title="Q6：Bean 的生命周期？"></a>Q6：Bean 的生命周期？</h4><p>在 IoC 容器的初始化过程中会对 Bean 定义完成资源定位，加载读取配置并解析，最后将解析的 Bean 信息放在一个 HashMap 集合中。当 IoC 容器初始化完成后，会进行对 Bean 实例的创建和依赖注入过程，注入对象依赖的各种属性值，在初始化时可以指定自定义的初始化方法。经过这一系列初始化操作后 Bean 达到可用状态，接下来就可以使用 Bean 了，当使用完成后会调用 destroy 方法进行销毁，此时也可以指定自定义的销毁方法，最终 Bean 被销毁且从容器中移除。</p><p>XML 方式通过配置 bean 标签中的 init-Method 和 destory-Method 指定自定义初始化和销毁方法。 </p><p>注解方式通过 <code>@PreConstruct</code> 和 <code>@PostConstruct</code> 注解指定自定义初始化和销毁方法。</p><hr><h4 id="Q7：Bean-的作用范围？"><a href="#Q7：Bean-的作用范围？" class="headerlink" title="Q7：Bean 的作用范围？"></a>Q7：Bean 的作用范围？</h4><p>通过 scope 属性指定 bean 的作用范围，包括：</p><p>① singleton：单例模式，是默认作用域，不管收到多少 Bean 请求每个容器中只有一个唯一的 Bean 实例。</p><p>② prototype：原型模式，和 singleton 相反，每次 Bean 请求都会创建一个新的实例。</p><p>③ request：每次 HTTP 请求都会创建一个新的 Bean 并把它放到 request 域中，在请求完成后 Bean 会失效并被垃圾收集器回收。</p><p>④ session：和 request 类似，确保每个 session 中有一个 Bean 实例，session 过期后 bean 会随之失效。</p><p>⑤ global session：当应用部署在 Portlet 容器时，如果想让所有 Portlet 共用全局存储变量，那么该变量需要存储在 global session 中。</p><hr><h4 id="Q8：如何通过-XML-方式创建-Bean？"><a href="#Q8：如何通过-XML-方式创建-Bean？" class="headerlink" title="Q8：如何通过 XML 方式创建 Bean？"></a>Q8：如何通过 XML 方式创建 Bean？</h4><p>默认无参构造方法，只需要指明 bean 标签中的 id 和 class 属性，如果没有无参构造方***报错。</p><p>静态工厂方法，通过 bean 标签中的 class 属性指明静态工厂，factory-method 属性指明静态工厂方法。</p><p>实例工厂方法，通过 bean 标签中的 factory-bean 属性指明实例工厂，factory-method 属性指明实例工厂方法。</p><hr><h4 id="Q9：如何通过注解创建-Bean？"><a href="#Q9：如何通过注解创建-Bean？" class="headerlink" title="Q9：如何通过注解创建 Bean？"></a>Q9：如何通过注解创建 Bean？</h4><p><code>@Component</code> 把当前类对象存入 Spring 容器中，相当于在 xml 中配置一个 bean 标签。value 属性指定 bean 的 id，默认使用当前类的首字母小写的类名。</p><p><code>@Controller</code>，<code>@Service</code>，<code>@Repository</code> 三个注解都是 <code>@Component</code> 的衍生注解，作用及属性都是一模一样的。只是提供了更加明确语义，<code>@Controller</code> 用于表现层，<code>@Service</code>用于业务层，<code>@Repository</code>用于持久层。如果注解中有且只有一个 value 属性要赋值时可以省略 value。</p><p>如果想将第三方的类变成组件又没有源代码，也就没办法使用 <code>@Component</code> 进行自动配置，这种时候就要使用 <code>@Bean</code> 注解。被 <code>@Bean</code> 注解的方法返回值是一个对象，将会实例化，配置和初始化一个新对象并返回，这个对象由 Spring 的 IoC 容器管理。name 属性用于给当前 <code>@Bean</code> 注解方法创建的对象指定一个名称，即 bean 的 id。当使用注解配置方法时，如果方法有参数，Spring 会去容器查找是否有可用 bean对象，查找方式和 <code>@Autowired</code> 一样。</p><hr><h4 id="Q10：如何通过注解配置文件？"><a href="#Q10：如何通过注解配置文件？" class="headerlink" title="Q10：如何通过注解配置文件？"></a>Q10：如何通过注解配置文件？</h4><p><code>@Configuration</code> 用于指定当前类是一个 spring 配置类，当创建容器时会从该类上加载注解，value 属性用于指定配置类的字节码。</p><p><code>@ComponentScan</code> 用于指定 Spring 在初始化容器时要扫描的包。basePackages 属性用于指定要扫描的包。</p><p><code>@PropertySource</code> 用于加载 <code>.properties</code> 文件中的配置。value 属性用于指定文件位置，如果是在类路径下需要加上 classpath。</p><p><code>@Import</code> 用于导入其他配置类，在引入其他配置类时可以不用再写 <code>@Configuration</code> 注解。有 <code>@Import</code> 的是父配置类，引入的是子配置类。value 属性用于指定其他配置类的字节码。</p><hr><h4 id="Q11：BeanFactory、FactoryBean-和-ApplicationContext-的区别？"><a href="#Q11：BeanFactory、FactoryBean-和-ApplicationContext-的区别？" class="headerlink" title="Q11：BeanFactory、FactoryBean 和 ApplicationContext 的区别？"></a>Q11：BeanFactory、FactoryBean 和 ApplicationContext 的区别？</h4><p>BeanFactory 是一个 Bean 工厂，使用简单工厂模式，是 Spring IoC 容器顶级接口，可以理解为含有 Bean 集合的工厂类，作用是管理 Bean，包括实例化、定位、配置对象及建立这些对象间的依赖。BeanFactory 实例化后并不会自动实例化 Bean，只有当 Bean 被使用时才实例化与装配依赖关系，属于延迟加载，适合多例模式。</p><p>FactoryBean 是一个工厂 Bean，使用了工厂方法模式，作用是生产其他 Bean 实例，可以通过实现该接口，提供一个工厂方法来自定义实例化 Bean 的逻辑。FactoryBean 接口由 BeanFactory 中配置的对象实现，这些对象本身就是用于创建对象的工厂，如果一个 Bean 实现了这个接口，那么它就是创建对象的工厂 Bean，而不是 Bean 实例本身。</p><p>ApplicationConext 是 BeanFactory 的子接口，扩展了 BeanFactory 的功能，提供了支持国际化的文本消息，统一的资源文件读取方式，事件传播以及应用层的特别配置等。容器会在初始化时对配置的 Bean 进行预实例化，Bean 的依赖注入在容器初始化时就已经完成，属于立即加载，适合单例模式，一般推荐使用。</p><hr><h3 id="Spring-AOP-4"><a href="#Spring-AOP-4" class="headerlink" title="Spring AOP 4"></a>Spring AOP 4</h3><p>作者：是瑶瑶公主吖<br>链接：<a href="https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post">https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post</a><br>来源：牛客网</p><h4 id="Q1：AOP-是什么？"><a href="#Q1：AOP-是什么？" class="headerlink" title="Q1：AOP 是什么？"></a>Q1：AOP 是什么？</h4><p>AOP 即面向切面编程，简单地说就是将代码中重复的部分抽取出来，在需要执行的时候使用动态代理技术，在不修改<a href>源码</a>的基础上对方法进行增强。</p><p>Spring 根据类是否实现接口来判断动态代理方式，如果实现接口会使用 JDK 的动态代理，核心是 InvocationHandler 接口和 Proxy 类，如果没有实现接口会使用 CGLib 动态代理，CGLib 是在运行时动态生成某个类的子类，如果某个类被标记为 final，不能使用 CGLib 。</p><p>JDK 动态代理主要通过重组字节码实现，首先获得被代理对象的引用和所有接口，生成新的类必须实现被代理类的所有接口，动态生成Java 代码后编译新生成的 <code>.class</code> 文件并重新加载到 JVM 运行。JDK 代理直接写 Class 字节码，CGLib 是采用 ASM 框架写字节码，生成代理类的效率低。但是 CGLib 调用方法的效率高，因为 JDK 使用反射调用方法，CGLib 使用 FastClass 机制为代理类和被代理类各生成一个类，这个类会为代理类或被代理类的方法生成一个 index，这个 index 可以作为参数直接定位要调用的方法。</p><p>常用场景包括权限认证、自动缓存、错误处理、日志、调试和事务等。</p><hr><h4 id="Q2：AOP-的相关注解有哪些？"><a href="#Q2：AOP-的相关注解有哪些？" class="headerlink" title="Q2：AOP 的相关注解有哪些？"></a>Q2：AOP 的相关注解有哪些？</h4><p><code>@Aspect</code>：声明被注解的类是一个切面 Bean。</p><p><code>@Before</code>：前置通知，指在某个连接点之前执行的通知。</p><p><code>@After</code>：后置通知，指某个连接点退出时执行的通知（不论正常返回还是异常退出）。</p><p><code>@AfterReturning</code>：返回后通知，指某连接点正常完成之后执行的通知，返回值使用returning属性接收。</p><p><code>@AfterThrowing</code>：异常通知，指方法抛出异常导致退出时执行的通知，和<code>@AfterReturning</code>只会有一个执行，异常使用throwing属性接收。</p><hr><h4 id="Q3：AOP-的相关术语有什么？"><a href="#Q3：AOP-的相关术语有什么？" class="headerlink" title="Q3：AOP 的相关术语有什么？"></a>Q3：AOP 的相关术语有什么？</h4><p><code>Aspect</code>：切面，一个关注点的模块化，这个关注点可能会横切多个对象。</p><p><code>Joinpoint</code>：连接点，程序执行过程中的某一行为，即业务层中的所有方法。。</p><p><code>Advice</code>：通知，指切面对于某个连接点所产生的动作，包括前置通知、后置通知、返回后通知、异常通知和环绕通知。</p><p><code>Pointcut</code>：切入点，指被拦截的连接点，切入点一定是连接点，但连接点不一定是切入点。</p><p><code>Proxy</code>：代理，Spring AOP 中有 JDK 动态代理和 CGLib 代理，目标对象实现了接口时采用 JDK 动态代理，反之采用 CGLib 代理。</p><p><code>Target</code>：代理的目标对象，指一个或多个切面所通知的对象。</p><p><code>Weaving</code> ：织入，指把增强应用到目标对象来创建代理对象的过程。</p><hr><h4 id="Q4：AOP-的过程？"><a href="#Q4：AOP-的过程？" class="headerlink" title="Q4：AOP 的过程？"></a>Q4：AOP 的过程？</h4><p>Spring AOP 由 BeanPostProcessor 后置处理器开始，这个后置处理器是一个***，可以监听容器触发的 Bean 生命周期事件，向容器注册后置处理器以后，容器中管理的 Bean 就具备了接收 IoC 容器回调事件的能力。BeanPostProcessor 的调用发生在 Spring IoC 容器完成 Bean 实例对象的创建和属性的依赖注入后，为 Bean 对象添加后置处理器的入口是 <code>initializeBean</code> 方法。</p><p>Spring 中 JDK 动态代理通过 JdkDynamicAopProxy 调用 Proxy 的 <code>newInstance</code> 方法来生成代理类，JdkDynamicAopProxy 也实现了 InvocationHandler 接口，<code>invoke</code> 方法的具体逻辑是先获取应用到此方法上的拦截器链，如果有拦截器则创建 MethodInvocation 并调用其 <code>proceed</code> 方法，否则直接反射调用目标方法。因此 Spring AOP 对目标对象的增强是通过拦截器实现的。</p><hr><h3 id="Spring-MVC-3"><a href="#Spring-MVC-3" class="headerlink" title="Spring MVC 3"></a>Spring MVC 3</h3><h4 id="Q1：Spring-MVC-的处理流程？"><a href="#Q1：Spring-MVC-的处理流程？" class="headerlink" title="Q1：Spring MVC 的处理流程？"></a>Q1：Spring MVC 的处理流程？</h4><p>Web 容器启动时会通知 Spring 初始化容器，加载 Bean 的定义信息并初始化所有单例 Bean，然后遍历容器中的 Bean，获取每一个 Controller 中的所有方法访问的 URL，将 URL 和对应的 Controller 保存到一个 Map 集合中。</p><p>所有的请求会转发给 DispatcherServlet <a href>前端</a>处理器处理，DispatcherServlet 会请求 HandlerMapping 找出容器中被 <code>@Controler</code> 注解修饰的 Bean 以及被 <code>@RequestMapping</code> 修饰的方法和类，生成 Handler 和 HandlerInterceptor 并以一个 HandlerExcutionChain 处理器执行链的形式返回。</p><p>之后 DispatcherServlet 使用 Handler 找到对应的 HandlerApapter，通过 HandlerApapter 调用 Handler 的方法，将请求参数绑定到方法的形参上，执行方法处理请求并得到 ModelAndView。</p><p>最后 DispatcherServlet 根据使用 ViewResolver 试图解析器对得到的 ModelAndView 逻辑视图进行解析得到 View 物理视图，然后对视图渲染，将数据填充到视图中并返回给<a href>客户端</a>。</p><hr><h4 id="Q2：Spring-MVC-有哪些组件？"><a href="#Q2：Spring-MVC-有哪些组件？" class="headerlink" title="Q2：Spring MVC 有哪些组件？"></a>Q2：Spring MVC 有哪些组件？</h4><p><code>DispatcherServlet</code>：SpringMVC 中的<a href>前端</a>控制器，是整个流程控制的核心，负责接收请求并转发给对应的处理组件。</p><p><code>Handler</code>：处理器，完成具体业务逻辑，相当于 Servlet 或 Action。</p><p><code>HandlerMapping</code>：完成 URL 到 Controller 映射，DispatcherServlet 通过 HandlerMapping 将不同请求映射到不同 Handler。</p><p><code>HandlerInterceptor</code>：处理器拦截器，是一个接口，如果需要完成一些拦截处理，可以实现该接口。</p><p><code>HandlerExecutionChain</code>：处理器执行链，包括两部分内容：Handler 和 HandlerInterceptor。</p><p><code>HandlerAdapter</code>：处理器适配器，Handler执行业务方法前需要进行一系列操作，包括表单数据验证、数据类型转换、将表单数据封装到JavaBean等，这些操作都由 HandlerAdapter 完成。DispatcherServlet 通过 HandlerAdapter 来执行不同的 Handler。</p><p><code>ModelAndView</code>：装载模型数据和视图信息，作为 Handler 处理结果返回给 DispatcherServlet。</p><p><code>ViewResolver</code>：视图解析器，DispatcherServlet 通过它将逻辑视图解析为物理视图，最终将渲染的结果响应给<a href>客户端</a>。</p><hr><h4 id="Q3：Spring-MVC-的相关注解？"><a href="#Q3：Spring-MVC-的相关注解？" class="headerlink" title="Q3：Spring MVC 的相关注解？"></a>Q3：Spring MVC 的相关注解？</h4><p><code>@Controller</code>：在类定义处添加，将类交给IoC容器管理。</p><p><code>@RequtestMapping</code>：将URL请求和业务方法映射起来，在类和方法定义上都可以添加该注解。<code>value</code> 属性指定URL请求的实际地址，是默认值。<code>method</code> 属性限制请求的方法类型，包括GET、POST、PUT、DELETE等。如果没有使用指定的请求方法请求URL，会报405 Method Not Allowed 错误。<code>params</code> 属性限制必须提供的参数，如果没有会报错。</p><p><code>@RequestParam</code>：如果 Controller 方法的形参和 URL 参数名一致可以不添加注解，如果不一致可以使用该注解绑定。<code>value</code> 属性表示HTTP请求中的参数名。<code>required</code> 属性设置参数是否必要，默认false。<code>defaultValue</code> 属性指定没有给参数赋值时的默认值。</p><p><code>@PathVariable</code>：Spring MVC 支持 RESTful 风格 URL，通过 <code>@PathVariable</code> 完成请求参数与形参的绑定。</p><hr><h3 id="Spring-Data-JPA-4"><a href="#Spring-Data-JPA-4" class="headerlink" title="Spring Data JPA 4"></a>Spring Data JPA 4</h3><p>作者：是瑶瑶公主吖<br>链接：<a href="https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post">https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post</a><br>来源：牛客网</p><h4 id="Q1：ORM-是什么？"><a href="#Q1：ORM-是什么？" class="headerlink" title="Q1：ORM 是什么？"></a>Q1：ORM 是什么？</h4><p>ORM 即 Object-Relational Mapping ，表示对象关系映射，映射的不只是对象的值还有对象之间的关系，通过 ORM 就可以把对象映射到关系型数据库中。操作实体类就相当于操作数据库表，可以不再重点关注 SQL 语句。</p><hr><h4 id="Q2：JPA-如何使用？"><a href="#Q2：JPA-如何使用？" class="headerlink" title="Q2：JPA 如何使用？"></a>Q2：JPA 如何使用？</h4><p>只需要持久层接口继承 JpaRepository 即可，泛型参数列表中第一个参数是实体类类型，第二个参数是主键类型。</p><p>运行时通过 <code>JdkDynamicAopProxy</code> 的 <code>invoke</code> 方法创建了一个动态代理对象 <code>SimpleJpaRepository</code>，<code>SimpleJpaRepository</code> 中封装了 JPA 的操作，通过 <code>hibernate</code>（封装了JDBC）完成数据库操作。</p><hr><h4 id="Q3：JPA-实体类相关注解有哪些？"><a href="#Q3：JPA-实体类相关注解有哪些？" class="headerlink" title="Q3：JPA 实体类相关注解有哪些？"></a>Q3：JPA 实体类相关注解有哪些？</h4><p><code>@Entity</code>：表明当前类是一个实体类。</p><p><code>@Table</code> ：关联实体类和数据库表。</p><p><code>@Column</code> ：关联实体类属性和数据库表中字段。</p><p><code>@Id</code> ：声明当前属性为数据库表主键对应的属性。</p><p><code>@GeneratedValue</code>： 配置主键生成策略。</p><p><code>@OneToMany</code> ：配置一对多关系，mappedBy 属性值为主表实体类在从表实体类中对应的属性名。</p><p><code>@ManyToOne</code> ：配置多对一关系，targetEntity 属性值为主表对应实体类的字节码。</p><p><code>@JoinColumn</code>：配置外键关系，name 属性值为外键名称，referencedColumnName 属性值为主表主键名称。</p><hr><h4 id="Q4：对象导航查询是什么？"><a href="#Q4：对象导航查询是什么？" class="headerlink" title="Q4：对象导航查询是什么？"></a>Q4：对象导航查询是什么？</h4><p>通过 get 方法查询一个对象的同时，通过此对象可以查询它的关联对象。</p><p>对象导航查询一到多默认使用延迟加载的形式， 关联对象是集合，因此使用立即加载可能浪费资源。</p><p>对象导航查询多到一默认使用立即加载的形式， 关联对象是一个对象，因此使用立即加载。</p><p>如果要改变加载方式，在实体类注解配置加上 fetch 属性即可，LAZY 表示延迟加载，EAGER 表示立即加载。</p><hr><h3 id="Mybatis-5"><a href="#Mybatis-5" class="headerlink" title="Mybatis 5"></a>Mybatis 5</h3><h4 id="Q1：Mybatis-的优缺点？"><a href="#Q1：Mybatis-的优缺点？" class="headerlink" title="Q1：Mybatis 的优缺点？"></a>Q1：Mybatis 的优缺点？</h4><p><strong>优点</strong></p><p>相比 JDBC 减少了大量代码量，减少冗余代码。</p><p>使用灵活，SQL 语句写在 XML 里，从程序代码中彻底分离，降低了耦合度，便于管理。</p><p>提供 XML 标签，支持编写动态 SQL 语句。</p><p>提供映射标签，支持对象与数据库的 ORM 字段映射关系。</p><p><strong>缺点</strong></p><p>SQL 语句编写工作量较大，尤其是字段和关联表多时。</p><p>SQL 语句依赖于数据库，导致数据库移植性差，不能随意更换数据库。</p><hr><h4 id="Q2：Mybatis-的-XML-文件有哪些标签属性？"><a href="#Q2：Mybatis-的-XML-文件有哪些标签属性？" class="headerlink" title="Q2：Mybatis 的 XML 文件有哪些标签属性？"></a>Q2：Mybatis 的 XML 文件有哪些标签属性？</h4><p><code>select</code>、<code>insert</code>、<code>update</code>、<code>delete</code> 标签分别对应查询、添加、更新、删除操作。</p><p><code>parameterType</code> 属性表示参数的数据类型，包括基本数据类型和对应的包装类型、String 和 Java Bean 类型，当有多个参数时可以使用 <code>#&#123;argn&#125;</code> 的形式表示第 n 个参数。除了基本数据类型都要以全限定类名的形式指定参数类型。</p><p><code>resultType</code> 表示返回的结果类型，包括基本数据类型和对应的包装类型、String 和 Java Bean 类型。还可以使用把返回结果封装为复杂类型的 <code>resultMap</code> 。</p><hr><h4 id="Q3：Mybatis-的一级缓存是什么？"><a href="#Q3：Mybatis-的一级缓存是什么？" class="headerlink" title="Q3：Mybatis 的一级缓存是什么？"></a>Q3：Mybatis 的一级缓存是什么？</h4><p>一级缓存是 SqlSession 级别，默认开启且不能关闭。</p><p>操作数据库时需要创建 SqlSession 对象，对象中有一个 HashMap 存储缓存数据，不同 SqlSession 之间缓存数据区域互不影响。</p><p>一级缓存的作用域是 SqlSession 范围的，在同一个 SqlSession 中执行两次相同的 SQL 语句时，第一次执行完毕会将结果保存在缓存中，第二次查询直接从缓存中获取。</p><p>如果 SqlSession 执行了 DML 操作（insert、update、delete），Mybatis 必须将缓存清空保证数据有效性。 </p><hr><h4 id="Q4：Mybatis-的二级缓存是什么？"><a href="#Q4：Mybatis-的二级缓存是什么？" class="headerlink" title="Q4：Mybatis 的二级缓存是什么？"></a>Q4：Mybatis 的二级缓存是什么？</h4><p>二级缓存是Mapper 级别，默认关闭。</p><p>使用二级缓存时多个 SqlSession 使用同一个 Mapper 的 SQL 语句操作数据库，得到的数据会存在二级缓存区，同样使用 HashMap 进行数据存储，相比于一级缓存，二级缓存范围更大，多个 SqlSession 可以共用二级缓存，作用域是 Mapper 的同一个 namespace，不同 SqlSession 两次执行相同的 namespace 下的 SQL 语句，参数也相等，则第一次执行成功后会将数据保存在二级缓存中，第二次可直接从二级缓存中取出数据。</p><p>要使用二级缓存，需要在全局配置文件中配置 <code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;</code> ，再在对应的映射文件中配置一个 <code>&lt;cache/&gt;</code> 标签。</p><hr><h4 id="Q5：Mybatis-和-的区别？"><a href="#Q5：Mybatis-和-的区别？" class="headerlink" title="Q5：Mybatis #{} 和 ${} 的区别？"></a>Q5：Mybatis <code>#&#123;&#125;</code> 和 <code>$&#123;&#125;</code> 的区别？</h4><p>使用 <code>$&#123;&#125;</code> 相当于使用字符串拼接，存在 SQL 注入的风险。</p><p>使用 <code>#&#123;&#125;</code> 相当于使用占位符，可以防止 SQL 注入，不支持使用占位符的地方就只能使用 <code>$&#123;&#125;</code> ，典型情况就是动态参数。</p><hr><h2 id="数据结构和算法-13"><a href="#数据结构和算法-13" class="headerlink" title="数据结构和算法 13"></a>数据结构和<a href>算法</a> 13</h2><h3 id="数据结构-4"><a href="#数据结构-4" class="headerlink" title="数据结构 4"></a>数据结构 4</h3><h4 id="Q1：什么是-AVL-树？"><a href="#Q1：什么是-AVL-树？" class="headerlink" title="Q1：什么是 AVL 树？"></a>Q1：什么是 AVL 树？</h4><p>AVL 树是平衡二叉查找树，增加和删除节点后通过树形旋转重新达到平衡。右旋是以某个节点为中心，将它沉入当前右子节点的位置，而让当前的左子节点作为新树的根节点，也称为顺时针旋转。同理左旋是以某个节点为中心，将它沉入当前左子节点的位置，而让当前的右子节点作为新树的根节点，也称为逆时针旋转。</p><hr><h4 id="Q2：什么是红黑树？"><a href="#Q2：什么是红黑树？" class="headerlink" title="Q2：什么是红黑树？"></a>Q2：什么是<a href>红黑树</a>？</h4><p><a href>红黑树</a>是 1972 年发明的，称为对称二叉 B 树，1978 年正式命名<a href>红黑树</a>。主要特征是在每个节点上增加一个属性表示节点颜色，可以红色或黑色。<a href>红黑树</a>和 AVL 树类似，都是在进行插入和删除时通过旋转保持自身平衡，从而获得较高的查找性能。与 AVL 树相比，<a href>红黑树</a>不追求所有递归子树的高度差不超过 1，保证从根节点到叶尾的最长路径不超过最短路径的 2 倍，所以最差时间复杂度是 O(log<del>n</del>)。<a href>红黑树</a>通过重新着色和左右旋转，更加高效地完成了插入和删除之后的自平衡调整。</p><p><a href>红黑树</a>在本质上还是二叉查找树，它额外引入了 5 个约束条件：① 节点只能是红色或黑色。② 根节点必须是黑色。③ 所有 NIL 节点都是黑色的。④ 一条路径上不能出现相邻的两个红色节点。⑤ 在任何递归子树中，根节点到叶子节点的所有路径上包含相同数目的黑色节点。这五个约束条件保证了<a href>红黑树</a>的新增、删除、查找的最坏时间复杂度均为 O(log<del>n</del>)。如果一个树的左子节点或右子节点不存在，则均认定为黑色。<a href>红黑树</a>的任何旋转在 3 次之内均可完成。</p><hr><h4 id="Q3：AVL-树和红黑树的区别？"><a href="#Q3：AVL-树和红黑树的区别？" class="headerlink" title="Q3：AVL 树和红黑树的区别？"></a>Q3：AVL 树和<a href>红黑树</a>的区别？</h4><p><a href>红黑树</a>的平衡性不如 AVL 树，它维持的只是一种大致的平衡，不严格保证左右子树的高度差不超过 1。这导致节点数相同的情况下，<a href>红黑树</a>的高度可能更高，也就是说平均查找次数会高于相同情况的 AVL 树。</p><p>在插入时，<a href>红黑树</a>和 AVL 树都能在至多两次旋转内恢复平衡，在删除时由于<a href>红黑树</a>只追求大致平衡，因此<a href>红黑树</a>至多三次旋转可以恢复平衡，而 AVL 树最多需要 O(log<del>n</del>) 次。AVL 树在插入和删除时，将向上回溯确定是否需要旋转，这个回溯的时间成本最差为 O(log<del>n</del>)，而<a href>红黑树</a>每次向上回溯的步长为 2，回溯成本低。因此面对频繁地插入与删除<a href>红黑树</a>更加合适。</p><hr><h4 id="Q4：B-树和B-树的区别？"><a href="#Q4：B-树和B-树的区别？" class="headerlink" title="Q4：B 树和B+ 树的区别？"></a>Q4：B 树和B+ 树的区别？</h4><p>B 树中每个节点同时存储 key 和 data，而 B+ 树中只有叶子节点才存储 data，非叶子节点只存储 key。InnoDB 对 B+ 树进行了优化，在每个叶子节点上增加了一个指向相邻叶子节点的<a href>链表</a>指针，形成了带有顺序指针的 B+ 树，提高区间访问的性能。</p><p>B+ 树的优点在于：① 由于 B+ 树在非叶子节点上不含数据信息，因此在内存页中能够存放更多的 key，数据存放得更加紧密，具有更好的空间利用率，访问叶子节点上关联的数据也具有更好的缓存命中率。② B+树的叶子结点都是相连的，因此对整棵树的遍历只需要一次线性遍历叶子节点即可。而 B 树则需要进行每一层的递归遍历，相邻的元素可能在内存中不相邻，所以缓存命中性没有 B+树好。但是 B 树也有优点，由于每个节点都包含 key 和 value，因此经常访问的元素可能离根节点更近，访问也更迅速。</p><hr><h3 id="排序-9"><a href="#排序-9" class="headerlink" title="排序 9"></a><a href>排序</a> 9</h3><h4 id="Q1：排序有哪些分类？"><a href="#Q1：排序有哪些分类？" class="headerlink" title="Q1：排序有哪些分类？"></a>Q1：<a href>排序</a>有哪些分类？</h4><p><a href>排序</a>可以分为内部<a href>排序</a>和外部<a href>排序</a>，在内存中进行的称为内部<a href>排序</a>，当数据量很大时无法全部拷贝到内存需要使用外存，称为外部<a href>排序</a>。</p><p>内部<a href>排序</a>包括比较<a href>排序</a>和非比较<a href>排序</a>，比较<a href>排序</a>包括插入&#x2F;选择&#x2F;交换&#x2F;归并<a href>排序</a>，非比较<a href>排序</a>包括计数&#x2F;基数&#x2F;桶<a href>排序</a>。</p><p>插入<a href>排序</a>包括直接插入&#x2F;希尔<a href>排序</a>，选择<a href>排序</a>包括直接选择&#x2F;堆<a href>排序</a>，交换<a href>排序</a>包括冒泡&#x2F;快速<a href>排序</a>。</p><hr><h4 id="Q2：直接插入排序的原理？"><a href="#Q2：直接插入排序的原理？" class="headerlink" title="Q2：直接插入排序的原理？"></a>Q2：直接插入<a href>排序</a>的原理？</h4><p>稳定，平均&#x2F;最差时间复杂度 O(n²)，元素基本有序时最好时间复杂度 O(n)，空间复杂度 O(1)。</p><p>每一趟将一个待<a href>排序</a>记录按其关键字的大小插入到已排好序的一组记录的适当位置上，直到所有待<a href>排序</a>记录全部插入为止。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public` `void` `insertionSort(``int``[] nums) &#123;``  ``for` `(``int` `i = ``1``; i &lt; nums.length; i++) &#123;``    ``int` `insertNum = nums[i];``    ``int` `insertIndex;``    ``for` `(insertIndex = i - ``1``; insertIndex &gt;= ``0` `&amp;&amp; nums[insertIndex] &gt; insertNum; insertIndex--) &#123;``      ``nums[insertIndex + ``1``] = nums[insertIndex];``    ``&#125;``    ``nums[insertIndex + ``1``] = insertNum;``  ``&#125;``&#125;</span><br></pre></td></tr></table></figure><p>直接插入没有利用到要插入的序列已有序的特点，插入第 i 个元素时可以通过二分查找找到插入位置 insertIndex，再把 i~insertIndex 之间的所有元素后移一位，把第 i 个元素放在插入位置上。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public` `void` `binaryInsertionSort(``int``[] nums) &#123;``  ``for` `(``int` `i = ``1``; i &lt; nums.length; i++) &#123;``    ``int` `insertNum = nums[i];``    ``int` `insertIndex = -``1``;``    ``int` `start = ``0``;``    ``int` `end = i - ``1``;``    ``while` `(start &lt;= end) &#123;``      ``int` `mid = start + (end - start) / ``2``;``      ``if` `(insertNum &gt; nums[mid])``        ``start = mid + ``1``;``      ``else` `if` `(insertNum &lt; nums[mid])``        ``end = mid - ``1``;``      ``else` `&#123;``        ``insertIndex = mid + ``1``;``        ``break``;``      ``&#125;``    ``&#125;``    ``if` `(insertIndex == -``1``)``      ``insertIndex = start;``    ``if` `(i - insertIndex &gt;= ``0``)``      ``System.arraycopy(nums, insertIndex, nums, insertIndex + ``1``, i - insertIndex);``    ``nums[insertIndex] = insertNum;``  ``&#125;``&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="Q3：希尔排序的原理？"><a href="#Q3：希尔排序的原理？" class="headerlink" title="Q3：希尔排序的原理？"></a>Q3：希尔<a href>排序</a>的原理？</h4><p>又称缩小增量<a href>排序</a>，是对直接插入<a href>排序</a>的改进，不稳定，平均时间复杂度 O(n^1.3^)，最差时间复杂度 O(n²)，最好时间复杂度 O(n)，空间复杂度 O(1)。</p><p>把记录按下标的一定增量分组，对每组进行直接插入<a href>排序</a>，每次<a href>排序</a>后减小增量，当增量减至 1 时<a href>排序</a>完毕。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public` `void` `shellSort(``int``[] nums) &#123;``  ``for` `(``int` `d = nums.length / ``2``; d &gt; ``0` `; d /= ``2``) &#123;``    ``for` `(``int` `i = d; i &lt; nums.length; i++) &#123;``      ``int` `insertNum = nums[i];``      ``int` `insertIndex;``      ``for` `(insertIndex = i - d; insertIndex &gt;= ``0` `&amp;&amp; nums[insertIndex] &gt; insertNum; insertIndex -= d) &#123;``        ``nums[insertIndex + d] = nums[insertIndex];``      ``&#125;``      ``nums[insertIndex + d] = insertNum;``    ``&#125;``  ``&#125;``&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="Q4：直接选择排序的原理？"><a href="#Q4：直接选择排序的原理？" class="headerlink" title="Q4：直接选择排序的原理？"></a>Q4：直接选择<a href>排序</a>的原理？</h4><p>不稳定，时间复杂度 O(n²)，空间复杂度 O(1)。</p><p>每次在未<a href>排序</a>序列中找到最小元素，和未<a href>排序</a>序列的第一个元素交换位置，再在剩余未<a href>排序</a>序列中重复该操作直到所有元素<a href>排序</a>完毕。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public` `void` `selectSort(``int``[] nums) &#123;``  ``int` `minIndex;``  ``for` `(``int` `index = ``0``; index &lt; nums.length - ``1``; index++)&#123;``    ``minIndex = index;``    ``for` `(``int` `i = index + ``1``;i &lt; nums.length; i++)&#123;``      ``if``(nums[i] &lt; nums[minIndex]) ``        ``minIndex = i;``    ``&#125;``    ``if` `(index != minIndex)&#123;``      ``swap(nums, index, minIndex);``    ``&#125;``  ``&#125;``&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="Q5：堆排序的原理？"><a href="#Q5：堆排序的原理？" class="headerlink" title="Q5：堆排序的原理？"></a>Q5：堆<a href>排序</a>的原理？</h4><p>是对直接选择<a href>排序</a>的改进，不稳定，时间复杂度 O(nlogn)，空间复杂度 O(1)。</p><p>将待<a href>排序</a>记录看作完全<a href>二叉树</a>，可以建立大根堆或小根堆，大根堆中每个节点的值都不小于它的子节点值，小根堆中每个节点的值都不大于它的子节点值。</p><p>以大根堆为例，在建堆时首先将最后一个节点作为当前节点，如果当前节点存在父节点且值大于父节点，就将当前节点和父节点交换。在移除时首先暂存根节点的值，然后用最后一个节点代替根节点并作为当前节点，如果当前节点存在子节点且值小于子节点，就将其与值较大的子节点进行交换，调整完堆后返回暂存的值。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public` `void` `add(``int``[] nums, ``int` `i, ``int` `num)&#123;``  ``nums[i] = num;``  ``int` `curIndex = i;``  ``while` `(curIndex &gt; ``0``) &#123;``    ``int` `parentIndex = (curIndex - ``1``) / ``2``;``    ``if` `(nums[parentIndex] &lt; nums[curIndex]) ``      ``swap(nums, parentIndex, curIndex);``    ``else` `break``;``    ``curIndex = parentIndex;``  ``&#125;``&#125;` `public` `int` `remove(``int``[] nums, ``int` `size)&#123;``  ``int` `result = nums[``0``];``  ``nums[``0``] = nums[size - ``1``];``  ``int` `curIndex = ``0``;``  ``while` `(``true``) &#123;``    ``int` `leftIndex = curIndex * ``2` `+ ``1``;``    ``int` `rightIndex = curIndex * ``2` `+ ``2``;``    ``if` `(leftIndex &gt;= size) ``break``;``    ``int` `maxIndex = leftIndex;``    ``if` `(rightIndex &lt; size &amp;&amp; nums[maxIndex] &lt; nums[rightIndex])``      ``maxIndex = rightIndex;``    ``if` `(nums[curIndex] &lt; nums[maxIndex])``      ``swap(nums, curIndex, maxIndex);``    ``else` `break``;``    ``curIndex = maxIndex;``  ``&#125;``  ``return` `result;``&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="Q6：冒泡排序的原理？"><a href="#Q6：冒泡排序的原理？" class="headerlink" title="Q6：冒泡排序的原理？"></a>Q6：冒泡<a href>排序</a>的原理？</h4><p>稳定，平均&#x2F;最坏时间复杂度 O(n²)，元素基本有序时最好时间复杂度 O(n)，空间复杂度 O(1)。</p><p>比较相邻的元素，如果第一个比第二个大就进行交换，对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对，每一轮<a href>排序</a>后末尾元素都是有序的，针对 n 个元素重复以上步骤 n -1 次<a href>排序</a>完毕。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public` `void` `bubbleSort(``int``[] nums) &#123;``  ``for` `(``int` `i = ``0``; i &lt; nums.length - ``1``; i++) &#123;``    ``for` `(``int` `index = ``0``; index &lt; nums.length - ``1` `- i; index++) &#123;``      ``if` `(nums[index] &gt; nums[index + ``1``]) ``        ``swap(nums, index, index + ``1``)``    ``&#125;``  ``&#125;``&#125;</span><br></pre></td></tr></table></figure><p>当序列已经有序时仍会进行不必要的比较，可以设置一个标志记录是否有元素交换，如果没有直接结束比较。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public` `void` `betterBubbleSort(``int``[] nums) &#123;``  ``boolean` `swap;``  ``for` `(``int` `i = ``0``; i &lt; nums.length - ``1``; i++) &#123;``    ``swap = ``true``;``    ``for` `(``int` `index = ``0``; index &lt; nums.length - ``1` `- i; index++) &#123;``      ``if` `(nums[index] &gt; nums[index + ``1``]) &#123;``        ``swap(nums, index ,index + ``1``);``        ``swap = ``false``;``      ``&#125;``    ``&#125;``    ``if` `(swap) ``break``;``  ``&#125;``&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="Q7：快速排序的原理？"><a href="#Q7：快速排序的原理？" class="headerlink" title="Q7：快速排序的原理？"></a>Q7：快速<a href>排序</a>的原理？</h4><p>是对冒泡<a href>排序</a>的一种改进，不稳定，平均&#x2F;最好时间复杂度 O(nlogn)，元素基本有序时最坏时间复杂度 O(n²)，空间复杂度 O(logn)。</p><p>首先选择一个基准元素，通过一趟<a href>排序</a>将要<a href>排序</a>的数据分割成独立的两部分，一部分全部小于等于基准元素，一部分全部大于等于基准元素，再按此方法递归对这两部分数据进行快速<a href>排序</a>。</p><p>快速<a href>排序</a>的一次划分从两头交替搜索，直到 low 和 high 指针重合，一趟时间复杂度 O(n)，整个<a href>算法</a>的时间复杂度与划分趟数有关。</p><p>最好情况是每次划分选择的中间数恰好将当前序列等分，经过 log(n) 趟划分便可得到长度为 1 的子表，这样时间复杂度 O(nlogn)。</p><p>最坏情况是每次所选中间数是当前序列中的最大或最小元素，这使每次划分所得子表其中一个为空表 ，这样长度为 n 的数据表需要 n 趟划分，整个<a href>排序</a>时间复杂度 O(n²)。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public` `void` `quickSort(``int``[] nums, ``int` `start, ``int` `end) &#123;``  ``if` `(start &lt; end) &#123;``    ``int` `pivotIndex = getPivotIndex(nums, start, end);``    ``quickSort(nums, start, pivotIndex - ``1``);``    ``quickSort(nums, pivotIndex + ``1``, end);``  ``&#125;``&#125;` `public` `int` `getPivotIndex(``int``[] nums, ``int` `start, ``int` `end) &#123;``  ``int` `pivot = nums[start];``  ``int` `low = start;``  ``int` `high = end;``  ``while` `(low &lt; high) &#123;``    ``while` `(low &lt;= high &amp;&amp; nums[low] &lt;= pivot) ``      ``low++;``    ``while` `(low &lt;= high &amp;&amp; nums[high] &gt; pivot) ``      ``high--;``    ``if` `(low &lt; high) ``      ``swap(nums, low, high);``  ``&#125;``  ``swap(nums, start, high);``  ``return` `high;``&#125;</span><br></pre></td></tr></table></figure><p><strong>优化：</strong>当规模足够小时，例如 <code>end - start &lt; 10</code> 时，采用直接插入<a href>排序</a>。</p><hr><h4 id="Q8：归并排序的原理？"><a href="#Q8：归并排序的原理？" class="headerlink" title="Q8：归并排序的原理？"></a>Q8：归并<a href>排序</a>的原理？</h4><p>归并<a href>排序</a>基于归并操作，是一种稳定的<a href>排序</a><a href>算法</a>，任何情况时间复杂度都为 O(nlogn)，空间复杂度为 O(n)。</p><p><strong>基本原理：</strong>应用分治法将待<a href>排序</a>序列分成两部分，然后对两部分分别递归<a href>排序</a>，最后进行合并，使用一个辅助空间并设定两个指针分别指向两个有序序列的起始元素，将指针对应的较小元素添加到辅助空间，重复该步骤到某一序列到达末尾，然后将另一序列剩余元素合并到辅助空间末尾。</p><p><strong>适用场景：</strong>数据量大且对稳定性有要求的情况。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int``[] help;` `public` `void` `mergeSort(``int``[] arr) &#123;``  ``int``[] help = ``new` `int``[arr.length];``  ``sort(arr, ``0``, arr.length - ``1``);``&#125;` `public` `void` `sort(``int``[] arr, ``int` `start, ``int` `end) &#123;``  ``if` `(start == end) ``return``;``  ``int` `mid = start + (end - start) / ``2``;``  ``sort(arr, start, mid);``  ``sort(arr, mid + ``1``, end);``  ``merge(arr, start, mid, end);``&#125;` `public` `void` `merge(``int``[] arr, ``int` `start, ``int` `mid, ``int` `end) &#123;``  ``if` `(end + ``1` `- start &gt;= ``0``) System.arraycopy(arr, start, help, start, end + ``1` `- start);``  ``int` `p = start;``  ``int` `q = mid + ``1``;``  ``int` `index = start;``  ``while` `(p &lt;= mid &amp;&amp; q &lt;= end) &#123;``    ``if` `(help[p] &lt; help[q]) ``      ``arr[index++] = help[p++];``    ``else``      ``arr[index++] = help[q++];``  ``&#125;``  ``while` `(p &lt;= mid) arr[index++] = help[p++];``  ``while` `(q &lt;= end) arr[index++] = help[q++];``&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="Q9：排序算法怎么选择？"><a href="#Q9：排序算法怎么选择？" class="headerlink" title="Q9：排序算法怎么选择？"></a>Q9：<a href>排序</a><a href>算法</a>怎么选择？</h4><p>数据量规模较小，考虑直接插入或直接选择。当元素分布有序时直接插入将大大减少比较和移动记录的次数，如果不要求稳定性，可以使用直接选择，效率略高于直接插入。</p><p>数据量规模中等，选择希尔<a href>排序</a>。</p><p>数据量规模较大，考虑堆<a href>排序</a>（元素分布接近正序或逆序）、快速<a href>排序</a>（元素分布随机）和归并<a href>排序</a>（稳定性）。</p><p>一般不使用冒泡。</p><hr><h2 id="设计模式-15"><a href="#设计模式-15" class="headerlink" title="设计模式 15"></a>设计模式 15</h2><h4 id="Q1：设计模式有哪些原则？"><a href="#Q1：设计模式有哪些原则？" class="headerlink" title="Q1：设计模式有哪些原则？"></a>Q1：设计模式有哪些原则？</h4><p><strong>开闭原则：</strong>OOP 中最基础的原则，指一个软件实体（类、模块、方法等）应该对扩展开放，对修改关闭。强调用抽象构建框架，用实现扩展细节，提高代码的可复用性和可维护性。</p><p><strong>单一职责原则：</strong>一个类、接口或方法只负责一个职责，降低代码复杂度以及变更引起的风险。</p><p><strong>依赖倒置原则：</strong>程序应该依赖于抽象类或接口，而不是具体的实现类。</p><p><strong>接口隔离原则：</strong>将不同功能定义在不同接口中实现接口隔离，避免了类依赖它不需要的接口，减少了接口之间依赖的冗余性和复杂性。</p><p><strong>里氏替换原则：</strong>开闭原则的补充，规定了任何父类可以出现的地方子类都一定可以出现，可以约束继承泛滥，加强程序健壮性。</p><p><strong>迪米特原则：</strong>也叫最少知道原则，每个模块对其他模块都要尽可能少地了解和依赖，降低代码耦合度。</p><p><strong>合成&#x2F;聚合原则：</strong>尽量使用组合(has-a)&#x2F;聚合(contains-a)而不是继承(is-a)达到软件复用的目的，避免滥用继承带来的方法污染和方法爆炸，方法污染指父类的行为通过继承传递给子类，但子类并不具备执行此行为的能力；方法爆炸指继承树不断扩大，底层类拥有的方法过于繁杂，导致很容易选择错误。</p><hr><h4 id="Q2：设计模式的分类，你知道哪些设计模式？"><a href="#Q2：设计模式的分类，你知道哪些设计模式？" class="headerlink" title="Q2：设计模式的分类，你知道哪些设计模式？"></a>Q2：设计模式的分类，你知道哪些设计模式？</h4><p><strong>创建型：</strong> 在创建对象的同时隐藏创建逻辑，不使用 new 直接实例化对象，程序在判断需要创建哪些对象时更灵活。包括工厂&#x2F;抽象工厂&#x2F;单例&#x2F;建造者&#x2F;原型模式。</p><p>**结构型： **通过类和接口间的继承和引用实现创建复杂结构的对象。包括适配器&#x2F;桥接模式&#x2F;过滤器&#x2F;组合&#x2F;装饰器&#x2F;外观&#x2F;享元&#x2F;代理模式。</p><p>**行为型： **通过类之间不同通信方式实现不同行为。包括责任链&#x2F;命名&#x2F;解释器&#x2F;迭代器&#x2F;中介者&#x2F;备忘录&#x2F;观察者&#x2F;状态&#x2F;策略&#x2F;模板&#x2F;访问者模式。</p><hr><h4 id="Q3：说一说简单工厂模式"><a href="#Q3：说一说简单工厂模式" class="headerlink" title="Q3：说一说简单工厂模式"></a>Q3：说一说简单工厂模式</h4><p>简单工厂模式指由一个工厂对象来创建实例，<a href>客户端</a>不需要关注创建逻辑，只需提供传入工厂的参数。</p><p>适用于工厂类负责创建对象较少的情况，缺点是如果要增加新产品，就需要修改工厂类的判断逻辑，违背开闭原则，且产品多的话会使工厂类比较复杂。</p><p>Calendar 抽象类的 <code>getInstance</code> 方法，调用 <code>createCalendar</code> 方法根据不同的地区参数创建不同的日历对象。</p><p>Spring 中的 BeanFactory 使用简单工厂模式，根据传入一个唯一的标识来获得 Bean 对象。</p><hr><h4 id="Q4：说一说工厂方法模式"><a href="#Q4：说一说工厂方法模式" class="headerlink" title="Q4：说一说工厂方法模式"></a>Q4：说一说工厂方法模式</h4><p>工厂方法模式指定义一个创建对象的接口，让接口的实现类决定创建哪种对象，让类的实例化推迟到子类中进行。</p><p><a href>客户端</a>只需关心对应工厂而无需关心创建细节，主要解决了产品扩展的问题，在简单工厂模式中如果产品种类变多，工厂的职责会越来越多，不便于维护。</p><p>Collection 接口这个抽象工厂中定义了一个抽象的 <code>iterator</code> 工厂方法，返回一个 Iterator 类的抽象产品。该方法通过 ArrayList 、HashMap 等具体工厂实现，返回 Itr、KeyIterator 等具体产品。</p><p>Spring 的 FactoryBean 接口的 <code>getObject</code> 方法也是工厂方法。</p><hr><h4 id="Q5：抽象工厂模式了解吗？"><a href="#Q5：抽象工厂模式了解吗？" class="headerlink" title="Q5：抽象工厂模式了解吗？"></a>Q5：抽象工厂模式了解吗？</h4><p>抽象工厂模式指提供一个创建一系列相关或相互依赖对象的接口，无需指定它们的具体类。</p><p><a href>客户端</a>不依赖于产品类实例如何被创建和实现的细节，主要用于系统的产品有多于一个的产品族，而系统只消费其中某一个产品族产品的情况。抽象工厂模式的缺点是不方便扩展产品族，并且增加了系统的抽象性和理解难度。</p><p>java.sql.Connection 接口就是一个抽象工厂，其中包括很多抽象产品如 Statement、Blob、Savepoint 等。</p><hr><p>作者：是瑶瑶公主吖<br>链接：<a href="https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post">https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post</a><br>来源：牛客网</p><hr><h4 id="Q6：单例模式的特点是什么？"><a href="#Q6：单例模式的特点是什么？" class="headerlink" title="Q6：单例模式的特点是什么？"></a>Q6：单例模式的特点是什么？</h4><p>单例模式属于创建型模式，一个单例类在任何情况下都只存在一个实例，构造方法必须是私有的、由自己创建一个静态变量存储实例，对外提供一个静态公有方法获取实例。</p><p>优点是内存中只有一个实例，减少了开销，尤其是频繁创建和销毁实例的情况下并且可以避免对资源的多重占用。缺点是没有抽象层，难以扩展，与单一职责原则冲突。</p><p>Spring 的 ApplicationContext 创建的 Bean 实例都是单例对象，还有 ServletContext、数据库连接池等也都是单例模式。</p><hr><h4 id="Q7：单例模式有哪些实现？"><a href="#Q7：单例模式有哪些实现？" class="headerlink" title="Q7：单例模式有哪些实现？"></a>Q7：单例模式有哪些实现？</h4><p><strong>饿汉式：</strong>在类加载时就初始化创建单例对象，线程安全，但不管是否使用都创建对象可能会浪费内存。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public` `class` `HungrySingleton &#123;``  ``private` `HungrySingleton()&#123;&#125;` `  ``private` `static` `HungrySingleton instance = ``new` `HungrySingleton();` `  ``public` `static` `HungrySingleton getInstance() &#123;``    ``return` `instance;``  ``&#125;``&#125;</span><br></pre></td></tr></table></figure><p><strong>懒汉式：</strong>在外部调用时才会加载，线程不安全，可以加锁保证线程安全但效率低。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public` `class` `LazySingleton &#123;``  ``private` `LazySingleton()&#123;&#125;` `  ``private` `static` `LazySingleton instance;` `  ``public` `static` `LazySingleton getInstance() &#123;``    ``if``(instance == ``null``) &#123;``      ``instance = ``new` `LazySingleton();``    ``&#125;``    ``return` `instance;``  ``&#125;``&#125;</span><br></pre></td></tr></table></figure><p><strong>双重检查锁：</strong>使用 volatile 以及多重检查来减小锁范围，提升效率。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public` `class` `DoubleCheckSingleton &#123;``  ``private` `DoubleCheckSingleton()&#123;&#125;` `  ``private` `volatile` `static` `DoubleCheckSingleton instance;` `  ``public` `static` `DoubleCheckSingleton getInstance() &#123;``    ``if``(instance == ``null``) &#123;``      ``synchronized` `(DoubleCheckSingleton.``class``) &#123;``        ``if` `(instance == ``null``) &#123;``          ``instance = ``new` `DoubleCheckSingleton();``        ``&#125;``      ``&#125;``    ``&#125;``    ``return` `instance;``  ``&#125;``&#125;</span><br></pre></td></tr></table></figure><p><strong>静态内部类：</strong>同时解决饿汉式的内存浪费问题和懒汉式的线程安全问题。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public` `class` `StaticSingleton &#123;``  ``private` `StaticSingleton()&#123;&#125;` `  ``public` `static` `StaticSingleton getInstance() &#123;``    ``return` `StaticClass.instance;``  ``&#125;` `  ``private` `static` `class` `StaticClass &#123;``    ``private` `static` `final` `StaticSingleton instance = ``new` `StaticSingleton();``  ``&#125;``&#125;</span><br></pre></td></tr></table></figure><p><strong>枚举：</strong>《Effective Java》提倡的方式，不仅能避免线程安全问题，还能防止反序列化重新创建新的对象，绝对防止多次实例化，也能防止反射破解单例的问题。</p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public` `enum` `EnumSingleton &#123;``  ``INSTANCE;``&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="Q8：讲一讲代理模式"><a href="#Q8：讲一讲代理模式" class="headerlink" title="Q8：讲一讲代理模式"></a>Q8：讲一讲代理模式</h4><p>代理模式属于结构型模式，为其他对象提供一种代理以控制对这个对象的访问。优点是可以增强目标对象的功能，降低代码耦合度，扩展性好。缺点是在<a href>客户端</a>和目标对象之间增加代理对象会导致请求处理速度变慢，增加系统复杂度。</p><p>Spring 利用动态代理实现 AOP，如果 Bean 实现了接口就使用 JDK 代理，否则使用 CGLib 代理。</p><p><strong>静态代理：</strong>代理对象持有被代理对象的引用，调用代理对象方法时也会调用被代理对象的方法，但是会在被代理对象方法的前后增加其他逻辑。需要手动完成，在程序运行前就已经存在代理类的字节码文件，代理类和被代理类的关系在运行前就已经确定了。 缺点是一个代理类只能为一个目标服务，如果要服务多种类型会增加工作量。</p><p><strong>动态代理：</strong>动态代理在程序运行时通过反射创建具体的代理类，代理类和被代理类的关系在运行前是不确定的。动态代理的适用性更强，主要分为 JDK 动态代理和 CGLib 动态代理。</p><ul><li><strong>JDK 动态代理：</strong>通过 <code>Proxy</code> 类的 <code>newInstance</code> 方法获取一个动态代理对象，需要传入三个参数，被代理对象的类加载器、被代理对象实现的接口，以及一个 <code>InvocationHandler</code> 调用处理器来指明具体的逻辑，相比静态代理的优势是接口中声明的所有方法都被转移到 <code>InvocationHandler</code> 的 <code>invoke</code> 方法集中处理。 </li><li><strong>CGLib 动态代理：</strong>JDK 动态代理要求实现被代理对象的接口，而 CGLib 要求继承被代理对象，如果一个类是 final 类则不能使用 CGLib 代理。两种代理都在运行期生成字节码，JDK 动态代理直接写字节码，而 CGLib 动态代理使用 ASM 框架写字节码，ASM 的目的是生成、转换和分析以字节数组表示的已编译 Java 类。 JDK 动态代理调用代理方法通过反射机制实现，而 GCLib 动态代理通过 FastClass 机制直接调用方法，它为代理类和被代理类各生成一个类，该类为代理类和被代理类的方法分配一个 int 参数，调用方法时可以直接定位，因此调用效率更高。</li></ul><hr><h4 id="Q9：讲一讲装饰器模式"><a href="#Q9：讲一讲装饰器模式" class="headerlink" title="Q9：讲一讲装饰器模式"></a>Q9：讲一讲装饰器模式</h4><p>装饰器模式属于结构型模式，在不改变原有对象的基础上将功能附加到对象，相比继承可以更加灵活地扩展原有对象的功能。</p><p>装饰器模式适合的场景：在不想增加很多子类的前提下扩展一个类的功能。</p><p>java.io 包中，InputStream 字节输入流通过装饰器 BufferedInputStream 增强为缓冲字节输入流。</p><hr><h4 id="Q10：装饰器模式和动态代理的区别？"><a href="#Q10：装饰器模式和动态代理的区别？" class="headerlink" title="Q10：装饰器模式和动态代理的区别？"></a>Q10：装饰器模式和动态代理的区别？</h4><p>装饰器模式的关注点在于给对象动态添加方法，而动态代理更注重对象的访问控制。动态代理通常会在代理类中创建被代理对象的实例，而装饰器模式会将装饰者作为构造方法的参数。</p><hr><h4 id="Q11：讲一讲适配器模式"><a href="#Q11：讲一讲适配器模式" class="headerlink" title="Q11：讲一讲适配器模式"></a>Q11：讲一讲适配器模式</h4><p>适配器模式属于结构型模式，它作为两个不兼容接口之间的桥梁，结合了两个独立接口的功能，将一个类的接口转换成另外一个接口使得原本由于接口不兼容而不能一起工作的类可以一起工作。 </p><p>缺点是过多使用适配器会让系统非常混乱，不易整体把握。</p><p>java.io 包中，InputStream 字节输入流通过适配器 InputStreamReader 转换为 Reader 字符输入流。</p><p>Spring MVC 中的 HandlerAdapter，由于 handler 有很多种形式，包括 Controller、HttpRequestHandler、Servlet 等，但调用方式又是确定的，因此需要适配器来进行处理，根据适配规则调用 handle 方法。</p><p>Arrays.asList 方法，将数组转换为对应的集合（注意不能使用修改集合的方法，因为返回的 ArrayList 是 Arrays 的一个内部类）。</p><hr><h4 id="Q12：适配器模式和和装饰器模式以及代理模式的区别？"><a href="#Q12：适配器模式和和装饰器模式以及代理模式的区别？" class="headerlink" title="Q12：适配器模式和和装饰器模式以及代理模式的区别？"></a>Q12：适配器模式和和装饰器模式以及代理模式的区别？</h4><p>适配器模式没有层级关系，适配器和被适配者没有必然连续，满足 has-a 的关系，解决不兼容的问题，是一种后置考虑。</p><p>装饰器模式具有层级关系，装饰器与被装饰者实现同一个接口，满足 is-a 的关系，注重覆盖和扩展，是一种前置考虑。</p><p>适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</p><hr><h4 id="Q13：讲一讲策略模式"><a href="#Q13：讲一讲策略模式" class="headerlink" title="Q13：讲一讲策略模式"></a>Q13：讲一讲策略模式</h4><p>策略模式属于行为型模式，定义了一系列<a href>算法</a>并封装起来，之间可以互相替换。策略模式主要解决在有多种<a href>算法</a>相似的情况下，使用 if&#x2F;else 所带来的难以维护。</p><p>优点是<a href>算法</a>可以自由切换，可以避免使用多重条件判断并且扩展性良好，缺点是策略类会增多并且所有策略类都需要对外暴露。</p><p>在集合框架中，经常需要通过构造方法传入一个比较器 Comparator 进行比较<a href>排序</a>。Comparator 就是一个抽象策略，一个类通过实现该接口并重写 compare 方法成为具体策略类。</p><p>创建线程池时，需要传入拒绝策略，当创建新线程使当前运行的线程数超过 maximumPoolSize 时会使用相应的拒绝策略处理。</p><hr><h4 id="Q14：讲一讲模板模式"><a href="#Q14：讲一讲模板模式" class="headerlink" title="Q14：讲一讲模板模式"></a>Q14：讲一讲模板模式</h4><p>模板模式属于行为型模式，使子类可以在不改变<a href>算法</a>结构的情况下重新定义<a href>算法</a>的某些步骤，适用于抽取子类重复代码到公共父类。</p><p>优点是可以封装固定不变的部分，扩展可变的部分。缺点是每一个不同实现都需要一个子类维护，会增加类的数量。</p><p>为防止恶意操作，一般模板方法都以 final 修饰。</p><p>HttpServlet 定义了一套处理 HTTP 请求的模板，service 方法为模板方法，定义了处理HTTP请求的基本流程，doXXX 等方法为基本方法，根据请求方法的类型做相应的处理，子类可重写这些方法。</p><hr><h4 id="Q15：讲一讲观察者模式"><a href="#Q15：讲一讲观察者模式" class="headerlink" title="Q15：讲一讲观察者模式"></a>Q15：讲一讲观察者模式</h4><p>观察者模式属于行为型模式，也叫发布订阅模式，定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。主要解决一个对象状态改变给其他对象通知的问题，缺点是如果被观察者对象有很多的直接和间接观察者的话通知很耗时， 如果存在循环依赖的话可能导致系统崩溃，另外观察者无法知道目标对象具体是怎么发生变化的。</p><p>ServletContextListener 能够监听 ServletContext 对象的生命周期，实际上就是监听 Web 应用。当 Servlet 容器启动 Web 应用时调用 <code>contextInitialized</code> 方法，终止时调用 <code>contextDestroyed</code> 方法。</p><hr><h2 id="MySQL-33"><a href="#MySQL-33" class="headerlink" title="MySQL 33"></a>MySQL 33</h2><p>作者：是瑶瑶公主吖<br>链接：<a href="https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post">https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post</a><br>来源：牛客网</p><h3 id="逻辑架构-13"><a href="#逻辑架构-13" class="headerlink" title="逻辑架构 13"></a>逻辑架构 13</h3><h4 id="Q1：MySQL-的逻辑架构了解吗？"><a href="#Q1：MySQL-的逻辑架构了解吗？" class="headerlink" title="Q1：MySQL 的逻辑架构了解吗？"></a>Q1：MySQL 的逻辑架构了解吗？</h4><p>第一层是服务器层，主要提供连接处理、授权认证、安全等功能。</p><p>第二层实现了 MySQL 核心服务功能，包括查询解析、分析、优化、缓存以及日期和时间等所有内置函数，所有跨存储引擎的功能都在这一层实现，例如存储过程、触发器、视图等。</p><p>第三层是存储引擎层，存储引擎负责 MySQL 中数据的存储和提取。服务器通过 API 与存储引擎通信，这些接口屏蔽了不同存储引擎的差异，使得差异对上层查询过程透明。除了会解析外键定义的 InnoDB 外，存储引擎不会解析 SQL，不同存储引擎之间也不会相互通信，只是简单响应上层服务器请求。</p><hr><h4 id="Q2：谈一谈-MySQL-的读写锁"><a href="#Q2：谈一谈-MySQL-的读写锁" class="headerlink" title="Q2：谈一谈 MySQL 的读写锁"></a>Q2：谈一谈 MySQL 的读写锁</h4><p>在处理并发读或写时，可以通过实现一个由两种类型组成的锁系统来解决问题。这两种类型的锁通常被称为共享锁和排它锁，也叫读锁和写锁。读锁是共享的，相互不阻塞，多个客户在同一时刻可以同时读取同一个资源而不相互干扰。写锁则是排他的，也就是说一个写锁会阻塞其他的写锁和读锁，确保在给定时间内只有一个用户能执行写入并防止其他用户读取正在写入的同一资源。</p><p>在实际的数据库系统中，每时每刻都在发生锁定，当某个用户在修改某一部分数据时，MySQL 会通过锁定防止其他用户读取同一数据。写锁比读锁有更高的优先级，一个写锁请求可能会被插入到读锁队列的前面，但是读锁不能插入到写锁前面。</p><hr><h4 id="Q3：MySQL-的锁策略有什么？"><a href="#Q3：MySQL-的锁策略有什么？" class="headerlink" title="Q3：MySQL 的锁策略有什么？"></a>Q3：MySQL 的锁策略有什么？</h4><p><strong>表锁</strong>是MySQL中最基本的锁策略，并且是开销最小的策略。表锁会锁定整张表，一个用户在对表进行写操作前需要先获得写锁，这会阻塞其他用户对该表的所有读写操作。只有没有写锁时，其他读取的用户才能获取读锁，读锁之间不相互阻塞。</p><p><strong>行锁</strong>可以最大程度地支持并发，同时也带来了最大开销。InnoDB 和 XtraDB 以及一些其他存储引擎实现了行锁。行锁只在存储引擎层实现，而服务器层没有实现。</p><hr><h4 id="Q4：数据库死锁如何解决？"><a href="#Q4：数据库死锁如何解决？" class="headerlink" title="Q4：数据库死锁如何解决？"></a>Q4：数据库死锁如何解决？</h4><p>死锁是指多个事务在同一资源上相互占用并请求锁定对方占用的资源而导致恶性循环的现象。当多个事务试图以不同顺序锁定资源时就可能会产生死锁，多个事务同时锁定同一个资源时也会产生死锁。</p><p>为了解决死锁问题，数据库系统实现了各种死锁检测和死锁超时机制。越复杂的系统，例如InnoDB 存储引擎，越能检测到死锁的循环依赖，并立即返回一个错误。这种解决方式很有效，否则死锁会导致出现非常慢的查询。还有一种解决方法，就是当查询的时间达到锁等待超时的设定后放弃锁请求，这种方式通常来说不太好。InnoDB 目前处理死锁的方法是将持有最少行级排它锁的事务进行回滚。</p><p>死锁发生之后，只有部分或者完全回滚其中一个事务，才能打破死锁。对于事务型系统这是无法避免的，所以应用程序在设计时必须考虑如何处理死锁。大多数情况下只需要重新执行因死锁回滚的事务即可。</p><hr><h4 id="Q5：事务是什么"><a href="#Q5：事务是什么" class="headerlink" title="Q5：事务是什么?"></a>Q5：事务是什么?</h4><p>事务是一组原子性的 SQL 查询，或者说一个独立的工作单元。如果数据库引擎能够成功地对数据库应用该组查询的全部语句，那么就执行该组查询。如果其中有任何一条语句因为崩溃或其他原因无法执行，那么所有的语句都不会执行。也就是说事务内的语句要么全部执行成功，要么全部执行失败。</p><hr><h4 id="Q6：事务有什么特性？"><a href="#Q6：事务有什么特性？" class="headerlink" title="Q6：事务有什么特性？"></a>Q6：事务有什么特性？</h4><p><strong>原子性 atomicity</strong></p><p>一个事务在逻辑上是必须不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败回滚，对于一个事务来说不可能只执行其中的一部分。</p><p><strong>一致性 consistency</strong></p><p>数据库总是从一个一致性的状态转换到另一个一致性的状态。</p><p><strong>隔离性 isolation</strong></p><p>针对并发事务而言，隔离性就是要隔离并发运行的多个事务之间的相互影响，一般来说一个事务所做的修改在最终提交以前，对其他事务是不可见的。</p><p><strong>持久性 durability</strong></p><p>一旦事务提交成功，其修改就会永久保存到数据库中，此时即使系统崩溃，修改的数据也不会丢失。</p><hr><h4 id="Q7：MySQL-的隔离级别有哪些？"><a href="#Q7：MySQL-的隔离级别有哪些？" class="headerlink" title="Q7：MySQL 的隔离级别有哪些？"></a>Q7：MySQL 的隔离级别有哪些？</h4><p><strong>未提交读 READ UNCOMMITTED</strong></p><p>在该级别事务中的修改即使没有被提交，对其他事务也是可见的。事务可以读取其他事务修改完但未提交的数据，这种问题称为脏读。这个级别还会导致不可重复读和幻读，性能没有比其他级别好很多，很少使用。</p><p><strong>提交读 READ COMMITTED</strong></p><p>多数数据库系统默认的隔离级别。提交读满足了隔离性的简单定义：一个事务开始时只能”看见”已经提交的事务所做的修改。换句话说，一个事务从开始直到提交之前的任何修改对其他事务都是不可见的。也叫不可重复读，因为两次执行同样的查询可能会得到不同结果。</p><p><strong>可重复读 REPEATABLE READ</strong>（MySQL默认的隔离级别）</p><p>可重复读解决了不可重复读的问题，保证了在同一个事务中多次读取同样的记录结果一致。但还是无法解决幻读，所谓幻读指的是当某个事务在读取某个范围内的记录时，会产生幻行。InnoDB 存储引擎通过多版本并发控制MVCC 解决幻读的问题。</p><p><strong>可串行化 SERIALIZABLE</strong></p><p>最高的隔离级别，通过强制事务串行执行，避免幻读。可串行化会在读取的每一行数据上都加锁，可能导致大量的超时和锁争用的问题。实际应用中很少用到这个隔离级别，只有非常需要确保数据一致性且可以接受没有并发的情况下才考虑该级别。</p><hr><h4 id="Q8：MVCC-是什么？"><a href="#Q8：MVCC-是什么？" class="headerlink" title="Q8：MVCC 是什么？"></a>Q8：MVCC 是什么？</h4><p>MVCC 是多版本并发控制，在很多情况下避免加锁，大都实现了非阻塞的读操作，写操作也只锁定必要的行。</p><p>InnoDB 的MVCC 通过在每行记录后面保存两个隐藏的列来实现，这两个列一个保存了行的创建时间，一个保存行的过期时间间。不过存储的不是实际的时间值而是系统版本号，每开始一个新的事务系统版本号都会自动递增，事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。</p><p>MVCC 只能在 <code>READ COMMITTED</code> 和 <code>REPEATABLE READ</code> 两个隔离级别下工作，因为 <code>READ UNCOMMITTED</code> 总是读取最新的数据行，而不是符合当前事务版本的数据行，而 <code>SERIALIZABLE</code> 则会对所有读取的行都加锁。</p><hr><h4 id="Q9：谈一谈-InnoDB"><a href="#Q9：谈一谈-InnoDB" class="headerlink" title="Q9：谈一谈 InnoDB"></a>Q9：谈一谈 InnoDB</h4><p>InnoDB 是 MySQL 的默认事务型引擎，用来处理大量短期事务。InnoDB 的性能和自动崩溃恢复特性使得它在非事务型存储需求中也很流行，除非有特别原因否则应该优先考虑 InnoDB。</p><p>InnoDB 的数据存储在表空间中，表空间由一系列数据文件组成。MySQL4.1 后 InnoDB 可以将每个表的数据和索引放在单独的文件中。</p><p>InnoDB 采用 MVCC 来支持高并发，并且实现了四个标准的隔离级别。其默认级别是 <code>REPEATABLE READ</code>，并通过间隙锁策略防止幻读，间隙锁使 InnoDB 不仅仅锁定查询涉及的行，还会对索引中的间隙进行锁定防止幻行的插入。</p><p>InnoDB 表是基于聚簇索引建立的，InnoDB 的索引结构和其他存储引擎有很大不同，聚簇索引对主键查询有很高的性能，不过它的二级索引中必须包含主键列，所以如果主键很大的话其他所有索引都会很大，因此如果表上索引较多的话主键应当尽可能小。</p><p>InnoDB 的存储格式是平***立的，可以将数据和索引文件从一个平台复制到另一个平台。</p><p>InnoDB 内部做了很多优化，包括从磁盘读取数据时采用的可预测性预读，能够自动在内存中创建加速读操作的自适应哈希索引，以及能够加速插入操作的插入缓冲区等。</p><hr><h4 id="Q10：谈一谈-MyISAM"><a href="#Q10：谈一谈-MyISAM" class="headerlink" title="Q10：谈一谈 MyISAM"></a>Q10：谈一谈 MyISAM</h4><p>MySQL5.1及之前，MyISAM 是默认存储引擎，MyISAM 提供了大量的特性，包括全文索引、压缩、空间函数等，但不支持事务和行锁，最大的缺陷就是崩溃后无法安全恢复。对于只读的数据或者表比较小、可以忍受修复操作的情况仍然可以使用 MyISAM。</p><p>MyISAM 将表存储在数据文件和索引文件中，分别以 <code>.MYD</code> 和 <code>.MYI</code> 作为扩展名。MyISAM 表可以包含动态或者静态行，MySQL 会根据表的定义决定行格式。MyISAM 表可以存储的行记录数一般受限于可用磁盘空间或者操作系统中单个文件的最大尺寸。</p><p>MyISAM 对整张表进行加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但是在表有读取查询的同时，也支持并发往表中插入新的记录。</p><p>对于MyISAM 表，MySQL 可以手动或自动执行检查和修复操作，这里的修复和事务恢复以及崩溃恢复的概念不同。执行表的修复可能导致一些数据丢失，而且修复操作很慢。</p><p>对于 MyISAM 表，即使是 BLOB 和 TEXT 等长字段，也可以基于其前 500 个字符创建索引。MyISAM 也支持全文索引，这是一种基于分词创建的索引，可以支持复杂的查询。</p><p>MyISAM 设计简单，数据以紧密格式存储，所以在某些场景下性能很好。MyISAM 最典型的性能问题还是表锁问题，如果所有的查询长期处于 Locked 状态，那么原因毫无疑问就是表锁。</p><hr><h4 id="Q12：谈一谈-Memory"><a href="#Q12：谈一谈-Memory" class="headerlink" title="Q12：谈一谈 Memory"></a>Q12：谈一谈 Memory</h4><p>如果需要快速访问数据且这些数据不会被修改，重启以后丢失也没有关系，那么使用 Memory 表是非常有用的。Memory 表至少要比 MyISAM 表快一个数量级，因为所有数据都保存在内存，不需要磁盘 IO，Memory 表的结构在重启后会保留，但数据会丢失。</p><p>Memory 表适合的场景：查找或者映射表、缓存周期性聚合数据的结果、保存<a href>数据分析</a>中产生的中间数据。</p><p>Memory 表支持哈希索引，因此查找速度极快。虽然速度很快但还是无法取代传统的基于磁盘的表，Memory 表使用表级锁，因此并发写入的性能较低。它不支持 BLOB 和 TEXT 类型的列，并且每行的长度是固定的，所以即使指定了 VARCHAR 列，实际存储时也会转换成CHAR，这可能导致部分内存的浪费。</p><p>如果 MySQL 在执行查询的过程中需要使用临时表来保持中间结果，内部使用的临时表就是 Memory 表。如果中间结果太大超出了Memory 表的限制，或者含有 BLOB 或 TEXT 字段，临时表会转换成 MyISAM 表。</p><hr><h4 id="Q13：查询执行流程是什么？"><a href="#Q13：查询执行流程是什么？" class="headerlink" title="Q13：查询执行流程是什么？"></a>Q13：查询执行流程是什么？</h4><p>简单来说分为五步：① <a href>客户端</a>发送一条查询给服务器。② 服务器先检查查询缓存，如果命中了缓存则立刻返回存储在缓存中的结果，否则进入下一阶段。③ 服务器端进行 SQL 解析、预处理，再由优化器生成对应的执行计划。④ MySQL 根据优化器生成的执行计划，调用存储引擎的 API 来执行查询。⑤ 将结果返回给<a href>客户端</a>。 </p><hr><h3 id="数据类型-3作者：是瑶瑶公主吖"><a href="#数据类型-3作者：是瑶瑶公主吖" class="headerlink" title="数据类型 3作者：是瑶瑶公主吖"></a>数据类型 3作者：是瑶瑶公主吖</h3><p>链接：<a href="https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post">https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post</a><br>来源：牛客网</p><h4 id="Q1：VARCHAR-和-CHAR-的区别？"><a href="#Q1：VARCHAR-和-CHAR-的区别？" class="headerlink" title="Q1：VARCHAR 和 CHAR 的区别？"></a>Q1：VARCHAR 和 CHAR 的区别？</h4><p><strong>VARCHAR</strong> 用于存储可变字符串，是最常见的字符串数据类型。它比 CHAR 更节省空间，因为它仅使用必要的空间。VARCHAR 需要 1 或 2 个额外字节记录字符串长度，如果列的最大长度不大于 255 字节则只需要 1 字节。VARCHAR 不会删除末尾空格。</p><p>VARCHAR 适用场景：字符串列的最大长度比平均长度大很多、列的更新很少、使用了 UTF8 这种复杂字符集，每个字符都使用不同的字节数存储。</p><p><strong>CHAR</strong> 是定长的，根据定义的字符串长度分配足够的空间。CHAR 会删除末尾空格。</p><p>CHAR 适合存储很短的字符串，或所有值都接近同一个长度，例如存储密码的 MD5 值。对于经常变更的数据，CHAR 也比 VARCHAR更好，因为定长的 CHAR 不容易产生碎片。对于非常短的列，CHAR 在存储空间上也更有效率，例如用 CHAR 来存储只有 Y 和 N 的值只需要一个字节，但是 VARCHAR 需要两个字节，因为还有一个记录长度的额外字节。</p><hr><h4 id="Q2：DATETIME-和-TIMESTAMP-的区别？"><a href="#Q2：DATETIME-和-TIMESTAMP-的区别？" class="headerlink" title="Q2：DATETIME 和 TIMESTAMP 的区别？"></a>Q2：DATETIME 和 TIMESTAMP 的区别？</h4><p><strong>DATETIME</strong> 能保存大范围的值，从 1001~9999 年，精度为秒。把日期和时间封装到了一个整数中，与时区无关，使用 8 字节存储空间。</p><p><strong>TIMESTAMP</strong> 和 UNIX 时间戳相同，只使用 4 字节的存储空间，范围比 DATETIME 小得多，只能表示 1970 ~2038 年，并且依赖于时区。</p><hr><h4 id="Q3：数据类型有哪些优化策略？"><a href="#Q3：数据类型有哪些优化策略？" class="headerlink" title="Q3：数据类型有哪些优化策略？"></a>Q3：数据类型有哪些优化策略？</h4><p><strong>更小的通常更好</strong></p><p>一般情况下尽量使用可以正确存储数据的最小数据类型，更小的数据类型通常也更快，因为它们占用更少的磁盘、内存和 CPU 缓存。</p><p><strong>尽可能简单</strong></p><p>简单数据类型的操作通常需要更少的 CPU 周期，例如整数比字符操作代价更低，因为字符集和校对规则使字符相比整形更复杂。应该使用 MySQL 的内建类型 date、time 和 datetime 而不是字符串来存储日期和时间，另一点是应该使用整形存储 IP 地址。</p><p><strong>尽量避免 NULL</strong></p><p>通常情况下最好指定列为 NOT NULL，除非需要存储 NULL值。因为如果查询中包含可为 NULL 的列对 MySQL 来说更难优化，可为 NULL 的列使索引、索引统计和值比较都更复杂，并且会使用更多存储空间。当可为 NULL 的列被索引时，每个索引记录需要一个额外字节，在MyISAM 中还可能导致固定大小的索引变成可变大小的索引。</p><p>如果计划在列上建索引，就应该尽量避免设计成可为 NULL 的列。</p><hr><h3 id="索引-10"><a href="#索引-10" class="headerlink" title="索引 10"></a>索引 10</h3><h4 id="Q1：索引有什么作用？"><a href="#Q1：索引有什么作用？" class="headerlink" title="Q1：索引有什么作用？"></a>Q1：索引有什么作用？</h4><p>索引也叫键，是存储引擎用于快速找到记录的一种数据结构。索引对于良好的性能很关键，尤其是当表中数据量越来越大时，索引对性能的影响愈发重要。在数据量较小且负载较低时，不恰当的索引对性能的影响可能还不明显，但数据量逐渐增大时，性能会急剧下降。</p><p>索引大大减少了服务器需要扫描的数据量、可以帮助服务器避免<a href>排序</a>和临时表、可以将随机 IO 变成顺序 IO。但索引并不总是最好的工具，对于非常小的表，大部分情况下会采用全表扫描。对于中到大型的表，索引就非常有效。但对于特大型的表，建立和使用索引的代价也随之增长，这种情况下应该使用分区技术。</p><p>在MySQL中，首先在索引中找到对应的值，然后根据匹配的索引记录找到对应的数据行。索引可以包括一个或多个列的值，如果索引包含多个列，那么列的顺序也十分重要，因为 MySQL 只能使用索引的最左前缀。</p><hr><h4 id="Q2：谈一谈-MySQL-的-B-Tree-索引"><a href="#Q2：谈一谈-MySQL-的-B-Tree-索引" class="headerlink" title="Q2：谈一谈 MySQL 的 B-Tree 索引"></a>Q2：谈一谈 MySQL 的 B-Tree 索引</h4><p>大多数 MySQL 引擎都支持这种索引，但底层的存储引擎可能使用不同的存储结构，例如 NDB 使用 T-Tree，而 InnoDB 使用 B+ Tree。</p><p>B-Tree 通常意味着所有的值都是按顺序存储的，并且每个叶子页到根的距离相同。B-Tree 索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中存放了指向子节点的指针，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子节点，这些指针实际上定义了子节点页中值的上限和下限。最终存储引擎要么找到对应的值，要么该记录不存在。叶子节点的指针指向的是被索引的数据，而不是其他的节点页。</p><p>B-Tree索引的限制：</p><ul><li>如果不是按照索引的最左列开始查找，则无法使用索引。 </li><li>不能跳过索引中的列，例如索引为 (id,name,sex)，不能只使用 id 和 sex 而跳过 name。 </li><li>如果查询中有某个列的范围查询，则其右边的所有列都无法使用索引。</li></ul><hr><h4 id="Q3：了解-Hash-索引吗？"><a href="#Q3：了解-Hash-索引吗？" class="headerlink" title="Q3：了解 Hash 索引吗？"></a>Q3：了解 Hash 索引吗？</h4><p>哈希索引基于<a href>哈希表</a>实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码，哈希码是一个较小的值，并且不同键值的行计算出的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在<a href>哈希表</a>中保存指向每个数据行的指针。</p><p>只有 Memory 引擎显式支持哈希索引，这也是 Memory 引擎的默认索引类型。</p><p>因为索引自身只需存储对应的哈希值，所以索引的结构十分紧凑，这让哈希索引的速度非常快，但它也有一些限制：</p><ul><li>哈希索引数据不是按照索引值顺序存储的，无法用于<a href>排序</a>。 </li><li>哈希索引不支持部分索引列匹配查找，因为哈希索引始终是使用索引列的全部内容来计算哈希值的。例如在数据列(a,b)上建立哈希索引，如果查询的列只有a就无法使用该索引。 </li><li>哈希索引只支持等值比较查询，不支持任何范围查询。</li></ul><hr><h4 id="Q4：什么是自适应哈希索引？"><a href="#Q4：什么是自适应哈希索引？" class="headerlink" title="Q4：什么是自适应哈希索引？"></a>Q4：什么是自适应哈希索引？</h4><p>自适应哈希索引是 InnoDB 引擎的一个特殊功能，当它注意到某些索引值被使用的非常频繁时，会在内存中基于 B-Tree 索引之上再创键一个哈希索引，这样就让 B-Tree 索引也具有哈希索引的一些优点，比如快速哈希查找。这是一个完全自动的内部行为，用户无法控制或配置，但如果有必要可以关闭该功能。</p><hr><h4 id="Q5-：什么是空间索引？"><a href="#Q5-：什么是空间索引？" class="headerlink" title="Q5 ：什么是空间索引？"></a>Q5 ：什么是空间索引？</h4><p>MyISAM 表支持空间索引，可以用作地理数据存储。和 B-Tree 索引不同，这类索引无需前缀查询。空间索引会从所有维度来索引数据，查询时可以有效地使用任意维度来组合查询。必须使用 MySQL 的 GIS 即地理信息系统的相关函数来维护数据，但 MySQL 对 GIS 的支持并不完善，因此大部分人都不会使用这个特性。</p><hr><h4 id="Q6：什么是全文索引？"><a href="#Q6：什么是全文索引？" class="headerlink" title="Q6：什么是全文索引？"></a>Q6：什么是全文索引？</h4><p>通过数值比较、范围过滤等就可以完成绝大多数需要的查询，但如果希望通过关键字匹配进行查询，就需要基于相似度的查询，而不是精确的数值比较，全文索引就是为这种场景设计的。</p><p>MyISAM 的全文索引是一种特殊的 B-Tree 索引，一共有两层。第一层是所有关键字，然后对于每一个关键字的第二层，包含的是一组相关的”文档指针”。全文索引不会索引文档对象中的所有词语，它会根据规则过滤掉一些词语，例如停用词列表中的词都不会被索引。</p><hr><h4 id="Q7：什么是聚簇索引？"><a href="#Q7：什么是聚簇索引？" class="headerlink" title="Q7：什么是聚簇索引？"></a>Q7：什么是聚簇索引？</h4><p>聚簇索引不是一种索引类型，而是一种数据存储方式。InnoDB 的聚簇索引实际上在同一个结构中保存了 B-Tree 索引和数据行。当表有聚餐索引时，它的行数据实际上存放在索引的叶子页中，因为无法同时把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</p><p>优点：① 可以把相关数据保存在一起。② 数据访问更快，聚簇索引将索引和数据保存在同一个 B-Tree 中，因此获取数据比非聚簇索引要更快。③ 使用覆盖索引扫描的查询可以直接使用页节点中的主键值。</p><p>缺点：① 聚簇索引最大限度提高了 IO 密集型应用的性能，如果数据全部在内存中将会失去优势。② 更新聚簇索引列的代价很高，因为会强制每个被更新的行移动到新位置。③ 基于聚簇索引的表插入新行或主键被更新导致行移动时，可能导致页分裂，表会占用更多磁盘空间。④ 当行稀疏或由于页分裂导致数据存储不连续时，全表扫描可能很慢。</p><hr><h4 id="Q8：什么是覆盖索引？"><a href="#Q8：什么是覆盖索引？" class="headerlink" title="Q8：什么是覆盖索引？"></a>Q8：什么是覆盖索引？</h4><p>覆盖索引指一个索引包含或覆盖了所有需要查询的字段的值，不再需要根据索引回表查询数据。覆盖索引必须要存储索引列的值，因此 MySQL 只能使用 B-Tree 索引做覆盖索引。</p><p>优点：① 索引条目通常远小于数据行大小，可以极大减少数据访问量。② 因为索引按照列值顺序存储，所以对于 IO 密集型防伪查询回避随机从磁盘读取每一行数据的 IO 少得多。③ 由于 InnoDB 使用聚簇索引，覆盖索引对 InnoDB 很有帮助。InnoDB 的二级索引在叶子节点保存了行的主键值，如果二级主键能覆盖查询那么可以避免对主键索引的二次查询。</p><hr><h4 id="Q9：你知道哪些索引使用原则？"><a href="#Q9：你知道哪些索引使用原则？" class="headerlink" title="Q9：你知道哪些索引使用原则？"></a>Q9：你知道哪些索引使用原则？</h4><p><strong>建立索引</strong></p><p>对查询频次较高且数据量比较大的表建立索引。索引字段的选择，最佳候选列应当从 WHERE 子句的条件中提取，如果 WHERE 子句中的组合比较多，应当挑选最常用、过滤效果最好的列的组合。业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。</p><p><strong>使用前缀索引</strong></p><p>索引列开始的部分字符，索引创建后也是使用硬盘来存储的，因此短索引可以提升索引访问的 IO 效率。对于 BLOB、TEXT 或很长的 VARCHAR 列必须使用前缀索引，MySQL 不允许索引这些列的完整长度。前缀索引是一种能使索引更小更快的有效方法，但缺点是 MySQL 无法使用前缀索引做 ORDER BY 和 GROUP BY，也无法使用前缀索引做覆盖扫描。</p><p><strong>选择合适的索引顺序</strong></p><p>当不需要考虑<a href>排序</a>和分组时，将选择性最高的列放在前面。索引的选择性是指不重复的索引值和数据表的记录总数之比，索引的选择性越高则查询效率越高，唯一索引的选择性是 1，因此也可以使用唯一索引提升查询效率。</p><p><strong>删除无用索引</strong></p><p>MySQL 允许在相同列上创建多个索引，重复的索引需要单独维护，并且优化器在优化查询时也需要逐个考虑，这会影响性能。重复索引是指在相同的列上按照相同的顺序创建的相同类型的索引，应该避免创建重复索引。如果创建了索引 (A,B) 再创建索引 (A) 就是冗余索引，因为这只是前一个索引的前缀索引，对于 B-Tree 索引来说是冗余的。解决重复索引和冗余索引的方法就是删除这些索引。除了重复索引和冗余索引，可能还会有一些服务器永远不用的索引，也应该考虑删除。</p><hr><h4 id="Q10：索引失效的情况有哪些？"><a href="#Q10：索引失效的情况有哪些？" class="headerlink" title="Q10：索引失效的情况有哪些？"></a>Q10：索引失效的情况有哪些？</h4><p>如果索引列出现了隐式类型转换，则 MySQL 不会使用索引。常见的情况是在 SQL 的 WHERE 条件中字段类型为字符串，其值为数值，如果没有加引号那么 MySQL 不会使用索引。</p><p>如果 WHERE 条件中含有 OR，除非 OR 前使用了索引列而 OR 之后是非索引列，索引会失效。</p><p>MySQL 不能在索引中执行 LIKE 操作，这是底层存储引擎 API 的限制，最左匹配的 LIKE 比较会被转换为简单的比较操作，但如果是以通配符开头的 LIKE 查询，存储引擎就无法做比较。这种情况下 MySQL 只能提取数据行的值而不是索引值来做比较。</p><p>如果查询中的列不是独立的，则 MySQL 不会使用索引。独立的列是指索引列不能是表达式的一部分，也不能是函数的参数。</p><p>对于多个范围条件查询，MySQL 无法使用第一个范围列后面的其他索引列，对于多个等值查询则没有这种限制。</p><p>如果 MySQL 判断全表扫描比使用索引查询更快，则不会使用索引。</p><p>索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p><hr><h3 id="优化-5"><a href="#优化-5" class="headerlink" title="优化 5"></a>优化 5</h3><h4 id="Q1：如何定位低效-SQL？"><a href="#Q1：如何定位低效-SQL？" class="headerlink" title="Q1：如何定位低效 SQL？"></a>Q1：如何定位低效 SQL？</h4><p>可以通过两种方式来定位执行效率较低的 SQL 语句。一种是通过慢查询日志定位，可以通过慢查询日志定位那些已经执行完毕的 SQL 语句。另一种是使用 SHOW PROCESSLIST 查询，慢查询日志在查询结束以后才记录，所以在应用反应执行效率出现问题的时候查询慢查询日志不能定位问题，此时可以使用 SHOW PROCESSLIST 命令查看当前 MySQL 正在进行的线程，包括线程的状态、是否锁表等，可以实时查看 SQL 的执行情况，同时对一些锁表操作进行优化。找到执行效率低的 SQL 语句后，就可以通过 SHOW PROFILE、EXPLAIN 或 trace 等丰富来继续优化语句。</p><hr><h4 id="Q2：SHOW-PROFILE-的作用？"><a href="#Q2：SHOW-PROFILE-的作用？" class="headerlink" title="Q2：SHOW PROFILE 的作用？"></a>Q2：SHOW PROFILE 的作用？</h4><p>通过 SHOW PROFILE 可以分析 SQL 语句性能消耗，例如查询到 SQL 会执行多少时间，并显示 CPU、内存使用量，执行过程中系统锁及表锁的花费时间等信息。例如 <code>SHOW PROFILE CPU/MEMORY/BLOCK IO FOR QUERY N</code> 分别查询 id 为 N 的 SQL 语句的 CPU、内存以及 IO 的消耗情况。</p><hr><h4 id="Q3：trace-是干什么的？"><a href="#Q3：trace-是干什么的？" class="headerlink" title="Q3：trace 是干什么的？"></a>Q3：trace 是干什么的？</h4><p>从 MySQL5.6 开始，可以通过 trace 文件进一步获取优化器是是如何选择执行计划的，在使用时需要先打开设置，然后执行一次 SQL，最后查看 information_schema.optimizer_trace 表而都内容，该表为联合i表，只能在当前会话进行查询，每次查询后返回的都是最近一次执行的 SQL 语句。</p><hr><h4 id="Q4：EXPLAIN-的字段有哪些，具有什么含义？"><a href="#Q4：EXPLAIN-的字段有哪些，具有什么含义？" class="headerlink" title="Q4：EXPLAIN 的字段有哪些，具有什么含义？"></a>Q4：EXPLAIN 的字段有哪些，具有什么含义？</h4><p>执行计划是 SQL 调优的一个重要依据，可以通过 EXPLAIN 命令查看 SQL 语句的执行计划，如果作用在表上，那么该命令相当于 DESC。EXPLAIN 的指标及含义如下：</p><table><thead><tr><th>指标名</th><th>含义</th></tr></thead><tbody><tr><td>id</td><td>表示 SELECT 子句或操作表的顺序，执行顺序从大到小执行，当 id 一样时，执行顺序从上往下。</td></tr><tr><td>select_type</td><td>表示查询中每个 SELECT 子句的类型，例如 SIMPLE 表示不包含子查询、表连接或其他复杂语法的简单查询，PRIMARY 表示复杂查询的最外层查询，SUBQUERY 表示在 SELECT 或 WHERE 列表中包含了子查询。</td></tr><tr><td>type</td><td>表示访问类型，性能由差到好为：ALL 全表扫描、index 索引全扫描、range 索引范围扫描、ref 返回匹配某个单独值得所有行，常见于使用非唯一索引或唯一索引的非唯一前缀进行的查找，也经常出现在 join 操作中、eq_ref 唯一性索引扫描，对于每个索引键只有一条记录与之匹配、const 当 MySQL 对查询某部分进行优化，并转为一个常量时，使用这些访问类型，例如将主键或唯一索引置于 WHERE 列表就能将该查询转为一个 const、system 表中只有一行数据或空表，只能用于 MyISAM 和 Memory 表、NULL 执行时不用访问表或索引就能得到结果。SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是consts 最好。</td></tr><tr><td>possible_keys</td><td>表示查询时可能用到的索引，但不一定使用。列出大量可能索引时意味着备选索引数量太多了。</td></tr><tr><td>key</td><td>显示 MySQL 在查询时实际使用的索引，如果没有使用则显示为 NULL。</td></tr><tr><td>key_len</td><td>表示使用到索引字段的长度，可通过该列计算查询中使用的索引的长度，对于确认索引有效性以及多列索引中用到的列数目很重要。</td></tr><tr><td>ref</td><td>表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值。</td></tr><tr><td>rows</td><td>表示 MySQL 根据表统计信息及索引选用情况，估算找到所需记录所需要读取的行数。</td></tr><tr><td>Extra</td><td>表示额外信息，例如 Using temporary 表示需要使用临时表存储结果集，常见于<a href>排序</a>和分组查询。Using filesort 表示无法利用索引完成的文件<a href>排序</a>，这是 ORDER BY 的结果，可以通过合适的索引改进性能。Using index 表示只需要使用索引就可以满足查询表得要求，说明表正在使用覆盖索引。</td></tr></tbody></table><hr><h4 id="Q5：有哪些优化-SQL-的策略？"><a href="#Q5：有哪些优化-SQL-的策略？" class="headerlink" title="Q5：有哪些优化 SQL 的策略？"></a>Q5：有哪些优化 SQL 的策略？</h4><p><strong>优化 COUNT 查询</strong></p><p>COUNT 是一个特殊的函数，它可以统计某个列值的数量，在统计列值时要求列值是非空的，不会统计 NULL 值。如果在 COUNT 中指定了列或列的表达式，则统计的就是这个表达式有值的结果数，而不是 NULL。</p><p>COUNT 的另一个作用是统计结果集的行数，当 MySQL 确定括号内的表达式不可能为 NULL 时，实际上就是在统计行数。当使用 COUNT(*) 时，* 不会扩展成所有列，它会忽略所有的列而直接统计所有的行数。</p><p>某些业务场景并不要求完全精确的 COUNT 值，此时可以使用近似值来代替，EXPLAIN 出来的优化器估算的行数就是一个不错的近似值，因为执行 EXPLAIN 并不需要真正地执行查询。</p><p>通常来说 COUNT 都需要扫描大量的行才能获取精确的结果，因此很难优化。在 MySQL 层还能做的就只有覆盖扫描了，如果还不够就需要修改应用的架构，可以增加汇总表或者外部缓存系统。</p><p><strong>优化关联查询</strong></p><p>确保 ON 或 USING 子句中的列上有索引，在创建索引时就要考虑到关联的顺序。</p><p>确保任何 GROUP BY 和 ORDER BY 的表达式只涉及到一个表中的列，这样 MySQL 才有可能使用索引来优化这个过程。</p><p>在 MySQL 5.5 及以下版本尽量避免子查询，可以用关联查询代替，因为执行器会先执行外部的 SQL 再执行内部的 SQL。</p><p><strong>优化 GROUP BY</strong></p><p>如果没有通过 ORDER BY 子句显式指定要<a href>排序</a>的列，当查询使用 GROUP BY 时，结果***自动按照分组的字段进行<a href>排序</a>，如果不关心结果集的顺序，可以使用 ORDER BY NULL 禁止<a href>排序</a>。</p><p><strong>优化 LIMIT 分页</strong></p><p>在偏移量非常大的时候，需要查询很多条数据再舍弃，这样的代价非常高。要优化这种查询，要么是在页面中限制分页的数量，要么是优化大偏移量的性能。最简单的办法是尽可能地使用覆盖索引扫描，而不是查询所有的列，然后根据需要做一次关联操作再返回所需的列。</p><p>还有一种方法是从上一次取数据的位置开始扫描，这样就可以避免使用 OFFSET。其他优化方法还包括使用预先计算的汇总表，或者关联到一个冗余表，冗余表只包含主键列和需要做<a href>排序</a>的数据列。</p><p><strong>优化 UNION 查询</strong></p><p>MySQL 通过创建并填充临时表的方式来执行 UNION 查询，除非确实需要服务器消除重复的行，否则一定要使用 UNION ALL，如果没有 ALL 关键字，MySQL 会给临时表加上 DISTINCT 选项，这会导致对整个临时表的数据做唯一性检查，这样做的代价非常高。</p><p><strong>使用用户自定义变量</strong></p><p>在查询中混合使用过程化和关系化逻辑的时候，自定义变量可能会非常有用。用户自定义变量是一个用来存储内容的临时容器，在连接 MySQL 的整个过程中都存在，可以在任何可以使用表达式的地方使用自定义变量。例如可以使用变量来避免重复查询刚刚更新过的数据、统计更新和插入的数量等。</p><p><strong>优化 INSERT</strong> </p><p>需要对一张表插入很多行数据时，应该尽量使用一次性插入多个值的 INSERT 语句，这种方式将缩减<a href>客户端</a>与数据库之间的连接、关闭等消耗，效率比多条插入单个值的 INSERT 语句高。也可以关闭事务的自动提交，在插入完数据后提交。当插入的数据是按主键的顺序插入时，效率更高。</p><hr><h3 id="复制-2"><a href="#复制-2" class="headerlink" title="复制 2"></a>复制 2</h3><p>作者：是瑶瑶公主吖<br>链接：<a href="https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post">https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post</a><br>来源：牛客网</p><h4 id="Q1：MySQL-主从复制的作用？"><a href="#Q1：MySQL-主从复制的作用？" class="headerlink" title="Q1：MySQL 主从复制的作用？"></a>Q1：MySQL 主从复制的作用？</h4><p>复制解决的基本问题是让一台服务器的数据与其他服务器保持同步，一台主库的数据可以同步到多台备库上，备库本身也可以被配置成另外一台服务器的主库。主库和备库之间可以有多种不同的组合方式。</p><p>MySQL 支持两种复制方式：基于行的复制和基于语句的复制，基于语句的复制也称为逻辑复制，从 MySQL 3.23 版本就已存在，基于行的复制方式在 5.1 版本才被加进来。这两种方式都是通过在主库上记录二进制日志、在备库重放日志的方式来实现异步的数据复制。因此同一时刻备库的数据可能与主库存在不一致，并且无法包装主备之间的延迟。</p><p>MySQL 复制大部分是向后兼容的，新版本的服务器可以作为老版本服务器的备库，但是老版本不能作为新版本服务器的备库，因为它可能无法解析新版本所用的新特性或语法，另外所使用的二进制文件格式也可能不同。</p><p>复制解决的问题：数据分布、负载均衡、备份、高可用性和故障切换、MySQL 升级测试。</p><hr><h4 id="Q2：MySQL-主从复制的步骤？"><a href="#Q2：MySQL-主从复制的步骤？" class="headerlink" title="Q2：MySQL 主从复制的步骤？"></a>Q2：MySQL 主从复制的步骤？</h4><p>① 在主库上把数据更改记录到二进制日志中。② 备库将主库的日志复制到自己的中继日志中。 ③ 备库读取中继日志中的事件，将其重放到备库数据之上。</p><p>第一步是在主库上记录二进制日志，每次准备提交事务完成数据更新前，主库将数据更新的事件记录到二进制日志中。MySQL 会按事务提交的顺序而非每条语句的执行顺序来记录二进制日志，在记录二进制日志后，主库会告诉存储引擎可以提交事务了。</p><p>下一步，备库将主库的二进制日志复制到其本地的中继日志中。备库首先会启动一个工作的 IO 线程，IO 线程跟主库建立一个普通的<a href>客户端</a>连接，然后在主库上启动一个特殊的二进制转储线程，这个线程会读取主库上二进制日志中的事件。它不会对事件进行轮询。如果该线程追赶上了主库将进入睡眠状态，直到主库发送信号量通知其有新的事件产生时才会被唤醒，备库 IO 线程会将接收到的事件记录到中继日志中。</p><p>备库的 SQL 线程执行最后一步，该线程从中继日志中读取事件并在备库执行，从而实现备库数据的更新。当 SQL 线程追赶上 IO 线程时，中继日志通常已经在系统缓存中，所以中继日志的开销很低。SQL 线程执行的时间也可以通过配置选项来决定是否写入其自己的二进制日志中。</p><hr><h2 id="Redis-37"><a href="#Redis-37" class="headerlink" title="Redis 37"></a>Redis 37</h2><h3 id="架构-3"><a href="#架构-3" class="headerlink" title="架构 3"></a>架构 3</h3><h4 id="Q1：Redis-有什么特点？"><a href="#Q1：Redis-有什么特点？" class="headerlink" title="Q1：Redis 有什么特点？"></a>Q1：Redis 有什么特点？</h4><p><strong>基于键值对的数据结构服务器</strong></p><p>Redis 中的值不仅可以是字符串，还可以是具体的数据结构，这样不仅能应用于多种场景开发，也可以提高开发效率。它主要提供五种数据结构：字符串、哈希、列表、集合、有序集合，同时在字符串的基础上演变出了 Bitmaps 和 HyperLogLog 两种数据结构，Redis 3.2 还加入了有关 GEO 地理信息定位的功能。</p><p><strong>丰富的功能</strong></p><p>① 提供了键过期功能，可以实现缓存。② 提供了发布订阅功能，可以实现消息系统。③ 支持 Lua 脚本，可以创造新的 Redis 命令。④ 提供了简单的事务功能，能在一定程度上保证事务特性。⑤ 提供了流水线功能，<a href>客户端</a>能将一批命令一次性传到 Redis，减少网络开销。</p><p><strong>简单稳定</strong></p><p>Redis 的简单主要体现在三个方面：① <a href>源码</a>很少，早期只有 2 万行左右，在 3.0 版本由于添加了集群特性，增加到了 5 万行左右，相对于很多 NoSQL 数据库来说代码量要少很多。② 采用单线程模型，使得服务端处理模型更简单，也使<a href>客户端</a>开发更简单。③ 不依赖底层操作系统的类库，自己实现了事件处理的相关功能。虽然 Redis 比较简单，但也很稳定。</p><p><strong><a href>客户端</a>语言多</strong></p><p>Redis 提供了简单的 TCP 通信协议，很多编程语言可以方便地接入 Redis，例如 Java、PHP、Python、C、C++ 等。</p><p><strong>持久化</strong></p><p>通常来说数据放在内存中是不安全的，一旦发生断电或故障数据就可能丢失，因此 Redis 提供了两种持久化方式 RDB 和 AOF 将内存的数据保存到硬盘中。</p><p><strong>高性能</strong></p><p>Redis 使用了单线程架构和 IO 多路复用模型来实现高性能的内存数据库服务。</p><p>每次<a href>客户端</a>调用都经历了发送命令、执行命令、返回结果三个过程，因为 Redis 是单线程处理命令的，所以一条命令从<a href>客户端</a>到达服务器不会立即执行，所有命令都会进入一个队列中，然后逐个被执行。<a href>客户端</a>的执行顺序可能不确定，但是可以确定不会有两条命令被同时执行，不存在并发问题。</p><p>通常来说单线程处理能力要比多线程差，Redis 快的原因：① 纯内存访问，Redis 将所有数据放在内存中。② 非阻塞 IO，Redis 使用 epoll 作为 IO 多路复用技术的实现，再加上 Redis 本身的事件处理模型将 epoll 中的连接、读写、关闭都转换为时间，不在网络 IO 上浪费过多的时间。③ 单线程避免了线程切换和竞争产生的消耗。单线程的一个问题是对于每个命令的执行时间是有要求的，如果某个命令执行时间过长会造成其他命令的阻塞，对于 Redis 这种高性能服务来说是致命的，因此 Redis 是面向快速执行场景的数据库。</p><hr><h4 id="Q2：Redis-的数据结构有哪些？"><a href="#Q2：Redis-的数据结构有哪些？" class="headerlink" title="Q2：Redis 的数据结构有哪些？"></a>Q2：Redis 的数据结构有哪些？</h4><p>可以使用 type 命令查看当前键的数据类型结构，它们分别是：string、hash、list、set、zset，但这些只是 Redis 对外的数据结构。实际上每种数据结构都有自己底层的内部编码实现，这样 Redis 会在合适的场景选择合适的内部编码，string 包括了 raw、int 和 embstr，hash 包括了 hashtable 和 ziplist，list 包括了 linkedlist 和 ziplist，set 包括了 hashtable 和 intset，zset 包括了 skiplist 和 ziplist。可以使用 <code>object encoding</code> 查看内部编码。</p><hr><h4 id="Q3：Redis-为什么要使用内部编码？"><a href="#Q3：Redis-为什么要使用内部编码？" class="headerlink" title="Q3：Redis 为什么要使用内部编码？"></a>Q3：Redis 为什么要使用内部编码？</h4><p>① 可以改进内部编码，而对外的数据结构和命令没有影响。</p><p>② 多种内部编码实现可以在不同场景下发挥各自的优势，例如 ziplist 比较节省内存，但在列表元素较多的情况下性能有所下降，这时 Redis 会根据配置选项将列表类型的内部实现转换为 linkedlist。</p><hr><h3 id="string-4"><a href="#string-4" class="headerlink" title="string 4"></a>string 4</h3><h4 id="Q1：简单说一说-string-类型"><a href="#Q1：简单说一说-string-类型" class="headerlink" title="Q1：简单说一说 string 类型"></a>Q1：简单说一说 string 类型</h4><p>字符串类型是 Redis 最基础的数据结构，键都是字符串类型，而且其他几种数据结构都是在字符串类型的基础上构建的。字符串类型的值可以实际可以是字符串（简单的字符串、复杂的字符串如 JSON、XML）、数字（整形、浮点数）、甚至二进制（图片、音频、视频），但是值最大不能超过 512 MB。</p><hr><h4 id="Q2：你知道哪些-string-的命令？"><a href="#Q2：你知道哪些-string-的命令？" class="headerlink" title="Q2：你知道哪些 string 的命令？"></a>Q2：你知道哪些 string 的命令？</h4><p><strong>设置值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set key value [ex seconds] [px millseconds] [nx|xx]</span><br></pre></td></tr></table></figure><ul><li>ex seconds：为键设置秒级过期时间，跟 setex 效果一样 </li><li>px millseconds：为键设置毫秒级过期时间 </li><li>nx：键必须不存在才可以设置成功，用于添加，跟 setnx 效果一样。由于 Redis 的单线程命令处理机制，如果多个<a href>客户端</a>同时执行，则只有一个<a href>客户端</a>能设置成功，可以用作分布式锁的一种实现。 </li><li>xx：键必须存在才可以设置成功，用于更新</li></ul><p><strong>获取值</strong></p><p><code>get key</code>，如果不存在返回 nil</p><p><strong>批量设置值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mset key value [key value...]</span><br></pre></td></tr></table></figure><p><strong>批量获取值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mget key [key...]</span><br></pre></td></tr></table></figure><p>批量操作命令可以有效提高开发效率，假如没有 mget，执行 n 次 get 命令需要 n 次网络时间 + n 次命令时间，使用 mget 只需要 1 次网络时间 + n 次命令时间。Redis 可以支持每秒数万的读写操作，但这指的是 Redis 服务端的处理能力，对于<a href>客户端</a>来说一次命令处理命令时间还有网络时间。因为 Redis 的处理能力已足够高，对于开发者来说，网络可能会成为性能瓶颈。</p><p><strong>计数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">incr key</span><br></pre></td></tr></table></figure><p>incr 命令用于对值做自增操作，返回结果分为三种：① 值不是整数返回错误。② 值是整数，返回自增后的结果。③ 值不存在，按照值为 0 自增，返回结果 1。除了 incr 命令，还有自减 decr、自增指定数字 incrby、自减指定数组 decrby、自增浮点数 incrbyfloat。</p><hr><h4 id="Q3：string-的内部编码是什么？"><a href="#Q3：string-的内部编码是什么？" class="headerlink" title="Q3：string 的内部编码是什么？"></a>Q3：string 的内部编码是什么？</h4><ul><li>int：8 个字节的长整形 </li><li>embstr：小于等于 39 个字节的字符串 </li><li>raw：大于 39 个字节的字符串</li></ul><hr><h4 id="Q4：string-的应用场景有什么？"><a href="#Q4：string-的应用场景有什么？" class="headerlink" title="Q4：string 的应用场景有什么？"></a>Q4：string 的应用场景有什么？</h4><p><strong>缓存功能</strong></p><p>Redis 作为缓存层，MySQL 作为存储层，首先从 Redis 获取数据，如果失败就从 MySQL 获取并将结果写回 Redis 并添加过期时间。</p><p><strong>计数</strong></p><p>Redis 可以实现快速计数功能，例如视频每播放一次就用 incy 把播放数加 1。</p><p><strong>共享 Session</strong></p><p>一个分布式 Web 服务将用户的 Session 信息保存在各自服务器，但会造成一个问题，出于负载均衡的考虑，分布式服务会将用户的访问负载到不同服务器上，用户刷新一次可能会发现需要重新登陆。为解决该问题，可以使用 Redis 将用户的 Session 进行集中管理，在这种模式下只要保证 Redis 是高可用和扩展性的，每次用户更新或查询登录信息都直接从 Redis 集中获取。</p><p><strong>限速</strong></p><p>例如为了短信接口不被频繁访问会限制用户每分钟获取验证码的次数或者网站限制一个 IP 地址不能在一秒内访问超过 n 次。可以使用键过期策略和自增计数实现。</p><hr><h3 id="hash-4"><a href="#hash-4" class="headerlink" title="hash 4"></a>hash 4</h3><h4 id="Q1：简单说一说-hash-类型"><a href="#Q1：简单说一说-hash-类型" class="headerlink" title="Q1：简单说一说 hash 类型"></a>Q1：简单说一说 hash 类型</h4><p>哈希类型指键值本身又是一个键值对结构，哈希类型中的映射关系叫 field-value，这里的 value 是指 field 对于的值而不是键对于的值。</p><hr><h4 id="Q2：你知道哪些-hash-的命令？"><a href="#Q2：你知道哪些-hash-的命令？" class="headerlink" title="Q2：你知道哪些 hash 的命令？"></a>Q2：你知道哪些 hash 的命令？</h4><p><strong>设置值</strong></p><p><code>hset key field value</code>，如果设置成功会返回 1，反之会返回 0，此外还提供了 hsetnx 命令，作用和 setnx 类似，只是作用于由键变为 field。</p><p><strong>获取值</strong></p><p><code>hget key field</code>，如果不存在会返回 nil。</p><p><strong>删除 field</strong></p><p><code>hdel key field [field...]</code>，会删除一个或多个 field，返回结果为删除成功 field 的个数。</p><p><strong>计算 field 个数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hlen key</span><br></pre></td></tr></table></figure><p><strong>批量设置或获取 field-value</strong></p><p><a href="#">复制代码</a></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hmget key field [field...]``hmset key field value [field value...]</span><br></pre></td></tr></table></figure><p><strong>判断 field 是否存在</strong></p><p><code>hexists key field</code>，存在返回 1，否则返回 0。</p><p><strong>获取所有的 field</strong></p><p><code>hkeys key</code>，返回指定哈希键的所有 field。</p><p><strong>获取所有 value</strong></p><p><code>hvals key</code>，获取指定键的所有 value。</p><p><strong>获取所有的 field-value</strong></p><p><code>hgetall key</code>，获取指定键的所有 field-value。</p><hr><h4 id="Q3：hash-的内部编码是什么？"><a href="#Q3：hash-的内部编码是什么？" class="headerlink" title="Q3：hash 的内部编码是什么？"></a>Q3：hash 的内部编码是什么？</h4><p>ziplist 压缩列表：当哈希类型元素个数和值小于配置值（默认 512 个和 64 字节）时会使用 ziplist 作为内部实现，使用更紧凑的结构实现多个元素的连续存储，在节省内存方面比 hashtable 更优秀。</p><p>hashtable <a href>哈希表</a>：当哈希类型无法满足 ziplist 的条件时会使用 hashtable 作为哈希的内部实现，因为此时 ziplist 的读写效率会下降，而 hashtable 的读写时间复杂度都为 O(1)。</p><hr><h4 id="Q4：hash-的应用场景有什么？"><a href="#Q4：hash-的应用场景有什么？" class="headerlink" title="Q4：hash 的应用场景有什么？"></a>Q4：hash 的应用场景有什么？</h4><p>缓存用户信息，每个用户属性使用一对 field-value，但只用一个键保存。</p><p>优点：简单直观，如果合理使用可以减少内存空间使用。</p><p>缺点：要控制哈希在 ziplist 和 hashtable 两种内部编码的转换，hashtable 会消耗更多内存。</p><hr><h3 id="list-4"><a href="#list-4" class="headerlink" title="list 4"></a>list 4</h3><h4 id="Q1：简单说一说-list-类型"><a href="#Q1：简单说一说-list-类型" class="headerlink" title="Q1：简单说一说 list 类型"></a>Q1：简单说一说 list 类型</h4><p>list 是用来存储多个有序的字符串，列表中的每个字符串称为元素，一个列表最多可以存储 2^32^-1 个元素。可以对列表两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等。列表是一种比较灵活的数据结构，它可以充当栈和队列的角色，在实际开发中有很多应用场景。</p><p>list 有两个特点：① 列表中的元素是有序的，可以通过索引下标获取某个元素或者某个范围内的元素列表。② 列表中的元素可以重复。</p><hr><h4 id="Q2：你知道哪些-list-的命令？"><a href="#Q2：你知道哪些-list-的命令？" class="headerlink" title="Q2：你知道哪些 list 的命令？"></a>Q2：你知道哪些 list 的命令？</h4><p><strong>添加</strong></p><p>从右边插入元素：<code>rpush key value [value...]</code></p><p>从左到右获取列表的所有元素：<code>lrange 0 -1</code></p><p>从左边插入元素：<code>lpush key value [value...]</code></p><p>向某个元素前或者后插入元素：<code>linsert key before|after pivot value</code>，会在列表中找到等于 pivot 的元素，在其前或后插入一个新的元素 value。</p><p><strong>查找</strong></p><p>获取指定范围内的元素列表：<code>lrange key start end</code>，索引从左到右的范围是 0<del>N-1，从右到左是 -1</del>-N，lrange 中的 end 包含了自身。</p><p>获取列表指定索引下标的元素：<code>lindex key index</code>，获取最后一个元素可以使用 <code>lindex key -1</code>。</p><p>获取列表长度：<code>llen key</code></p><p><strong>删除</strong></p><p>从列表左侧弹出元素：<code>lpop key</code></p><p>从列表右侧弹出元素：<code>rpop key</code></p><p>删除指定元素：<code>lrem key count value</code>，如果 count 大于 0，从左到右删除最多 count 个元素，如果 count 小于 0，从右到左删除最多个 count 绝对值个元素，如果 count 等于 0，删除所有。</p><p>按照索引范围修剪列表：<code>ltrim key start end</code>，只会保留 start ~ end 范围的元素。</p><p><strong>修改</strong></p><p>修改指定索引下标的元素：<code>lset key index newValue</code>。</p><p><strong>阻塞操作</strong></p><p>阻塞式弹出：<code>blpop/brpop key [key...] timeout</code>，timeout 表示阻塞时间。</p><p>当列表为空时，如果 timeout &#x3D; 0，<a href>客户端</a>会一直阻塞，如果在此期间添加了元素，<a href>客户端</a>会立即返回。</p><p>如果是多个键，那么brpop会从左至右遍历键，一旦有一个键能弹出元素，<a href>客户端</a>立即返回。</p><p>如果多个<a href>客户端</a>对同一个键执行 brpop，那么最先执行该命令的<a href>客户端</a>可以获取弹出的值。</p><hr><h4 id="Q3：list-的内部编码是什么？"><a href="#Q3：list-的内部编码是什么？" class="headerlink" title="Q3：list 的内部编码是什么？"></a>Q3：list 的内部编码是什么？</h4><p>ziplist 压缩列表：跟哈希的 zipilist 相同，元素个数和大小小于配置值（默认 512 个和 64 字节）时使用。</p><p>linkedlist <a href>链表</a>：当列表类型无法满足 ziplist 的条件时会使用linkedlist。</p><p>Redis 3.2 提供了 quicklist 内部编码，它是以一个 ziplist 为节点的 linkedlist，它结合了两者的优势，为列表类提供了一种更为优秀的内部编码实现。</p><hr><h4 id="Q4：list-的应用场景有什么？"><a href="#Q4：list-的应用场景有什么？" class="headerlink" title="Q4：list 的应用场景有什么？"></a>Q4：list 的应用场景有什么？</h4><p><strong>消息队列</strong></p><p>Redis 的 lpush + brpop 即可实现阻塞队列，生产者<a href>客户端</a>使用 lpush 从列表左侧插入元素，多个消费者<a href>客户端</a>使用 brpop 命令阻塞式地抢列表尾部的元素，多个<a href>客户端</a>保证了消费的负载均衡和高可用性。</p><p><strong>文章列表</strong></p><p>每个用户有属于自己的文章列表，现在需要分页展示文章列表，就可以考虑使用列表。因为列表不但有序，同时支持按照索引范围获取元素。每篇文章使用哈希结构存储。</p><p>lpush + lpop &#x3D; 栈、lpush + rpop &#x3D; 队列、lpush + ltrim &#x3D; 优先集合、lpush + brpop &#x3D; 消息队列。</p><hr><h3 id="set-4"><a href="#set-4" class="headerlink" title="set 4"></a>set 4</h3><p>作者：是瑶瑶公主吖<br>链接：<a href="https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post">https://www.nowcoder.com/discuss/447742?type=post&amp;order=time&amp;pos=&amp;page=4&amp;channel=1009&amp;source_id=search_post</a><br>来源：牛客网</p><h4 id="Q1：简单说一说-set-类型"><a href="#Q1：简单说一说-set-类型" class="headerlink" title="Q1：简单说一说 set 类型"></a>Q1：简单说一说 set 类型</h4><p>集合类型也是用来保存多个字符串元素，和列表不同的是集合不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。一个集合最多可以存储 2^32^-1 个元素。Redis 除了支持集合内的增删改查，还支持多个集合取交集、并集、差集。</p><hr><h4 id="Q2：你知道哪些-set-的命令？"><a href="#Q2：你知道哪些-set-的命令？" class="headerlink" title="Q2：你知道哪些 set 的命令？"></a>Q2：你知道哪些 set 的命令？</h4><p><strong>添加元素</strong></p><p><code>sadd key element [element...]</code>，返回结果为添加成功的元素个数。</p><p><strong>删除元素</strong></p><p><code>srem key element [element...]</code>，返回结果为成功删除的元素个数。</p><p><strong>计算元素个数</strong></p><p><code>scard key</code>，时间复杂度为 O(1)，会直接使用 Redis 内部的遍历。</p><p><strong>判断元素是否在集合中</strong></p><p><code>sismember key element</code>，如果存在返回 1，否则返回 0。</p><p><strong>随机从集合返回指定个数个元素</strong></p><p><code>srandmember key [count]</code>，如果不指定 count 默认为 1。</p><p><strong>从集合随机弹出元素</strong></p><p><code>spop key</code>，可以从集合中随机弹出一个元素。</p><p><strong>获取所有元素</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">smembers key</span><br></pre></td></tr></table></figure><p><strong>求多个集合的交集&#x2F;并集&#x2F;差集</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sinter key [key...]</span><br><span class="line">sunion key [key...]</span><br><span class="line">sdiff key [key...]</span><br></pre></td></tr></table></figure><p><strong>保存交集、并集、差集的结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sinterstore/sunionstore/sdiffstore destination key [key...]</span><br></pre></td></tr></table></figure><p>集合间运算在元素较多情况下比较耗时，Redis 提供这三个指令将集合间交集、并集、差集的结果保存在 destination key 中。</p><hr><h4 id="Q3：set-的内部编码是什么？"><a href="#Q3：set-的内部编码是什么？" class="headerlink" title="Q3：set 的内部编码是什么？"></a>Q3：set 的内部编码是什么？</h4><p>intset 整数集合：当集合中的元素个数小于配置值（默认 512 个时），使用 intset。</p><p>hashtable <a href>哈希表</a>：当集合类型无法满足 intset 条件时使用 hashtable。当某个元素不为整数时，也会使用 hashtable。</p><hr><h4 id="Q4：set-的应用场景有什么？"><a href="#Q4：set-的应用场景有什么？" class="headerlink" title="Q4：set 的应用场景有什么？"></a>Q4：set 的应用场景有什么？</h4><p>set 比较典型的使用场景是标签，例如一个用户可能与娱乐、体育比较感兴趣，另一个用户可能对例时、新闻比较感兴趣，这些兴趣点就是标签。这些数据对于用户体验以及增强用户黏度比较重要。</p><p>sadd &#x3D; 标签、spop&#x2F;srandmember &#x3D; 生成随机数，比如抽奖、sadd + sinter &#x3D; 社交需求。</p><hr><h3 id="zset-4"><a href="#zset-4" class="headerlink" title="zset 4"></a>zset 4</h3><h4 id="Q1：简单说一说-zset-类型"><a href="#Q1：简单说一说-zset-类型" class="headerlink" title="Q1：简单说一说 zset 类型"></a>Q1：简单说一说 zset 类型</h4><p>有序集合保留了集合不能有重复成员的特性，不同的是可以<a href>排序</a>。但是它和列表使用索引下标作为<a href>排序</a>依据不同的是，他给每个元素设置一个分数（score）作为<a href>排序</a>的依据。有序集合提供了获取指定分数和元素查询范围、计算成员排名等功能。</p><hr><h4 id="Q2：你知道哪些-zset-的命令？"><a href="#Q2：你知道哪些-zset-的命令？" class="headerlink" title="Q2：你知道哪些 zset 的命令？"></a>Q2：你知道哪些 zset 的命令？</h4><p><strong>添加成员</strong></p><p><code>zadd key score member [score member...]</code>，返回结果是成功添加成员的个数</p><p>Redis 3.2 为 zadd 命令添加了 nx、xx、ch、incr 四个选项：</p><ul><li>nx：member 必须不存在才可以设置成功，用于添加。 </li><li>xx：member 必须存在才能设置成功，用于更新。 </li><li>ch：返回此次操作后，有序集合元素和分数变化的个数。 </li><li>incr：对 score 做增加，相当于 zincrby。</li></ul><p>zadd 的时间复杂度为 O(log<del>n</del>)，sadd 的时间复杂度为 O(1)。</p><p><strong>计算成员个数</strong></p><p><code>zcard key</code>，时间复杂度为 O(1)。</p><p><strong>计算某个成员的分数</strong></p><p><code>zscore key member</code> ，如果不存在则返回 nil。</p><p><strong>计算成员排名</strong></p><p><code>zrank key member</code>，从低到高返回排名。</p><p><code>zrevrank key member</code>，从高到低返回排名。</p><p><strong>删除成员</strong></p><p><code>zrem key member [member...]</code>，返回结果是成功删除的个数。</p><p><strong>增加成员的分数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zincrby key increment member</span><br></pre></td></tr></table></figure><p><strong>返回指定排名范围的成员</strong></p><p><code>zrange key start end [withscores]</code>，从低到高返回</p><p><code>zrevrange key start end [withscores]</code>， 从高到底返回</p><p><strong>返回指定分数范围的成员</strong></p><p><code>zrangebyscore key min max [withscores] [limit offset count]</code>，从低到高返回</p><p><code>zrevrangebyscore key min max [withscores] [limit offset count]</code>， 从高到底返回</p><p><strong>返回指定分数范围成员个数</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zcount key min max</span><br></pre></td></tr></table></figure><p><strong>删除指定分数范围内的成员</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zremrangebyscore key min max</span><br></pre></td></tr></table></figure><p><strong>交集和并集</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zinterstore/zunionstore destination numkeys key [key...] [weights weight [weight...]] [aggregate sum|min|max]</span><br></pre></td></tr></table></figure><ul><li><code>destination</code>：交集结果保存到这个键</li><li><code>numkeys</code>：要做交集计算键的个数</li><li><code>key</code>：需要做交集计算的键</li><li><code>weight</code>：每个键的权重，默认 1</li><li><code>aggregate sum|min|max</code>：计算交集后，分值可以按和、最小值、最大值汇总，默认 sum。</li></ul><hr><h4 id="Q3：zset-的内部编码是什么？"><a href="#Q3：zset-的内部编码是什么？" class="headerlink" title="Q3：zset 的内部编码是什么？"></a>Q3：zset 的内部编码是什么？</h4><p>ziplist 压缩列表：当有序集合元素个数和值小于配置值（默认128 个和 64 字节）时会使用 ziplist 作为内部实现。</p><p>skiplist 跳跃表：当 ziplist 不满足条件时使用，因为此时 ziplist 的读写效率会下降。</p><hr><h4 id="Q4：zset-的应用场景有什么？"><a href="#Q4：zset-的应用场景有什么？" class="headerlink" title="Q4：zset 的应用场景有什么？"></a>Q4：zset 的应用场景有什么？</h4><p>有序集合的典型使用场景就是排行榜系统，例如用户上传了一个视频并获得了赞，可以使用 zadd 和 zincrby。如果需要将用户从榜单删除，可以使用 zrem。如果要展示获取赞数最多的十个用户，可以使用 zrange。</p><hr><h3 id="键和数据库管理-5"><a href="#键和数据库管理-5" class="headerlink" title="键和数据库管理 5"></a>键和数据库管理 5</h3><h4 id="Q1：如何对键重命名？"><a href="#Q1：如何对键重命名？" class="headerlink" title="Q1：如何对键重命名？"></a>Q1：如何对键重命名？</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rename key newkey</span><br></pre></td></tr></table></figure><p>如果 rename 前键已经存在，那么它的值也会被覆盖。为了防止强行覆盖，Redis 提供了 renamenx 命令，确保只有 newkey 不存在时才被覆盖。由于重命名键期间会执行 del 命令删除旧的键，如果键对应值比较大会存在阻塞的可能。</p><hr><h4 id="Q2：如何设置键过期？"><a href="#Q2：如何设置键过期？" class="headerlink" title="Q2：如何设置键过期？"></a>Q2：如何设置键过期？</h4><p><code>expire key seconds</code>：键在 seconds 秒后过期。</p><p>如果过期时间为负值，键会被立即删除，和 del 命令一样。persist 命令可以将键的过期时间清除。</p><p>对于字符串类型键，执行 set 命令会去掉过期时间，set 命令对应的函数 setKey 最后执行了 removeExpire 函数去掉了过期时间。setex 命令作为 set + expire 的组合，不单是原子执行并且减少了一次网络通信的时间。</p><hr><h4 id="Q3：如何进行键迁移？"><a href="#Q3：如何进行键迁移？" class="headerlink" title="Q3：如何进行键迁移？"></a>Q3：如何进行键迁移？</h4><ul><li><p>move</p><p>move 命令用于在 Redis 内部进行数据迁移，<code>move key db</code> 把指定的键从源数据库移动到目标数据库中。</p></li><li><p>dump + restore</p><p>可以实现在不同的 Redis 实例之间进行数据迁移，分为两步：</p><p>① <code>dump key</code> ，在源 Redis 上，dump 命令会将键值序列化，格式采用 RDB 格式。</p><p>② <code>restore key ttl value</code>，在目标 Redis 上，restore 命令将序列化的值进行复原，ttl 代表过期时间， ttl &#x3D; 0 则没有过期时间。</p><p>整个迁移并非原子性的，而是通过<a href>客户端</a>分步完成，并且需要两个<a href>客户端</a>。</p></li><li><p>migrate</p><p>实际上 migrate 命令就是将 dump、restore、del 三个命令进行组合，从而简化操作流程。migrate 具有原子性，支持多个键的迁移，有效提高了迁移效率。实现过程和 dump + restore 类似，有三点不同：</p><p>① 整个过程是原子执行，不需要在多个 Redis 实例开启<a href>客户端</a>。</p><p>② 数据传输直接在源 Redis 和目标 Redis 完成。</p><p>③ 目标 Redis 完成 restore 后会发送 OK 给源 Redis，源 Redis 接收后根据 migrate 对应选项来决定是否在源 Redis 上删除对应键。</p></li></ul><hr><h4 id="Q4：如何切换数据库？"><a href="#Q4：如何切换数据库？" class="headerlink" title="Q4：如何切换数据库？"></a>Q4：如何切换数据库？</h4><p><code>select dbIndex</code>，Redis 中默认配置有 16 个数据库，例如 select 0 将切换到第一个数据库，数据库之间的数据是隔离的。</p><hr><h4 id="Q5：如何清除数据库？"><a href="#Q5：如何清除数据库？" class="headerlink" title="Q5：如何清除数据库？"></a>Q5：如何清除数据库？</h4><p>用于清除数据库，flushdb 只清除当前数据库，flushall 会清除所有数据库。如果当前数据库键值数量比较多，flushdb&#x2F;flushall 存在阻塞 Redis 的可能性。</p><hr><h3 id="持久化-9"><a href="#持久化-9" class="headerlink" title="持久化 9"></a>持久化 9</h3><h4 id="Q1：RDB-持久化的原理？"><a href="#Q1：RDB-持久化的原理？" class="headerlink" title="Q1：RDB 持久化的原理？"></a>Q1：RDB 持久化的原理？</h4><p>RDB 持久化是把当前进程数据生成快照保存到硬盘的过程，触发 RDB 持久化过程分为手动触发和自动触发。</p><p>手动触发分别对应 save 和 bgsave 命令：</p><ul><li>save：阻塞当前 Redis 服务器，直到 RDB 过程完成为止，对于内存比较大的实例会造成长时间阻塞，线上环境不建议使用。 </li><li>bgasve：Redis 进程执行 fork 操作创建子进程，RDB 持久化过程由子进程负责，完成后自动结束。阻塞只发生在 fork 阶段，一般时间很短。bgsave 是针对 save 阻塞问题做的优化，因此 Redis 内部所有涉及 RDB 的操作都采用 bgsave 的方式，而 save 方式已经废弃。</li></ul><p>除了手动触发外，Redis 内部还存在自动触发 RDB 的持久化机制，例如：</p><ul><li>使用 save 相关配置，如 save m n，表示 m 秒内数据集存在 n 次修改时，自动触发 bgsave。 </li><li>如果从节点执行全量复制操作，主节点自动执行 bgsave 生成 RDB 文件并发送给从节点。 </li><li>执行 debug reload 命令重新加载 Redis 时也会自动触发 save 操作。 </li><li>默认情况下执行 shutdown 命令时，如果没有开启 AOF 持久化功能则自动执行 bgsave。</li></ul><hr><h4 id="Q2：bgsave-的原理？"><a href="#Q2：bgsave-的原理？" class="headerlink" title="Q2：bgsave 的原理？"></a>Q2：bgsave 的原理？</h4><p>① 执行 bgsave 命令，Redis 父进程判断当前是否存在正在执行的子进程，如 RDB&#x2F;AOF 子进程，如果存在 bgsave 命令直接返回。</p><p>② 父进程执行 fork 操作创建子进程，fork 操作过程中父进程会阻塞。</p><p>③ 父进程 fork 完成后，bgsave 命令返回并不再阻塞父进程，可以继续响应其他命令。</p><p>④ 子进程创建 RDB 文件，根据父进程内存生成临时快照文件，完成后对原有文件进行原子替换。</p><p>⑤ 进程发送信号给父进程表示完成，父进程更新统计信息。</p><hr><h4 id="Q3：RDB-持久化的优点？"><a href="#Q3：RDB-持久化的优点？" class="headerlink" title="Q3：RDB 持久化的优点？"></a>Q3：RDB 持久化的优点？</h4><p>RDB 是一个紧凑压缩的二进制文件，代表 Redis 在某个时间点上的数据快照。非常适合于备份，全量复制等场景。例如每 6 个消时执行 bgsave 备份，并把 RDB 文件拷贝到远程机器或者文件系统中，用于灾难恢复。</p><p>Redis 加载 RDB 恢复数据远远快于 AOF 的方式。</p><hr><h4 id="Q4：RDB-持久化的缺点？"><a href="#Q4：RDB-持久化的缺点？" class="headerlink" title="Q4：RDB 持久化的缺点？"></a>Q4：RDB 持久化的缺点？</h4><p>RDB 方式数据无法做到实时持久化&#x2F;秒级持久化，因为 bgsave 每次运行都要执行 fork 操作创建子进程，属于重量级操作，频繁执行成本过高。针对 RDB 不适合实时持久化的问题，Redis 提供了 AOF 持久化方式。</p><p>RDB 文件使用特定二进制格式保存，Redis 版本演进过程中有多个格式的 RDB 版本，存在老版本 Redis 服务无法兼容新版 RDB 格式的问题。</p><hr><h4 id="Q5：AOF-持久化的原理？"><a href="#Q5：AOF-持久化的原理？" class="headerlink" title="Q5：AOF 持久化的原理？"></a>Q5：AOF 持久化的原理？</h4><p>AOF 持久化以独立日志的方式记录每次写命令，重启时再重新执行 AOF 文件中的命令达到恢复数据的目的。AOF 的主要作用是解决了数据持久化的实时性，目前是 Redis 持久化的主流方式。</p><p>开启 AOF 功能需要设置：<code>appendonly yes</code>，默认不开启。保存路径同 RDB 方式一致，通过 dir 配置指定。</p><p>AOF 的工作流程操作：命令写入 append、文件同步 sync、文件重写 rewrite、重启加载 load：</p><ul><li>所有的写入命令会追加到 aof_buf 缓冲区中。 </li><li>AOF 缓冲区根据对应的策略向硬盘做同步操作。 </li><li>随着 AOF 文件越来越大，需要定期对 AOF 文件进行重写，达到压缩的目的。 </li><li>当服务器重启时，可以加载 AOF 文件进行数据恢复。</li></ul><hr><h4 id="Q6：AOF-命令写入的原理？"><a href="#Q6：AOF-命令写入的原理？" class="headerlink" title="Q6：AOF 命令写入的原理？"></a>Q6：AOF 命令写入的原理？</h4><p>AOF 命令写入的内容直接是文本协议格式，采用文本协议格式的原因：</p><ul><li>文本协议具有很好的兼容性。 </li><li>开启 AOF 后所有写入命令都包含追加操作，直接采用协议格式避免了二次处理开销。 </li><li>文本协议具有可读性，方便直接修改和处理。</li></ul><p>AOF 把命令追加到缓冲区的原因：</p><p>Redis 使用单线程响应命令，如果每次写 AOF 文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负载。先写入缓冲区中还有另一个好处，Redis 可以提供多种缓冲区同步硬盘策略，在性能和安全性方面做出平衡。</p><hr><h4 id="Q7：AOF-文件同步的原理？"><a href="#Q7：AOF-文件同步的原理？" class="headerlink" title="Q7：AOF 文件同步的原理？"></a>Q7：AOF 文件同步的原理？</h4><p>Redis 提供了多种 AOF 缓冲区文件同步策略，由参数 <code>appendfsync</code> 控制，不同值的含义如下：</p><ul><li>always：命令写入缓冲区后调用系统 fsync 操作同步到 AOF 文件，fsync 完成后线程返回。每次写入都要同步 AOF，性能较低，不建议配置。</li><li>everysec：命令写入缓冲区后调用系统 write 操作，write 完成后线程返回。fsync 同步文件操作由专门线程每秒调用一次。是建议的策略，也是默认配置，兼顾性能和数据安全。</li><li>no：命令写入缓冲区后调用系统 write 操作，不对 AOF 文件做 fsync 同步，同步硬盘操作由操作系统负责，周期通常最长 30 秒。由于操作系统每次同步 AOF 文件的周期不可控，而且会加大每次同步硬盘的数据量，虽然提升了性能，但安全性无法保证。</li></ul><hr><h4 id="Q8：AOF-文件重写的原理？"><a href="#Q8：AOF-文件重写的原理？" class="headerlink" title="Q8：AOF 文件重写的原理？"></a>Q8：AOF 文件重写的原理？</h4><p>文件重写是把 Redis 进程内的数据转化为写命令同步到新 AOF 文件的过程，可以降低文件占用空间，更小的文件可以更快地被加载。</p><p>重写后 AOF 文件变小的原因：</p><ul><li>进程内已经超时的数据不再写入文件。 </li><li>旧的 AOF 文件含有无效命令，重写使用进程内数据直接生成，这样新的 AOF 文件只保留最终数据写入命令。 </li><li>多条写命令可以合并为一个，为了防止单条命令过大造成<a href>客户端</a>缓冲区溢出，对于 list、set、hash、zset 等类型操作，以 64 个元素为界拆分为多条。</li></ul><p>AOF 重写分为手动触发和自动触发，手动触发直接调用 bgrewriteaof 命令，自动触发根据 <code>auto-aof-rewrite-min-size</code> 和 <code>auto-aof-rewrite-percentage</code> 参数确定自动触发时机。</p><p>重写流程：</p><p>① 执行 AOF 重写请求，如果当前进程正在执行 AOF 重写，请求不执行并返回，如果当前进程正在执行 bgsave 操作，重写命令延迟到 bgsave 完成之后再执行。</p><p>② 父进程执行 fork 创建子进程，开销等同于 bgsave 过程。</p><p>③ 父进程 fork 操作完成后继续响应其他命令，所有修改命令依然写入 AOF 缓冲区并同步到硬盘，保证原有 AOF 机制正确性。</p><p>④ 子进程根据内存快照，按命令合并规则写入到新的 AOF 文件。每次批量写入数据量默认为 32 MB，防止单次刷盘数据过多造成阻塞。</p><p>⑤ 新 AOF 文件写入完成后，子进程发送信号给父进程，父进程更新统计信息。</p><p>⑥ 父进程把 AOF 重写缓冲区的数据写入到新的 AOF 文件并替换旧文件，完成重写。</p><hr><h4 id="Q9：AOF-重启加载的原理？"><a href="#Q9：AOF-重启加载的原理？" class="headerlink" title="Q9：AOF 重启加载的原理？"></a>Q9：AOF 重启加载的原理？</h4><p>AOF 和 RDB 文件都可以用于服务器重启时的数据恢复。Redis 持久化文件的加载流程：</p><p>① AOF 持久化开启且存在 AOF 文件时，优先加载 AOF 文件。</p><p>② AOF 关闭时且存在 RDB 文件时，记载 RDB 文件。</p><p>③ 加载 AOF&#x2F;RDB 文件成功后，Redis 启动成功。</p><p>④ AOF&#x2F;RDB 文件存在错误导致加载失败时，Redis 启动失败并打印错误信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Java-基础-40&quot;&gt;&lt;a href=&quot;#Java-基础-40&quot; class=&quot;headerlink&quot; title=&quot;Java 基础 40&quot;&gt;&lt;/a&gt;Java 基础 40&lt;/h2&gt;&lt;h3 id=&quot;语言特性-12&quot;&gt;&lt;a href=&quot;#语言特性-12&quot; class</summary>
      
    
    
    
    <category term="Java" scheme="https://actionding.github.io/categories/Java/"/>
    
    <category term="面试" scheme="https://actionding.github.io/categories/Java/%E9%9D%A2%E8%AF%95/"/>
    
    
    <category term="Java" scheme="https://actionding.github.io/tags/Java/"/>
    
    <category term="面试" scheme="https://actionding.github.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Linux 笔记</title>
    <link href="https://actionding.github.io/2020/08/Linux%20%E7%AC%94%E8%AE%B0/"/>
    <id>https://actionding.github.io/2020/08/Linux%20%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-04T19:02:03.000Z</published>
    <updated>2021-02-18T03:09:34.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>学习Linux流程为：<br>第1阶段：Linux环境下的基本操作命令，包括文件操作命令（rm mkdir chmod，chown）编辑工具使用（vi vim）Linux用户管理（useradd userdel usermod）等。<br>第2阶段：Linux的各种配置（环境变量配置，网络配置，服务配置）。<br>第3阶段：Linux下如何搭建对应语言的开发环境（大数据，JavaEE，Python等）。<br>第4阶段：能编写sheLL脚本，对Linux服务器进行维护。<br>第5阶段：能进行安全设置，防止攻击，保障服务器正常运行，能对系统调优。<br>第6阶段：深入理解Linux系统（对内核有研究），熟练掌握大型网站应用架构组成、并熟悉各个环节的部署和维护方法。</p></blockquote><span id="more"></span><h2 id="第一章-Linux-概述"><a href="#第一章-Linux-概述" class="headerlink" title="第一章 Linux 概述"></a>第一章 Linux 概述</h2><p>Linux是一个开源、免费的操作系统，其稳定性、安全性、处理多并发已经得到业界的认可，目前很多中型，大型甚至是集群项目都在使用Linux，很多软件公司考虑到开发成本都首选Linux，在中国软件公司得到广泛的使用。</p><h3 id="1-1-准备工作"><a href="#1-1-准备工作" class="headerlink" title="1.1 准备工作"></a>1.1 准备工作</h3><ol><li>安装 VM 和 CentOS</li><li>安装 VM Tools，设置共享文件夹</li><li>安装 Xshell5 远程登陆</li><li>安装 Xftp5 远程上传和下载文件</li></ol><h3 id="1-2-Linux-目录结构"><a href="#1-2-Linux-目录结构" class="headerlink" title="1.2 Linux 目录结构"></a>1.2 Linux 目录结构</h3><p><img src="/.io//centos7-filesystem.png" alt="centos7-filesystem"></p><p><code>/bin</code>(<code>/usr/bin</code>, <code>/usr/local/bin</code>): 是 Binary 的缩写, 这个目录存放着最经常使用的<strong>命令</strong></p><p><code>/home</code>：存放普通用户的<strong>主目录</strong>，在 Linux 中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的</p><p><code>/root</code>：该目录为<strong>系统管理员</strong>，也称作超级权限者的用户主目录</p><p><code>/boot</code>：存放的是启动 Linux 时使用的一些<strong>核心文件</strong>，包括一些连接文件以及镜像文件</p><p><code>/media</code>：Linux 系统会自动识别一些<strong>设备</strong>，例如U盘、光驱等等，当识别后，Linux会 把识别的设备挂载到这个目录下</p><p><code>/mnt</code>：系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在 <code>/mnt/</code> 上，然后进入该目录就可以查看里的内容了</p><p><code>/usr/local</code>：这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序</p><p><code>/var</code>：这个目录存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件。</p><hr><p><code>/sbin</code>( <code>/usr/sbin</code>, <code>/usr/local/sbin</code>): s 就是 Super User 的意思，这里存放的是系统管理员使用的<strong>系统管理程序</strong></p><p><code>/etc</code>：所有的系统管理所需要的<strong>配置</strong>文件和子目录<code>my.conf</code></p><p><code>/proc</code>：这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。</p><p><code>/dev</code>：类似于 windows 的设备管理器，把所有的硬件用文件的形式存储。</p><p><code>/opt</code>：给主机额外安装软件所摆放的目录。</p><p><code>/tmp</code>：存放临时文件。</p><p><code>/var</code>：这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件</p><h3 id="1-3-Xshell5"><a href="#1-3-Xshell5" class="headerlink" title="1.3 Xshell5"></a>1.3 Xshell5</h3><p>Xshell5 是目前最好的远程登录到 Linux 操作的软件，流畅的速度并且完美解决了中文乱码问题，是目前程序员首选的软件。</p><h3 id="1-4-Xftp5"><a href="#1-4-Xftp5" class="headerlink" title="1.4 Xftp5"></a>1.4 Xftp5</h3><p>Xftp5 是一个基于 Windows 平台的功能强大的 SFTP、FTP 文件传输软件。使用了 Xftp 后，Windows 用户可以安全地在 Unix&#x2F;Linux 和 Windows PC 之间传输文件。</p><h2 id="第二章-Vi-和-Vim-编辑器"><a href="#第二章-Vi-和-Vim-编辑器" class="headerlink" title="第二章 Vi 和 Vim 编辑器"></a>第二章 Vi 和 Vim 编辑器</h2><h3 id="2-1-vi-和-vim-的基本介绍"><a href="#2-1-vi-和-vim-的基本介绍" class="headerlink" title="2.1 vi 和 vim 的基本介绍"></a>2.1 vi 和 vim 的基本介绍</h3><p>所有的Linux系统都会内建vi文本编辑器。</p><p>Vim具有程序编辑的能力，可以看做是Vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><h3 id="2-2-vi-和-vim-的三种常见模式"><a href="#2-2-vi-和-vim-的三种常见模式" class="headerlink" title="2.2 vi 和 vim 的三种常见模式"></a>2.2 vi 和 vim 的三种常见模式</h3><ol><li><p>正常模式</p><p>以 vim 打开一个文档进入此模式。</p><p>在正常模式下，可以使用上、下、左、右键移动光标，可以删除字符和删除整行（<code>dd</code>），还可以使用复制和粘贴功能。</p></li><li><p>插入模式</p><p>在此模式下，可以输入内容。</p><p>在正常模式下，按下 I、i（insert）、O、o（open）、A、a（append）、R、r（replace）、C、c（change）任何一个字母进入编辑模式。一般按 i 即可。</p></li><li><p>命令行模式</p><p>在此模式下，可以完成读取、存盘、替换、显示行号、退出 vim 等操作。</p><p><code>:q</code>：退出。</p><p><code>:q!</code>：强制不保存退出。</p><p><code>:qw!</code>：强制保存并退出。</p><p><code>:x</code>：保存并退出。</p><p><code>:w</code>：保存。</p><p><code>:w!</code>：强制保存。</p><p><code>:w filename</code>：文件另存为 filename。</p><p><code>n1,n2 w filename</code>：将 n1 行到 n2 行的数据另存为 filename。</p></li></ol><h3 id="2-3-快捷键键盘"><a href="#2-3-快捷键键盘" class="headerlink" title="2.3 快捷键键盘"></a>2.3 快捷键键盘</h3><p><img src="/.io//vim-sheet.gif" alt="vim-sheet"></p><h2 id="第三章-基本操作命令"><a href="#第三章-基本操作命令" class="headerlink" title="第三章 基本操作命令"></a>第三章 基本操作命令</h2><h3 id="3-1-关机-amp-重启命令"><a href="#3-1-关机-amp-重启命令" class="headerlink" title="3.1 关机&amp;重启命令"></a>3.1 关机&amp;重启命令</h3><p><code>shutdown -h now</code>：立刻关机</p><p><code>shutdown -h 1</code>：1分钟后关机</p><p><code>shutdown -r now</code>：重启</p><p><code>halt</code>：关机</p><p><code>reboot</code>：重启</p><p><code>sync</code>：把内存的数据同步到磁盘</p><blockquote><p>当我们关机或重启时，都应该先执行一下 <code>sync</code> 命令，把内存的数据写入磁盘，防止数据丢失。</p></blockquote><h3 id="3-2-用户登录与注销"><a href="#3-2-用户登录与注销" class="headerlink" title="3.2 用户登录与注销"></a>3.2 用户登录与注销</h3><p><code>su - username</code>：切换成系统管理员身份。</p><p><code>logout</code>：注销用户。</p><h3 id="3-3-用户管理"><a href="#3-3-用户管理" class="headerlink" title="3.3 用户管理"></a>3.3 用户管理</h3><p><code>useradd [username]</code>：添加用户</p><p><code>userdel [username]</code>：删除用户</p><p><code>passwd [username]</code>：指定&#x2F;修改密码</p><p><code>id [username]</code>：查询用户信息</p><p><code>su – [username]</code>：切换用户</p><ul><li>从权限高的用户切换到权限低的用户，不需要输入密码，反之需要</li><li>当需要返回到原来用户时，使用<code>exit</code>指令</li></ul><p><code>whoami</code>&#x2F;<code>who am I</code>：查看当前用户&#x2F;登录用户</p><h3 id="3-4-用户组"><a href="#3-4-用户组" class="headerlink" title="3.4 用户组"></a>3.4 用户组</h3><p><code>groupadd [groupname]</code>：新增组</p><p><code>groupdel [groupname]</code>：删除组</p><p><code>useradd -g [groupname] [username]</code>：添加用户时加入组</p><p><code>usermod -g [groupname] [username]</code>：修改用户的组</p><p> <strong>用户和组的相关文件</strong></p><p><code>/etc/passwd</code>：用户（user）的配置文件，记录用户的各种信息</p><p><code>/etc/shadow</code>：口令的配置文件</p><p><code>/etc/group</code>：组（group）的配置文件，记录Linux包含的组的信息</p><h3 id="3-5-帮助指令"><a href="#3-5-帮助指令" class="headerlink" title="3.5 帮助指令"></a>3.5 帮助指令</h3><p><code>man [命令或配置文件]</code>：获得帮助信息</p><p><code>help [命令]</code>：获得 shell 内置命令的帮助信息</p><h2 id="第四章-常用命令"><a href="#第四章-常用命令" class="headerlink" title="第四章 常用命令"></a>第四章 常用命令</h2><h3 id="4-1-指令的运行级别"><a href="#4-1-指令的运行级别" class="headerlink" title="4.1 指令的运行级别"></a>4.1 指令的运行级别</h3><ul><li>0：关机</li><li>1：单用户（找回丢失密码）</li><li>2：多用户无网络服务</li><li>3：多用户有网络服务</li><li>4：系统未使用，保留给用户</li><li>5：图形界面</li><li>6：系统重启</li></ul><p>常用的运行级别为 3 和 5。</p><p><code>init [0-6]</code>：切换到指定的运行级别。</p><p><code>/etc/inittab</code>：系统的运行级别配置文件。</p><p><code>id:5:initdefault</code>：默认的运行级别为 5。</p><p><strong>如何修改 root 密码？</strong></p><p>思路：进入到<strong>单用户模式</strong>，然后修改 root 密码。因为进入单用户模式，root 不需要密码就可以登录。</p><h3 id="4-2-文件目录类"><a href="#4-2-文件目录类" class="headerlink" title="4.2 文件目录类"></a>4.2 文件目录类</h3><h4 id="4-2-1-pwd-指令"><a href="#4-2-1-pwd-指令" class="headerlink" title="4.2.1 pwd 指令"></a>4.2.1 pwd 指令</h4><p><code>pwd</code>：显示当前工作目录的绝对路径。</p><h4 id="4-2-2-ls-指令"><a href="#4-2-2-ls-指令" class="headerlink" title="4.2.2 ls 指令"></a>4.2.2 ls 指令</h4><p><code>ls [选项] [目录或者文件]</code>：查看当前目录的所有内容信息。</p><p><strong>常用选项</strong></p><ul><li><code>-a</code>：显示当前目录所有的文件和目录，包括隐藏的。</li><li><code>-l</code>：以列表的方式显示信息。</li></ul><h4 id="4-2-3-cd-指令"><a href="#4-2-3-cd-指令" class="headerlink" title="4.2.3 cd 指令"></a>4.2.3 cd 指令</h4><p><code>cd [参数]</code>：切换到指定目录。</p><ul><li><code>cd ~</code>或<code>cd </code>：回到自己的家目录。</li><li><code>cd ..</code>：回到当前目录的上一级目录。</li></ul><h4 id="4-3-4-mkdir-指令"><a href="#4-3-4-mkdir-指令" class="headerlink" title="4.3.4 mkdir 指令"></a>4.3.4 mkdir 指令</h4><p><code>mkdir [选项]</code>：创建目录。</p><ul><li><code>-p</code>：创建多级目录。</li></ul><h4 id="4-3-5-rmdir-指令"><a href="#4-3-5-rmdir-指令" class="headerlink" title="4.3.5 rmdir 指令"></a>4.3.5 rmdir 指令</h4><p><code>rmdir [选项]</code>：删除<strong>空</strong>目录。</p><ul><li><code>rm -rf</code>：删除非空目录。</li></ul><h4 id="4-3-6-touch-指令"><a href="#4-3-6-touch-指令" class="headerlink" title="4.3.6 touch 指令"></a>4.3.6 touch 指令</h4><p><code>touch [文件名]</code>：创建空文件。</p><h4 id="4-3-7-cp-指令"><a href="#4-3-7-cp-指令" class="headerlink" title="4.3.7 cp 指令"></a>4.3.7 cp 指令</h4><p><code>cp [选项] [source dest]</code>：复制文件到指定目录。</p><ul><li><p><code>-r</code>：递归复制整个文件夹</p></li><li><p><code>\cp</code>：强制覆盖不提示，如：<code>\cp -r aaa/ bbb/</code></p></li></ul><h4 id="4-3-8-rm-指令"><a href="#4-3-8-rm-指令" class="headerlink" title="4.3.8 rm 指令"></a>4.3.8 rm 指令</h4><p><code>rm [选项]</code>：删除文件或目录。</p><ul><li><code>-r</code>：递归删除整个文件夹。</li><li><code>-f</code>：强制删除不提示。</li></ul><h4 id="4-3-9-mv-指令"><a href="#4-3-9-mv-指令" class="headerlink" title="4.3.9 mv 指令"></a>4.3.9 mv 指令</h4><p><code>rm [oldFileName] [newFileName]</code>：重命名。</p><p><code>mv [moveFileName] [targetFolder]</code>：移动文件。</p><h4 id="4-3-10-cat-指令"><a href="#4-3-10-cat-指令" class="headerlink" title="4.3.10 cat 指令"></a>4.3.10 cat 指令</h4><p><code>cat [选项]</code>：查看文件的内容，只以读的方式打开。</p><ul><li><code>-n</code>：显示行号。</li></ul><h4 id="4-3-11-more-指令"><a href="#4-3-11-more-指令" class="headerlink" title="4.3.11 more 指令"></a>4.3.11 more 指令</h4><p><code>more [fileName]</code>：基于 vim 编辑器的文本过滤器，它以全屏幕的方式按页显示文件的内容。</p><ul><li><code>space</code>：向下翻一页。</li><li><code>Enter</code>：向下翻一行。</li><li><code>q</code>：退出 more 指令。</li><li>Ctrl + F&#96;：向下滚动一屏。</li><li>Ctrl + B&#96;：向上滚动一屏。</li><li><code>=</code>：输出当前行号。</li><li><code>:f</code>：输出文件名和当前行号。</li></ul><h4 id="4-3-12-less-指令"><a href="#4-3-12-less-指令" class="headerlink" title="4.3.12 less 指令"></a>4.3.12 less 指令</h4><p><code>less [fileName]</code>：分屏查看文件内容。</p><ul><li><code>space</code>：向下翻一页。</li><li><code>pageup</code>：向上翻一页。</li><li><code>pagedown</code>：向下翻一页。</li><li><code>/字符串</code>：向下搜寻字符串，<code>n</code>：向下查找；<code>N</code>：向上查找。</li><li><code>?字符串</code>：向上搜寻字符串，<code>n</code>：向下查找；<code>N</code>：向上查找。</li><li>q&#96;：退出 less 指令。</li></ul><h4 id="4-3-13-gt-指令和-gt-gt-指令"><a href="#4-3-13-gt-指令和-gt-gt-指令" class="headerlink" title="4.3.13 &gt; 指令和 &gt;&gt; 指令"></a>4.3.13 &gt; 指令和 &gt;&gt; 指令</h4><p><code>&gt;</code> ：输出重定向，会覆盖原来的文件的内容。</p><p><code>&gt;&gt;</code>：追加，在文件的尾部追加。</p><ul><li><code>ls -l &gt; [fileName]</code>：将列表的内容写入文件中（覆盖写），如果文件不存在就创建该文件。</li><li><code>ls -al &gt;&gt; [fileName]</code>：将列表的内容写入文件中（追加写），如果文件不存在就创建该文件。</li><li><code>cat [fileName1] &gt; [fileName2]</code></li><li><code>echo 字符串&gt;&gt; [fileName]</code></li></ul><h4 id="4-3-14-echo-指令"><a href="#4-3-14-echo-指令" class="headerlink" title="4.3.14 echo 指令"></a>4.3.14 echo 指令</h4><p><code>echo [选项] [输出内容]</code>：输出内容到控制台。</p><h4 id="4-3-15-head-指令"><a href="#4-3-15-head-指令" class="headerlink" title="4.3.15 head 指令"></a>4.3.15 head 指令</h4><p><code>head [fileName]</code>：显示文件的开头部分内容，默认前十行内容。</p><ul><li><code>head -n [number] [fileName]</code>：查看文件前 <code>number</code> 行内容。</li></ul><h4 id="4-3-16-tail-指令"><a href="#4-3-16-tail-指令" class="headerlink" title="4.3.16 tail 指令"></a>4.3.16 tail 指令</h4><p>tail [fileName]&#96;：显示文件的开头部分内容，默认前十行内容。</p><ul><li>tail -n [number] [fileName]<code>：查看文件前 </code>number&#96; 行内容。</li><li>tail -f [fileName]&#96;：实时追踪该文档的所有更新。</li></ul><h4 id="4-3-17-ln-指令"><a href="#4-3-17-ln-指令" class="headerlink" title="4.3.17 ln 指令"></a>4.3.17 ln 指令</h4><p><code>ln -s [原文件或目录] [软链接名]</code>：给原文件或目录创建一个软链接。</p><h4 id="4-3-18-history-指令"><a href="#4-3-18-history-指令" class="headerlink" title="4.3.18 history 指令"></a>4.3.18 history 指令</h4><p><code>history</code>：查看已经执行过的历史命令。</p><ul><li><code>history [number]</code>：查看最近执行 <code>number</code> 个指令。</li><li><code>![行号]</code>：执行行号对应的指令。</li></ul><h3 id="4-4-时间日期类"><a href="#4-4-时间日期类" class="headerlink" title="4.4 时间日期类"></a>4.4 时间日期类</h3><h4 id="4-4-1-date-指令"><a href="#4-4-1-date-指令" class="headerlink" title="4.4.1 date 指令"></a>4.4.1 date 指令</h4><p><code>date</code>：显示当前时间。</p><ul><li><code>date +%Y</code>：显示当前年份。</li><li><code>date +%m</code>：显示当前月份。</li><li><code>date +%d</code>：显示当前天数。</li><li><code>date &quot;+%Y-%m-%d %H:%M:%S&quot;</code>：显示年月日时分秒。</li><li><code>date -s [字符串时间]</code>：设置系统当前时间。</li></ul><h4 id="4-4-2-cal-指令"><a href="#4-4-2-cal-指令" class="headerlink" title="4.4.2 cal 指令"></a>4.4.2 cal 指令</h4><p><code>cal</code>：显示本月日历。</p><ul><li><code>cal [年份]</code>：显示年日历。</li></ul><h3 id="4-5-搜索查找类"><a href="#4-5-搜索查找类" class="headerlink" title="4.5 搜索查找类"></a>4.5 搜索查找类</h3><h4 id="4-5-1-find-指令"><a href="#4-5-1-find-指令" class="headerlink" title="4.5.1 find 指令"></a>4.5.1 find 指令</h4><p><code>find [搜索范围] [选项]</code>：从指定目录向下递归地遍历各个子目录，将满足条件的文件或者目录显示在终端。</p><ul><li><code>-name</code>：按照指定的文件名查找模式查找文件。</li><li><code>-user</code>：查找属于指定用户名的所有文件。</li><li><code>-size</code>：按照指定的文件大小查找文件。</li></ul><h4 id="4-5-2-locate-指令"><a href="#4-5-2-locate-指令" class="headerlink" title="4.5.2 locate 指令"></a>4.5.2 locate 指令</h4><p><code>locate [fileName]</code>：快速定位文件路径。</p><p>4.5.2 grep 指令和管道符号 |</p><p><code>grep [选项] [查找内容] [源文件]</code>：过滤查找。</p><p><code>|</code>：管道符，表示将前一个命令的处理结果输出传递给后面的命令处理。</p><ul><li><code>-n</code>：显示匹配行及行号。</li><li><code>-i</code>：忽略字母大小写。</li></ul><p>如：<code>cat hello.txt | grep -ni yes</code></p><h3 id="4-6-压缩和解压类"><a href="#4-6-压缩和解压类" class="headerlink" title="4.6 压缩和解压类"></a>4.6 压缩和解压类</h3><h4 id="4-6-1-gzip-x2F-gunzip-指令"><a href="#4-6-1-gzip-x2F-gunzip-指令" class="headerlink" title="4.6.1 gzip&#x2F;gunzip 指令"></a>4.6.1 gzip&#x2F;gunzip 指令</h4><p><code>gzip [fileName]</code>：压缩文件，只能将文件压缩为 <code>*.gz</code> 文件。</p><p><code>gunzip [fileName]</code>：解压缩文件命令。</p><p>使用 <code>gzip</code> 对文件进行压缩后，不会保留原来的文件。</p><h4 id="4-6-1-zip-x2F-uzip-指令"><a href="#4-6-1-zip-x2F-uzip-指令" class="headerlink" title="4.6.1 zip&#x2F;uzip 指令"></a>4.6.1 zip&#x2F;uzip 指令</h4><p><code>zip [选项] xxx.zip</code>：压缩文件和目录。</p><ul><li><code>-r</code>：递归压缩，即压缩目录。</li><li>如：<code>zip -r package.zip /home/test/</code></li></ul><p><code>uzip [选项] xxx.zip</code>：解压缩文件。</p><ul><li><code>-d [目录]</code>：指定压缩后的文件存放目录。</li><li>如：<code>unzip -d /opt/tmp/ package.zip</code></li></ul><h4 id="4-6-3-tar-指令"><a href="#4-6-3-tar-指令" class="headerlink" title="4.6.3 tar 指令"></a>4.6.3 tar 指令</h4><p><code>tar [选项] xxx.tar.gz</code>：打包目录，压缩后的文件格式为 <code>xxx.tar.gz</code>。</p><ul><li><code>-c</code>：产生 <code>.tar</code> 打包文件。</li><li><code>-x</code>：解包 <code>.tar</code> 文件。</li><li><code>-v</code>：显示详细信息。</li><li><code>-f</code>：指定压缩后的文件名。</li><li><code>-z</code>：打包同时压缩。</li><li></li><li>如：<code>tar -zcvf myhome.tar.gz /home/</code>（将 <code>/home</code> 的文件夹压缩为 <code>myhome.tar.gz</code>）。</li><li>如：<code>tar -zxvf a.tar.gz</code>（将 <code>a.tar.gz</code> 解压到当前目录）。</li></ul><h2 id="第五章-组管理和权限管理"><a href="#第五章-组管理和权限管理" class="headerlink" title="第五章 组管理和权限管理"></a>第五章 组管理和权限管理</h2><h3 id="5-1-Linux-组基本介绍"><a href="#5-1-Linux-组基本介绍" class="headerlink" title="5.1 Linux 组基本介绍"></a>5.1 Linux 组基本介绍</h3><p>在 Linux 中的每个用户必须属于一个组，不能独立于组外。在 Linux 中每个文件有所有者、所在组、其他组的概念。</p><p><strong>1）所有者</strong></p><p>一般文件的创建者就是该文件的所有者。</p><p><code>ls -ahl</code>：查看文件的所有者。</p><p><code>chown [用户名] [文件名]</code>：修改文件的所有者。</p><p><code>chown [newowner]:[newgroup] [fileName]</code> ：改变用户的所有者和所有组。</p><p><code>-R</code>：如果是目录则使其下所有子文件或目录递归生效。</p><p><strong>2）所在组</strong></p><p><code>groupadd [组名]</code>：创建组。</p><p><code>ls -ahl</code>：查看文件的所在组。</p><p><code>chgrp [组名] [文件名]</code>：修改文件所在组。</p><p><strong>3）其他组</strong></p><p>除文件的所有者和所在组的用户外，系统的其他用户都是文件的其他组。</p><p><strong>4）改变用户所在组</strong></p><p><code>usermod -g [组名] [用户名]</code>：改变用户所在组。</p><p><code>usermod -d [目录名] [用户名]</code>：改变该用户登录的初始目录。</p><h3 id="5-2-权限的基本介绍"><a href="#5-2-权限的基本介绍" class="headerlink" title="5.2 权限的基本介绍"></a>5.2 权限的基本介绍</h3><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# ls -l</span><br><span class="line">总用量 0</span><br><span class="line">-rw-r--r--. 1 root root 0 12月 25 04:12 a.txt</span><br><span class="line">0123456789</span><br></pre></td></tr></table></figure><p><strong>0-9 位说明</strong></p><p>第 0 位：确定文件的类型（d，-，l，c，b 分别表示目录、文件、链接、字符设备文件、块设备文件）。</p><p>第 1-3 位：确定所有者拥有该文件的权限。（User）</p><p>第 4-6 位：确定所属组拥有该文件的权限。（Group）</p><p>第 7-9 位：确定其他用户拥有该文件的权限。（Other）</p><p><strong>1）rwx 权限详解</strong></p><p><strong>rwx 作用到文件</strong></p><p><code>[r]</code>代表可读（read）：可以读取、查看。</p><p><code>[w]</code>代表可写（write）：可以修改。（但是不代表可以删除该文件，删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件。）</p><p><code>[x]</code>代表可执行（execute）：可以被执行。</p><p><strong>rwx 作用到目录</strong></p><p><code>[r]</code>代表可读（read）：可以读取，通过 <code>ls</code> 查看目录内容。</p><p><code>[w]</code>代表可写（write）：可以修改，目录内创建、删除、重命名目录。</p><p><code>[x]</code>代表可执行（execute）：可以进入该目录。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-rwxrw-r-- 1 root root 1213 Feb 2 09:39 abc</span><br><span class="line">10 个字符确定不同用户能对文件干什么</span><br><span class="line">第一个字符代表文件类型： 文件 (-),目录(d),链接(l)</span><br><span class="line">其余字符每3 个一组(rwx) 读(r) 写(w) 执行(x)</span><br><span class="line">第一组rwx : 文件拥有者的权限是读、写和执行</span><br><span class="line">第二组rw- : 与文件拥有者同一组的用户的权限是读、写但不能执行</span><br><span class="line">第三组r-- :不与文件拥有者同组的其他用户的权限是读不能写和执行</span><br><span class="line">可用数字表示为: r=4,w=2,x=1 因此rwx=4+2+1=7</span><br><span class="line">1 文件：硬连接数或 目录：子目录数</span><br><span class="line">root 用户</span><br><span class="line">root 组</span><br><span class="line">1213 文件大小(字节)，如果是文件夹，显示 4096 字节</span><br><span class="line">Feb 2 09:39  最后修改日期</span><br><span class="line">abc 文件名</span><br></pre></td></tr></table></figure><h3 id="5-3-修改权限-chmod"><a href="#5-3-修改权限-chmod" class="headerlink" title="5.3 修改权限 chmod"></a>5.3 修改权限 chmod</h3><p>通过 <code>chmod</code> 指令，可以修改文件或者目录的权限。</p><p><strong>1）通过 <code>+</code>、<code>-</code>、<code>=</code> 变更权限</strong></p><p><code>u</code>：表示所有者</p><p><code>g</code>：表示所有组</p><p><code>o</code>：表示其他人</p><p><code>a</code>：表示所有人(u、g、o 的总和)</p><p><code>chmod u=rwx,g=rx,o=x [文件目录名]</code>：所有者读写执行的权限，所有组读执行的权限，其他人执行的权限。</p><p><code>chmod o+w [文件目录名]</code>：其他人增加写的权限。</p><p><code>chmod a-x [文件目录名]</code>：所有人除去执行的权限。</p><p><strong>2）通过数字变更权限</strong></p><p>规则：<code>r=4</code>、<code>w=2</code>、<code>x=1</code> ，<code>rwx=4+2+1=7</code></p><p><code>chmod u=rwx,g=rx,o=x [文件目录名]</code> 相当于 <code>chmod 751 文件目录名]</code></p><h2 id="第六章-CROND-任务调度"><a href="#第六章-CROND-任务调度" class="headerlink" title="第六章 CROND 任务调度"></a>第六章 CROND 任务调度</h2><h3 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h3><h2 id="第七章-LINUX-磁盘分区、挂载"><a href="#第七章-LINUX-磁盘分区、挂载" class="headerlink" title="第七章 LINUX 磁盘分区、挂载"></a>第七章 LINUX 磁盘分区、挂载</h2><h3 id="7-1-分区基础知识"><a href="#7-1-分区基础知识" class="headerlink" title="7.1 分区基础知识"></a>7.1 分区基础知识</h3><p><strong>1）MBR 分区</strong></p><ol><li>最多支持四个主分区。</li><li>系统只能安装在主分区。</li><li>扩展分区要占一个主分区。</li><li>MBR 最大支持 2TB，但拥有最好的兼容性。</li></ol><p><strong>2）GTP 分区</strong></p><ol><li>支持无线多个分区。（但操作系统可能限制，比如：windows 下最多 128 个分区。）</li><li>最大支持 18EB 的大容量。（1 EB &#x3D; 1024 PB，1 PB &#x3D; 1024 TB）</li><li>windows7 64 位以后支持 GTP。</li></ol><h3 id="7-2-Linux-分区"><a href="#7-2-Linux-分区" class="headerlink" title="7.2 Linux 分区"></a>7.2 Linux 分区</h3><p><strong>1）原理介绍</strong></p><p>Linux 来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构, Linux 中每个分区都是用来组成整个文件系统的一部分。</p><p>Linux 采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录，且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。</p><p><strong>2）硬盘说明</strong></p><p>Linux 硬盘分 IDE 硬盘和 SCSI 硬盘，目前基本上是 SCSI 硬盘。</p><p>对于 <strong>IDE 硬盘</strong>，驱动器标识符为“hdx~”，其中“hd”表明分区所在设备的类型，这里是指 IDE 硬盘了。</p><p>对于 <strong>SCSI 硬盘</strong>，则标识为“sdx~”，SCSI 硬盘是用“sd”来表示分区所在设备的类型的。</p><p>“x”为盘号（a 为基本盘，b 为基本从属盘，c 为辅助主盘，d 为辅助从属盘），“~”代表分区，前四个分区用数字 1 到 4 表示，它们是主分区或扩展分区，从 5 开始就是逻辑分区。</p><p><code>lsblk</code>：查看当前系统的分区情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# lsblk -f</span><br><span class="line">NAME   FSTYPE  LABEL           UUID                                 MOUNTPOINT</span><br><span class="line">sda                                                                 </span><br><span class="line">├─sda1 xfs                     b4957853-a1e7-48ae-89e9-18026483c661 /boot</span><br><span class="line">├─sda2 swap                    420f1351-c5d5-42c9-90fd-eb6b892b8bab [SWAP]</span><br><span class="line">└─sda3 xfs                     69e02e9e-4b77-4ad9-b656-49495852df04 /</span><br><span class="line">sr0    iso9660 CentOS 7 x86_64 2020-04-22-00-54-00-00               /run/media/r</span><br></pre></td></tr></table></figure><h3 id="7-3-挂载的经典案例"><a href="#7-3-挂载的经典案例" class="headerlink" title="7.3 挂载的经典案例"></a>7.3 挂载的经典案例</h3><ol><li>虚拟机添加硬盘</li><li>分区 <code>fdisk /dev/sdb</code></li><li>格式化 <code>mkfs -t ext4 /dev/sdb1</code></li><li>挂载先创建一个 <code>/home/newdisk</code>，挂载 <code>mount /dev/sdb1 /home/newdisk</code></li><li>设置可以自动挂载(永久挂载，当你重启系统，仍然可以挂载到 <code>/home/newdisk</code>) 。</li></ol><h3 id="7-4-磁盘情况查询"><a href="#7-4-磁盘情况查询" class="headerlink" title="7.4 磁盘情况查询"></a>7.4 磁盘情况查询</h3><p><code>df -h</code>：查询系统整体磁盘使用情况。</p><p><code>du -h [目录]</code>：查询指定目录的磁盘占用情况。</p><ul><li><code>-s</code> 指定目录占用大小汇总</li><li><code>-h</code> 带计量单位</li><li><code>-a</code> 含文件</li><li><code>--max-depth=1</code> 子目录深度</li><li><code>-c</code> 列出明细的同时，增加汇总值</li></ul><h2 id="第八章-网络配置"><a href="#第八章-网络配置" class="headerlink" title="第八章 网络配置"></a>第八章 网络配置</h2><h3 id="8-1-Linux-网络环境配置"><a href="#8-1-Linux-网络环境配置" class="headerlink" title="8.1 Linux 网络环境配置"></a>8.1 Linux 网络环境配置</h3><p><strong>1）自动获取</strong></p><p>Linux 启动后会自动获取 ip，每次自动获取的 ip 地址<strong>可能不一样</strong>。这个不适用于做服务器，因为我们的服务器的 ip 需要时固定的。</p><p><strong>2）指定固定的 ip</strong></p><p>直接修改配置文件来指定 ip。</p><h3 id="8-2-CentOS6-网络配置"><a href="#8-2-CentOS6-网络配置" class="headerlink" title="8.2 CentOS6 网络配置"></a>8.2 CentOS6 网络配置</h3><p><strong>1）修改配置文件</strong></p><p><code>vim /etc/sysconfig/network-scripts/ifcfg-eth0</code>：CentOS6 修改配置文件。</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 修改前</span><br><span class="line">DEVICE=eth0# 接口名（设备，网卡）</span><br><span class="line">HWADDR=00:0C:29:8B:B7:47 # MAC地址</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">UUID=c5e56ef8-bbe0-4dbc-bffd-46dd1c23d001</span><br><span class="line">ONBOOT=no</span><br><span class="line">NM_CONTROLLED=yes</span><br><span class="line">BOOTPROTO=dhcp</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 修改后</span><br><span class="line">DEVICE=eth0</span><br><span class="line">HWADDR=00:0C:29:8B:B7:47</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">UUID=c5e56ef8-bbe0-4dbc-bffd-46dd1c23d001</span><br><span class="line">ONBOOT=yes</span><br><span class="line">NM_CONTROLLED=yes</span><br><span class="line">BOOTPROTO=static</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>2）重启服务</strong></p><p>① <code>service network restart</code>：重启网络服务。</p><p>② <code>reboot</code>：重启。</p><h3 id="8-3-CentOS7-网络配置"><a href="#8-3-CentOS7-网络配置" class="headerlink" title="8.3 CentOS7 网络配置"></a>8.3 CentOS7 网络配置</h3><p><code>vim /etc/sysconfig/network-scripts/ifcfg-ens33</code>：CentOS7 修改配置文件。</p><p>将<code>ONBOOT=no</code> 改为&#96;&#96;ONBOOT&#x3D;yes<code>，将 </code>BOOTPROTO&#x3D;dhcp<code>改为</code>BOOTPROTO&#x3D;static&#96;，并在后面增加几行内容：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">IPADDR=192.168.127.128</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.127.2</span><br><span class="line">DNS1=119.29.29.29</span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 修改前</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=dhcp </span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=6fe8a9de-cc48-47a6-a6b8-cf0e63bdc58b</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=no </span><br></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 修改后</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=ens33</span><br><span class="line">UUID=6fe8a9de-cc48-47a6-a6b8-cf0e63bdc58b</span><br><span class="line">DEVICE=ens33</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=192.168.127.128</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=192.168.127.2</span><br><span class="line">DNS1=119.29.29.29</span><br></pre></td></tr></table></figure><p><strong>2）重启服务</strong></p><p><code>systemctl restart network.service</code>：来重启网络服务</p><h2 id="第九章-进程管理"><a href="#第九章-进程管理" class="headerlink" title="第九章 进程管理"></a>第九章 进程管理</h2><h2 id="第十章-RPM-和-YUM"><a href="#第十章-RPM-和-YUM" class="headerlink" title="第十章 RPM 和 YUM"></a>第十章 RPM 和 YUM</h2><h3 id="10-1-rpm-包管理"><a href="#10-1-rpm-包管理" class="headerlink" title="10.1 rpm 包管理"></a>10.1 rpm 包管理</h3><h4 id="10-1-1-介绍"><a href="#10-1-1-介绍" class="headerlink" title="10.1.1 介绍"></a>10.1.1 介绍</h4><p>一种用于互联网下载包的打包及安装工具，它包含在某些 Linux 分发版中。它生成具有 <code>.prm</code> 扩展名的文件。PRM 是 RedHat Package Manager（RedHat 软件管理工具）的缩写。</p><h4 id="10-1-2-基本格式"><a href="#10-1-2-基本格式" class="headerlink" title="10.1.2 基本格式"></a>10.1.2 基本格式</h4><p><code>rpm</code> 包名：<code>名称-版本号-适用的操作系统.rpm</code></p><p><code>i686</code>、<code>i386</code> 表示 32 位系统，<code>noarch</code> 表示通用。</p><h4 id="10-1-3-简单查询指令"><a href="#10-1-3-简单查询指令" class="headerlink" title="10.1.3 简单查询指令"></a>10.1.3 简单查询指令</h4><p><code>rpm -qa | grep [软件名]</code>：查看当前是否安装某软件。</p><h4 id="10-1-4-其他查询指令"><a href="#10-1-4-其他查询指令" class="headerlink" title="10.1.4 其他查询指令"></a>10.1.4 其他查询指令</h4><p><code>rpm -qa</code></p><p>&#96;rpm -</p><h3 id="10-2-yum"><a href="#10-2-yum" class="headerlink" title="10.2 yum"></a>10.2 yum</h3><h4 id="10-2-1-介绍"><a href="#10-2-1-介绍" class="headerlink" title="10.2.1 介绍"></a>10.2.1 介绍</h4><h2 id="第十一章-shell-编程"><a href="#第十一章-shell-编程" class="headerlink" title="第十一章 shell 编程"></a>第十一章 shell 编程</h2><h3 id="11-1-shell-编程入门"><a href="#11-1-shell-编程入门" class="headerlink" title="11.1 shell 编程入门"></a>11.1 shell 编程入门</h3><p>Shell 是一个命令行解释器，它为用户提供了一个向 Linux 内核发送请求以便运行程序的界面系统级程序，用户可以用 Shell 来启动、挂起、停止甚至是编写一些程序。</p><p><strong>1）shell 脚本的格式要求</strong></p><p>① 以 <code>#!/bin/bash</code> 开头。</p><p>② 需要有可执行权限。</p><p><strong>2）第一个 shell 脚本</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;hello,world!&quot;</span><br></pre></td></tr></table></figure><p><strong>3）脚本的常用执行方式</strong></p><p>① 输入脚本的绝对路径或相对路径。</p><p>首先要赋予脚本执行权限。</p><p>② sh + 脚本。（不推荐！）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# chmod 744 hello.sh </span><br><span class="line">[root@localhost test]# ll</span><br><span class="line">总用量 4</span><br><span class="line">-rwxr--r--. 1 root root 32 12月 25 22:29 hello.sh</span><br><span class="line">[root@localhost test]# ./hello.sh </span><br><span class="line">hello,world!</span><br><span class="line">[root@localhost test]# /test/hello.sh </span><br><span class="line">hello,world!</span><br></pre></td></tr></table></figure><h3 id="11-2-shell-变量"><a href="#11-2-shell-变量" class="headerlink" title="11.2 shell 变量"></a>11.2 shell 变量</h3><p><strong>1）shell 的变量的介绍</strong></p><p>Linux Shell 中的变量分为<strong>系统变量</strong>和<strong>用户自定义变量</strong>。</p><p><strong>系统变量</strong>：<code>$HOME</code>、<code>$PWD</code>、<code>$SHELL</code>、<code>$USER</code> 等等.</p><p><code>set</code>：显示当前 shell 中所有变量。</p><p><strong>2）shell 变量的定义</strong></p><p>定义变量：<code>变量=值</code></p><p>撤销变量：<code>unset 变量</code></p><p>声明<strong>静态变量</strong>：<code>readonly 变量</code>，注意：不能 unset</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="language-bash">!/bin/bash</span></span><br><span class="line">echo &quot;PATH=$PATH&quot;</span><br><span class="line">echo &quot;user=$USER&quot;</span><br><span class="line"></span><br><span class="line">A=100</span><br><span class="line">ehco &quot;A=$A&quot;</span><br><span class="line">unset A</span><br><span class="line">echo &quot;A=$A&quot;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# ./hello.sh </span><br><span class="line">PATH=/opt/jdk1.8.0_271/bin:/usr/local/mysql/bin:/usr/local/bin:/usr/local/sbin:/usr/bin:/usr/sbin:/bin:/sbin:/root/bin</span><br><span class="line">user=root</span><br><span class="line">A=100</span><br><span class="line">A=</span><br></pre></td></tr></table></figure><p><strong>3）定义变量的规则</strong></p><ol><li>变量名称可以由字母、数字和下划线组成，但是不能以数字开头。</li><li>等号两侧不能有空格。</li><li>变量名称一般习惯为大写。</li></ol><p><strong>4）将命令的返回值赋给变量（重点）</strong></p><ol><li>A&#x3D; <code>`ls -la`</code> 反引号，运行里面的命令，并把结果返回给变量 A。</li><li>A&#x3D;$(ls -la) 等价于反引号</li></ol>]]></content>
    
    
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;学习Linux流程为：&lt;br&gt;第1阶段：Linux环境下的基本操作命令，包括文件操作命令（rm mkdir chmod，chown）编辑工具使用（vi vim）Linux用户管理（useradd userdel usermod）等。&lt;br&gt;第2阶段：Linux的各种配置（环境变量配置，网络配置，服务配置）。&lt;br&gt;第3阶段：Linux下如何搭建对应语言的开发环境（大数据，JavaEE，Python等）。&lt;br&gt;第4阶段：能编写sheLL脚本，对Linux服务器进行维护。&lt;br&gt;第5阶段：能进行安全设置，防止攻击，保障服务器正常运行，能对系统调优。&lt;br&gt;第6阶段：深入理解Linux系统（对内核有研究），熟练掌握大型网站应用架构组成、并熟悉各个环节的部署和维护方法。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://actionding.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://actionding.github.io/tags/Linux/"/>
    
    <category term="编程" scheme="https://actionding.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis 笔记</title>
    <link href="https://actionding.github.io/2020/08/MyBatis%20%E7%AC%94%E8%AE%B0/"/>
    <id>https://actionding.github.io/2020/08/MyBatis%20%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-04T19:02:03.000Z</published>
    <updated>2022-03-08T12:39:02.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第1章-简介"><a href="#第1章-简介" class="headerlink" title="第1章 简介"></a>第1章 简介</h2><p><a href="https://mybatis.org/mybatis-3/zh/index.html">MyBatis</a> 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。</p><span id="more"></span><h2 id="第2章-入门案例"><a href="#第2章-入门案例" class="headerlink" title="第2章 入门案例"></a>第2章 入门案例</h2><ol><li><p>创建一张测试表 employee</p></li><li><p>创建对应的 JavaBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Employee</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span> Integer id;</span><br><span class="line"><span class="keyword">private</span> String empName;</span><br><span class="line"><span class="keyword">private</span> String email;</span><br><span class="line"><span class="keyword">private</span> Integer gender;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(Integer id)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.id = id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getEmpName</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> empName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmpName</span><span class="params">(String empName)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.empName = empName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">getEmail</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setEmail</span><span class="params">(String email)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.email = email;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">getGender</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setGender</span><span class="params">(Integer gender)</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.gender = gender;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Employee [id=&quot;</span> + id + <span class="string">&quot;, empName=&quot;</span> + empName + <span class="string">&quot;, email=&quot;</span> + email + <span class="string">&quot;, gender=&quot;</span> + gender + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">EmployeeDao</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> Employee <span class="title function_">getEmpById</span><span class="params">(Integer id)</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://github.com/mybatis/mybatis-3/releases">导包</a></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log4j-1.2.17.jar</span><br><span class="line">mybatis-3.5.5.jar</span><br><span class="line">mysql-connector-java-5.1.7-bin.jar</span><br></pre></td></tr></table></figure></li><li><p>创建 MyBatis 配置文件，sql 映射文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;development&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/mybatis&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ding32&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">resource</span>=<span class="string">&quot;EmployeeDao.xml&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- EmployeeDao.xml --&gt;</span></span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">mapper</span></span></span><br><span class="line"><span class="meta">  <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">  <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">&quot;com.ding.dao.EmployeeDao&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">&quot;getEmpById&quot;</span> <span class="attr">resultType</span>=<span class="string">&quot;com.ding.bean.Employee&quot;</span>&gt;</span></span><br><span class="line">select * from employee where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>测试</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyBatisTest</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">// 1、根据全局配置文件创建一个 SqlSessionFactory</span></span><br><span class="line"><span class="type">String</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="string">&quot;mybatis-config.xml&quot;</span>;</span><br><span class="line"><span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(resource);</span><br><span class="line"><span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>().build(inputStream);</span><br><span class="line"></span><br><span class="line"><span class="type">SqlSession</span> <span class="variable">openSession</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="type">Employee</span> <span class="variable">employee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 2、获取和数据库的一次会话：getConnetion()</span></span><br><span class="line">openSession = sqlSessionFactory.openSession();</span><br><span class="line"><span class="comment">// 3、使用 SqlSession 操作数据库，获取到 dao 接口的实现</span></span><br><span class="line"><span class="type">EmployeeDao</span> <span class="variable">employeeDao</span> <span class="operator">=</span> openSession.getMapper(EmployeeDao.class);</span><br><span class="line"><span class="comment">// 4、调用之前的方法</span></span><br><span class="line">employee = employeeDao.getEmpById(<span class="number">1</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">openSession.close();</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(employee);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>关于 SqlSession</strong></p><p>SqlSession 的实例不是线程安全的，因此是不能被共享的</p><p>SqlSession 每次使用完成后需要正确关闭，这个关闭操作是必须的</p><p>SqlSession 可以直接调用方法的 id 进行数据库操作，但是我们一般还是推荐使用 SqlSession 获取到 Dao 接口的代理类，执行代理对象的方法，可以更安全的进行类型检查操作</p><h2 id="第3章-全局配置文件"><a href="#第3章-全局配置文件" class="headerlink" title="第3章 全局配置文件"></a>第3章 全局配置文件</h2><blockquote><p>在 Eclipse 中引入 XML 的 dtd 约束文件，方便编写 XML 的时候有提示</p></blockquote><h3 id="3-1-configuration（配置）"><a href="#3-1-configuration（配置）" class="headerlink" title="3.1 configuration（配置）"></a>3.1 configuration（配置）</h3><h4 id="properties（属性）"><a href="#properties（属性）" class="headerlink" title="properties（属性）"></a>properties（属性）</h4><p>这些属性可以在外部进行配置，并可以进行动态替换。你既可以在典型的 Java 属性文件中配置这些属性，也可以在 properties 元素的子元素中设置。</p><p>如果一个属性在不只一个地方进行了配置，那么，MyBatis 将按照下面的顺序来加载：</p><ul><li>首先读取在 properties 元素体内指定的属性。</li><li>然后根据 properties 元素中的 resource 属性读取类路径下属性文件，或根据 url 属性指定的路径读取属性文件，并覆盖之前读取过的同名属性。</li><li>最后读取作为方法参数传递的属性，并覆盖之前读取过的同名属性。</li></ul><p>因此，通过方法参数传递的属性具有最高优先级，resource&#x2F;url 属性中指定的配置文件次之，最低优先级的则是 properties 元素中指定的属性。</p><h4 id="settings（设置）"><a href="#settings（设置）" class="headerlink" title="settings（设置）"></a>settings（设置）</h4><table><thead><tr><th align="left">设置名</th><th align="left">描述</th><th align="left">有效值</th><th align="left">默认值</th></tr></thead><tbody><tr><td align="left">cacheEnabled</td><td align="left">全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。</td><td align="left">true | false</td><td align="left">true</td></tr><tr><td align="left">lazyLoadingEnabled</td><td align="left">延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 <code>fetchType</code> 属性来覆盖该项的开关状态。</td><td align="left">true | false</td><td align="left">false</td></tr><tr><td align="left">aggressiveLazyLoading</td><td align="left">开启时，任一方法的调用都会加载该对象的所有延迟加载属性。 否则，每个延迟加载属性会按需加载（参考 <code>lazyLoadTriggerMethods</code>)。</td><td align="left">true | false</td><td align="left">false （在 3.4.1 及之前的版本中默认为 true）</td></tr><tr><td align="left">multipleResultSetsEnabled</td><td align="left">是否允许单个语句返回多结果集（需要数据库驱动支持）。</td><td align="left">true | false</td><td align="left">true</td></tr><tr><td align="left">useColumnLabel</td><td align="left">使用列标签代替列名。实际表现依赖于数据库驱动，具体可参考数据库驱动的相关文档，或通过对比测试来观察。</td><td align="left">true | false</td><td align="left">true</td></tr><tr><td align="left">useGeneratedKeys</td><td align="left">允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为 true，将强制使用自动生成主键。尽管一些数据库驱动不支持此特性，但仍可正常工作（如 Derby）。</td><td align="left">true | false</td><td align="left">False</td></tr><tr><td align="left">autoMappingBehavior</td><td align="left">指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。</td><td align="left">NONE, PARTIAL, FULL</td><td align="left">PARTIAL</td></tr><tr><td align="left">autoMappingUnknownColumnBehavior</td><td align="left">指定发现自动映射目标未知列（或未知属性类型）的行为。<code>NONE</code>: 不做任何反应<code>WARNING</code>: 输出警告日志（<code>&#39;org.apache.ibatis.session.AutoMappingUnknownColumnBehavior&#39;</code> 的日志等级必须设置为 <code>WARN</code>）<code>FAILING</code>: 映射失败 (抛出 <code>SqlSessionException</code>)</td><td align="left">NONE, WARNING, FAILING</td><td align="left">NONE</td></tr><tr><td align="left">defaultExecutorType</td><td align="left">配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（PreparedStatement）； BATCH 执行器不仅重用语句还会执行批量更新。</td><td align="left">SIMPLE REUSE BATCH</td><td align="left">SIMPLE</td></tr><tr><td align="left">defaultStatementTimeout</td><td align="left">设置超时时间，它决定数据库驱动等待数据库响应的秒数。</td><td align="left">任意正整数</td><td align="left">未设置 (null)</td></tr><tr><td align="left">defaultFetchSize</td><td align="left">为驱动的结果集获取数量（fetchSize）设置一个建议值。此参数只可以在查询设置中被覆盖。</td><td align="left">任意正整数</td><td align="left">未设置 (null)</td></tr><tr><td align="left">defaultResultSetType</td><td align="left">指定语句默认的滚动策略。（新增于 3.5.2）</td><td align="left">FORWARD_ONLY | SCROLL_SENSITIVE | SCROLL_INSENSITIVE | DEFAULT（等同于未设置）</td><td align="left">未设置 (null)</td></tr><tr><td align="left">safeRowBoundsEnabled</td><td align="left">是否允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为 false。</td><td align="left">true | false</td><td align="left">False</td></tr><tr><td align="left">safeResultHandlerEnabled</td><td align="left">是否允许在嵌套语句中使用结果处理器（ResultHandler）。如果允许使用则设置为 false。</td><td align="left">true | false</td><td align="left">True</td></tr><tr><td align="left"><strong>mapUnderscoreToCamelCase</strong></td><td align="left">是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。</td><td align="left">true | false</td><td align="left">False</td></tr><tr><td align="left">localCacheScope</td><td align="left">MyBatis 利用本地缓存机制（Local Cache）防止循环引用和加速重复的嵌套查询。 默认值为 SESSION，会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地缓存将仅用于执行语句，对相同 SqlSession 的不同查询将不会进行缓存。</td><td align="left">SESSION | STATEMENT</td><td align="left">SESSION</td></tr><tr><td align="left">jdbcTypeForNull</td><td align="left">当没有为参数指定特定的 JDBC 类型时，空值的默认 JDBC 类型。 某些数据库驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。</td><td align="left">JdbcType 常量，常用值：NULL、VARCHAR 或 OTHER。</td><td align="left">OTHER</td></tr><tr><td align="left">lazyLoadTriggerMethods</td><td align="left">指定对象的哪些方法触发一次延迟加载。</td><td align="left">用逗号分隔的方法列表。</td><td align="left">equals,clone,hashCode,toString</td></tr><tr><td align="left">defaultScriptingLanguage</td><td align="left">指定动态 SQL 生成使用的默认脚本语言。</td><td align="left">一个类型别名或全限定类名。</td><td align="left">org.apache.ibatis.scripting.xmltags.XMLLanguageDriver</td></tr><tr><td align="left">defaultEnumTypeHandler</td><td align="left">指定 Enum 使用的默认 <code>TypeHandler</code> 。（新增于 3.4.5）</td><td align="left">一个类型别名或全限定类名。</td><td align="left">org.apache.ibatis.type.EnumTypeHandler</td></tr><tr><td align="left">callSettersOnNulls</td><td align="left">指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这在依赖于 Map.keySet() 或 null 值进行初始化时比较有用。注意基本类型（int、boolean 等）是不能设置成 null 的。</td><td align="left">true | false</td><td align="left">false</td></tr><tr><td align="left">returnInstanceForEmptyRow</td><td align="left">当返回行的所有列都是空时，MyBatis默认返回 <code>null</code>。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集（如集合或关联）。（新增于 3.4.2）</td><td align="left">true | false</td><td align="left">false</td></tr><tr><td align="left">logPrefix</td><td align="left">指定 MyBatis 增加到日志名称的前缀。</td><td align="left">任何字符串</td><td align="left">未设置</td></tr><tr><td align="left">logImpl</td><td align="left">指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</td><td align="left">SLF4J | LOG4J | LOG4J2 | JDK_LOGGING | COMMONS_LOGGING | STDOUT_LOGGING | NO_LOGGING</td><td align="left">未设置</td></tr><tr><td align="left">proxyFactory</td><td align="left">指定 Mybatis 创建可延迟加载对象所用到的代理工具。</td><td align="left">CGLIB | JAVASSIST</td><td align="left">JAVASSIST （MyBatis 3.3 以上）</td></tr><tr><td align="left">vfsImpl</td><td align="left">指定 VFS 的实现</td><td align="left">自定义 VFS 的实现的类全限定名，以逗号分隔。</td><td align="left">未设置</td></tr><tr><td align="left">useActualParamName</td><td align="left">允许使用方法签名中的名称作为语句参数名称。 为了使用该特性，你的项目必须采用 Java 8 编译，并且加上 <code>-parameters</code> 选项。（新增于 3.4.1）</td><td align="left">true | false</td><td align="left">true</td></tr><tr><td align="left">configurationFactory</td><td align="left">指定一个提供 <code>Configuration</code> 实例的类。 这个被返回的 Configuration 实例用来加载被反序列化对象的延迟加载属性值。 这个类必须包含一个签名为<code>static Configuration getConfiguration()</code> 的方法。（新增于 3.2.3）</td><td align="left">一个类型别名或完全限定类名。</td><td align="left">未设置</td></tr><tr><td align="left">shrinkWhitespacesInSql</td><td align="left">从SQL中删除多余的空格字符。请注意，这也会影响SQL中的文字字符串。 (新增于 3.5.5)</td><td align="left">true | false</td><td align="left">false</td></tr><tr><td align="left">defaultSqlProviderType</td><td align="left">Specifies an sql provider class that holds provider method (Since 3.5.6). This class apply to the <code>type</code>(or <code>value</code>) attribute on sql provider annotation(e.g. <code>@SelectProvider</code>), when these attribute was omitted.</td><td align="left">A type alias or fully qualified class name</td><td align="left">Not set</td></tr></tbody></table><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;cacheEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadingEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;multipleResultSetsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useColumnLabel&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;useGeneratedKeys&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;PARTIAL&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;autoMappingUnknownColumnBehavior&quot;</span> <span class="attr">value</span>=<span class="string">&quot;WARNING&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultExecutorType&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SIMPLE&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultStatementTimeout&quot;</span> <span class="attr">value</span>=<span class="string">&quot;25&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;defaultFetchSize&quot;</span> <span class="attr">value</span>=<span class="string">&quot;100&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;safeRowBoundsEnabled&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;localCacheScope&quot;</span> <span class="attr">value</span>=<span class="string">&quot;SESSION&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;jdbcTypeForNull&quot;</span> <span class="attr">value</span>=<span class="string">&quot;OTHER&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">&quot;lazyLoadTriggerMethods&quot;</span> <span class="attr">value</span>=<span class="string">&quot;equals,clone,hashCode,toString&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="typeAliases（类型别名）"><a href="#typeAliases（类型别名）" class="headerlink" title="typeAliases（类型别名）"></a>typeAliases（类型别名）</h4><p>类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写。</p><p>有三种方式取别名：</p><ol><li><p>一个一个取别名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Author&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Author&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Blog&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Blog&quot;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">&quot;Comment&quot;</span> <span class="attr">type</span>=<span class="string">&quot;domain.blog.Comment&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>按包批量取别名</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用 Bean 的首字母小写的非限定类名来作为它的别名 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;domain.blog&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>注解取别名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Alias(&quot;author&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Author</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>下面是一些为常见的 Java 类型内建的类型别名。它们都是不区分大小写的，注意，为了应对原始类型的命名重复，采取了特殊的命名风格。</p><table><thead><tr><th align="left">别名</th><th align="left">映射的类型</th></tr></thead><tbody><tr><td align="left">_byte</td><td align="left">byte</td></tr><tr><td align="left">_long</td><td align="left">long</td></tr><tr><td align="left">_short</td><td align="left">short</td></tr><tr><td align="left">_int</td><td align="left">int</td></tr><tr><td align="left">_integer</td><td align="left">int</td></tr><tr><td align="left">_double</td><td align="left">double</td></tr><tr><td align="left">_float</td><td align="left">float</td></tr><tr><td align="left">_boolean</td><td align="left">boolean</td></tr><tr><td align="left">string</td><td align="left">String</td></tr><tr><td align="left">byte</td><td align="left">Byte</td></tr><tr><td align="left">long</td><td align="left">Long</td></tr><tr><td align="left">short</td><td align="left">Short</td></tr><tr><td align="left">int</td><td align="left">Integer</td></tr><tr><td align="left">integer</td><td align="left">Integer</td></tr><tr><td align="left">double</td><td align="left">Double</td></tr><tr><td align="left">float</td><td align="left">Float</td></tr><tr><td align="left">boolean</td><td align="left">Boolean</td></tr><tr><td align="left">date</td><td align="left">Date</td></tr><tr><td align="left">decimal</td><td align="left">BigDecimal</td></tr><tr><td align="left">bigdecimal</td><td align="left">BigDecimal</td></tr><tr><td align="left">object</td><td align="left">Object</td></tr><tr><td align="left">map</td><td align="left">Map</td></tr><tr><td align="left">hashmap</td><td align="left">HashMap</td></tr><tr><td align="left">list</td><td align="left">List</td></tr><tr><td align="left">arraylist</td><td align="left">ArrayList</td></tr><tr><td align="left">collection</td><td align="left">Collection</td></tr><tr><td align="left">iterator</td><td align="left">Iterator</td></tr></tbody></table><h4 id="typeHandlers（类型处理器）"><a href="#typeHandlers（类型处理器）" class="headerlink" title="typeHandlers（类型处理器）"></a>typeHandlers（类型处理器）</h4><p>MyBatis 在设置预处理语句（PreparedStatement）中的参数或从结果集中取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。</p><h4 id="objectFactory（对象工厂）"><a href="#objectFactory（对象工厂）" class="headerlink" title="objectFactory（对象工厂）"></a>objectFactory（对象工厂）</h4><p>每次 MyBatis 创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成实例化工作。 默认的对象工厂需要做的仅仅是实例化目标类，要么通过默认无参构造方法，要么通过存在的参数映射来调用带有参数的构造方法。 如果想覆盖对象工厂的默认行为，可以通过创建自己的对象工厂来实现。</p><h4 id="plugins（插件）"><a href="#plugins（插件）" class="headerlink" title="plugins（插件）"></a>plugins（插件）</h4><p>MyBatis 允许你在映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p><ul><li>Executor (update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li><li>ParameterHandler (getParameterObject, setParameters)</li><li>ResultSetHandler (handleResultSets, handleOutputParameters)</li><li>StatementHandler (prepare, parameterize, batch, update, query)</li></ul><p>这些类中方法的细节可以通过查看每个方法的签名来发现，或者直接查看 MyBatis 发行包中的源代码。 如果你想做的不仅仅是监控方法的调用，那么你最好相当了解要重写的方法的行为。 因为在试图修改或重写已有方法的行为时，很可能会破坏 MyBatis 的核心模块。 这些都是更底层的类和方法，所以使用插件的时候要特别当心。</p><p>通过 MyBatis 提供的强大机制，使用插件是非常简单的，只需实现 Interceptor 接口，并指定想要拦截的方法签名即可。</p><h4 id="environments（环境配置）"><a href="#environments（环境配置）" class="headerlink" title="environments（环境配置）"></a>environments（环境配置）</h4><p>MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者想在具有相同 Schema 的多个生产数据库中使用相同的 SQL 映射。还有许多类似的使用场景。</p><p><strong>不过要记住：尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</strong></p><h5 id="environment（环境变量）"><a href="#environment（环境变量）" class="headerlink" title="environment（环境变量）"></a>environment（环境变量）</h5><p>transactionManager（事务管理器）</p><p>在 MyBatis 中有两种类型的事务管理器（也就是 type&#x3D;”[JDBC|MANAGED]”）：</p><ul><li>JDBC – 这个配置直接使用了 JDBC 的提交和回滚设施，它依赖从数据源获得的连接来管理事务作用域。</li><li>MANAGED – 这个配置几乎没做什么。它从不提交或回滚一个连接，而是让容器来管理事务的整个生命周期（比如 JEE 应用服务器的上下文）。 默认情况下它会关闭连接。然而一些容器并不希望连接被关闭，因此需要将 closeConnection 属性设置为 false 来阻止默认的关闭行为。</li></ul><p><strong>提示</strong> 如果你正在使用 Spring + MyBatis，则没有必要配置事务管理器，因为 Spring 模块会使用自带的管理器来覆盖前面的配置。</p><p>dataSource（数据源）</p><p>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。</p><ul><li>大多数 MyBatis 应用程序会按示例中的例子来配置数据源。虽然数据源配置是可选的，但如果要启用延迟加载特性，就必须配置数据源。</li></ul><p>有三种内建的数据源类型（也就是 type&#x3D;”[UNPOOLED|POOLED|JNDI]”</p><h4 id="databaseIdProvider（数据库厂商标识）"><a href="#databaseIdProvider（数据库厂商标识）" class="headerlink" title="databaseIdProvider（数据库厂商标识）"></a>databaseIdProvider（数据库厂商标识）</h4><p>MyBatis 可以根据不同的数据库厂商执行不同的语句，这种多厂商的支持是基于映射语句中的 <code>databaseId</code> 属性。 MyBatis 会加载带有匹配当前数据库 <code>databaseId</code> 属性和所有不带 <code>databaseId</code> 属性的语句。 如果同时找到带有 <code>databaseId</code> 和不带 <code>databaseId</code> 的相同语句，则后者会被舍弃。</p><h4 id="mappers（映射器）"><a href="#mappers（映射器）" class="headerlink" title="mappers（映射器）"></a>mappers（映射器）</h4><p>既然 MyBatis 的行为已经由上述元素配置完了，我们现在就要来定义 SQL 映射语句了。 但首先，我们需要告诉 MyBatis 到哪里去找到这些语句。 在自动查找资源方面，Java 并没有提供一个很好的解决方案，所以最好的办法是直接告诉 MyBatis 到哪里去找映射文件。 你可以使用相对于类路径的资源引用，或完全限定资源定位符（包括 <code>file:///</code> 形式的 URL），或类名和包名等。</p><h2 id="第4章-映射文件"><a href="#第4章-映射文件" class="headerlink" title="第4章 映射文件"></a>第4章 映射文件</h2><p>SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：</p><ul><li><code>cache</code> – 该命名空间的缓存配置。</li><li><code>cache-ref</code> – 引用其它命名空间的缓存配置。</li><li><code>resultMap</code> – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。</li><li><del><code>parameterMap</code> – 老式风格的参数映射。此元素已被废弃，并可能在将来被移除！请使用行内参数映射。文档中不会介绍此元素。</del></li><li><code>sql</code> – 可被其它语句引用的可重用语句块。</li><li><code>insert</code> – 映射插入语句。</li><li><code>update</code> – 映射更新语句。</li><li><code>delete</code> – 映射删除语句。</li><li><code>select</code> – 映射查询语句。</li></ul><h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3><p>select 元素允许你配置很多属性来配置每条语句的行为细节。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;selectPerson&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">parameterType</span>=<span class="string">&quot;int&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">parameterMap</span>=<span class="string">&quot;deprecated&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">resultType</span>=<span class="string">&quot;hashmap&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">resultMap</span>=<span class="string">&quot;personResultMap&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushCache</span>=<span class="string">&quot;false&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">useCache</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">timeout</span>=<span class="string">&quot;10&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">fetchSize</span>=<span class="string">&quot;256&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">resultSetType</span>=<span class="string">&quot;FORWARD_ONLY&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>id</code></td><td align="left">在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td align="left"><code>parameterType</code></td><td align="left">将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。</td></tr><tr><td align="left">parameterMap</td><td align="left">用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。</td></tr><tr><td align="left"><code>resultType</code></td><td align="left">期望从这条语句中返回结果的类全限定名或别名。 注意，如果返回的是集合，那应该设置为集合包含的类型，而不是集合本身的类型。 resultType 和 resultMap 之间只能同时使用一个。</td></tr><tr><td align="left"><code>resultMap</code></td><td align="left">对外部 resultMap 的命名引用。结果映射是 MyBatis 最强大的特性，如果你对其理解透彻，许多复杂的映射问题都能迎刃而解。 resultType 和 resultMap 之间只能同时使用一个。</td></tr><tr><td align="left"><code>flushCache</code></td><td align="left">将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：false。</td></tr><tr><td align="left"><code>useCache</code></td><td align="left">将其设置为 true 后，将会导致本条语句的结果被二级缓存缓存起来，默认值：对 select 元素为 true。</td></tr><tr><td align="left"><code>timeout</code></td><td align="left">这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td></tr><tr><td align="left"><code>fetchSize</code></td><td align="left">这是一个给驱动的建议值，尝试让驱动程序每次批量返回的结果行数等于这个设置值。 默认值为未设置（unset）（依赖驱动）。</td></tr><tr><td align="left"><code>statementType</code></td><td align="left">可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr><tr><td align="left"><code>resultSetType</code></td><td align="left">FORWARD_ONLY，SCROLL_SENSITIVE, SCROLL_INSENSITIVE 或 DEFAULT（等价于 unset） 中的一个，默认值为 unset （依赖数据库驱动）。</td></tr><tr><td align="left"><code>databaseId</code></td><td align="left">如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。</td></tr><tr><td align="left"><code>resultOrdered</code></td><td align="left">这个设置仅针对嵌套结果 select 语句：如果为 true，将会假设包含了嵌套结果集或是分组，当返回一个主结果行时，就不会产生对前面结果集的引用。 这就使得在获取嵌套结果集的时候不至于内存不够用。默认值：<code>false</code>。</td></tr><tr><td align="left"><code>resultSets</code></td><td align="left">这个设置仅适用于多结果集的情况。它将列出语句执行后返回的结果集并赋予每个结果集一个名称，多个名称之间以逗号分隔。</td></tr></tbody></table><h3 id="insert-update-和-delete"><a href="#insert-update-和-delete" class="headerlink" title="insert, update 和 delete"></a>insert, update 和 delete</h3><p>数据变更语句 insert，update 和 delete 的实现非常接近：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;insertAuthor&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">parameterType</span>=<span class="string">&quot;domain.blog.Author&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">keyProperty</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">keyColumn</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">useGeneratedKeys</span>=<span class="string">&quot;&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">timeout</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">update</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;updateAuthor&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">parameterType</span>=<span class="string">&quot;domain.blog.Author&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">timeout</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">delete</span></span></span><br><span class="line"><span class="tag">  <span class="attr">id</span>=<span class="string">&quot;deleteAuthor&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">parameterType</span>=<span class="string">&quot;domain.blog.Author&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">flushCache</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">statementType</span>=<span class="string">&quot;PREPARED&quot;</span></span></span><br><span class="line"><span class="tag">  <span class="attr">timeout</span>=<span class="string">&quot;20&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="left">属性</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>id</code></td><td align="left">在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td align="left"><code>parameterType</code></td><td align="left">将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。</td></tr><tr><td align="left"><del><code>parameterMap</code></del></td><td align="left"><del>用于引用外部 parameterMap 的属性，目前已被废弃。请使用行内参数映射和 parameterType 属性。</del></td></tr><tr><td align="left"><code>flushCache</code></td><td align="left">将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：（对 insert、update 和 delete 语句）true。</td></tr><tr><td align="left"><code>timeout</code></td><td align="left">这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td></tr><tr><td align="left"><code>statementType</code></td><td align="left">可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr><tr><td align="left"><code>useGeneratedKeys</code></td><td align="left">（仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。</td></tr><tr><td align="left"><code>keyProperty</code></td><td align="left">（仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（<code>unset</code>）。如果生成列不止一个，可以用逗号分隔多个属性名称。</td></tr><tr><td align="left"><code>keyColumn</code></td><td align="left">（仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。</td></tr><tr><td align="left"><code>databaseId</code></td><td align="left">如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。</td></tr></tbody></table><h3 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h3><p>这个元素可以用来定义可重用的 SQL 代码片段，以便在其它语句中使用。 参数可以静态地（在加载的时候）确定下来，并且可以在不同的 include 元素中定义不同的参数值。</p><h2 id="第5章-动态-SQL"><a href="#第5章-动态-SQL" class="headerlink" title="第5章 动态 SQL"></a>第5章 动态 SQL</h2><p>动态 SQL 是 MyBatis 的强大特性之一。如果你使用过 JDBC 或其它类似的框架，你应该能理解根据不同条件拼接 SQL 语句有多痛苦，例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL，可以彻底摆脱这种痛苦。</p><p>使用动态 SQL 并非一件易事，但借助可用于任何 SQL 映射语句中的强大的动态 SQL 语言，MyBatis 显著地提升了这一特性的易用性。</p><p>如果你之前用过 JSTL 或任何基于类 XML 语言的文本处理器，你对动态 SQL 元素可能会感觉似曾相识。在 MyBatis 之前的版本中，需要花时间了解大量的元素。借助功能强大的基于 OGNL 的表达式，MyBatis 3 替换了之前的大部分元素，大大精简了元素种类，现在要学习的元素种类比原来的一半还要少。</p><ul><li>if</li><li>choose (when, otherwise)</li><li>trim (where, set)</li><li>foreach</li></ul><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><h3 id="choose、when、otherwise"><a href="#choose、when、otherwise" class="headerlink" title="choose、when、otherwise"></a>choose、when、otherwise</h3><h3 id="trim、where、set"><a href="#trim、where、set" class="headerlink" title="trim、where、set"></a>trim、where、set</h3><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><h2 id="第6章-缓存机制"><a href="#第6章-缓存机制" class="headerlink" title="第6章 缓存机制"></a>第6章 缓存机制</h2><h2 id="第7章-Spring-整合"><a href="#第7章-Spring-整合" class="headerlink" title="第7章 Spring 整合"></a>第7章 Spring 整合</h2><h2 id="第8章-逆向工程"><a href="#第8章-逆向工程" class="headerlink" title="第8章 逆向工程"></a>第8章 逆向工程</h2><p>MyBatis Generator，简称 MBG，是一个专门为 MyBatis 框架使用者定制的代码生成器，可以快速的根据表生成对应的映射文件，接口，以及bean类。支持基本的增删改查，以及 QBC 风格的条件查询。但是表连接、存储过程等这些复杂 sql 的定义需要我们手工编写。</p><p>使用步骤：<br>1）编写MBG的配置文件（重要几处配置）<br>    1）jdbcConnection配置数据库连接信息<br>    2）javaModelGenerator配置javaBean的生成策略<br>    3）sqlMapGenerator配置sql映射文件生成策略<br>    4）javaClientGenerator配置Mapper接口的生成策略<br>    5）table配置要逆向解析的数据表<br>        tableName：表名<br>        domainObjectName：对应的javaBean名<br>2）运行代码生成器生成代码<br>注意：<br>Context标签<br>targetRuntime&#x3D;“MyBatis3“可以生成带条件的增删改查<br>targetRuntime&#x3D;“MyBatis3Simple“可以生成基本的增删改查<br>如果再次生成，建议将之前生成的数据删除，避免xml向后追加内容出现的问题。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p><img src="/.io//Dvenotes\3_JavaEE\3_MyBatis\工作原理.png" alt="工作原理"></p><h2 id="插件开发"><a href="#插件开发" class="headerlink" title="插件开发"></a>插件开发</h2><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><h3 id="PageHelper-插件进行分页"><a href="#PageHelper-插件进行分页" class="headerlink" title="PageHelper 插件进行分页"></a>PageHelper 插件进行分页</h3><p>PageHelper 是 MyBatis 中非常方便的第三方分页插件。</p><p>我们可以对照官方文档的说明，快速的使用插件.</p><p><a href="https://github.com/pagehelper/Mybatis-PageHelper/blob/master/README_zh.md">官方文档</a></p><h3 id="批量操作"><a href="#批量操作" class="headerlink" title="批量操作"></a>批量操作</h3><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><h3 id="typeHandler-处理枚举"><a href="#typeHandler-处理枚举" class="headerlink" title="typeHandler 处理枚举"></a>typeHandler 处理枚举</h3>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;第1章-简介&quot;&gt;&lt;a href=&quot;#第1章-简介&quot; class=&quot;headerlink&quot; title=&quot;第1章 简介&quot;&gt;&lt;/a&gt;第1章 简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://mybatis.org/mybatis-3/zh/index.html&quot;&gt;MyBatis&lt;/a&gt; 是一款优秀的持久层框架，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录。&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://actionding.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="编程" scheme="https://actionding.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="MyBatis" scheme="https://actionding.github.io/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL 笔记</title>
    <link href="https://actionding.github.io/2020/08/MySQL%20%E7%AC%94%E8%AE%B0/"/>
    <id>https://actionding.github.io/2020/08/MySQL%20%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-04T19:02:01.000Z</published>
    <updated>2022-03-08T12:42:07.394Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一章-MySQL概述"><a href="#第一章-MySQL概述" class="headerlink" title="第一章 MySQL概述"></a>第一章 MySQL概述</h2><p>MySQL是一个<strong>关系型数据库管理系统</strong>，由瑞典MySQL AB公司开发，属于Oracle旗下产品。MySQL是最流行的关系型数据库管理系统之一。</p><h3 id="1-1-数据库的常见概念"><a href="#1-1-数据库的常见概念" class="headerlink" title="1.1 数据库的常见概念"></a>1.1 数据库的常见概念</h3><h4 id="1-1-1-DB"><a href="#1-1-1-DB" class="headerlink" title="1.1.1 DB"></a>1.1.1 DB</h4><p>Database，数据库，存储数据的容器</p><h4 id="1-1-2-DBMS"><a href="#1-1-2-DBMS" class="headerlink" title="1.1.2 DBMS"></a>1.1.2 DBMS</h4><p>Database Management System，数据库管理系统，又称为数据库软件或数据库产品，用于创建或管理数据库</p><h4 id="1-1-3-SQL"><a href="#1-1-3-SQL" class="headerlink" title="1.1.3 SQL"></a>1.1.3 SQL</h4><p>Structured Query Language，结构化查询语言，用于和数据库通信的语言，不是某个数据库软件特有的，而是几乎所有的主流数据库软件通用的语言</p><blockquote><p>常见的数据库管理系统：MySQL、Oracle、db2、SQLserver</p></blockquote><h3 id="1-2-MySQL的介绍"><a href="#1-2-MySQL的介绍" class="headerlink" title="1.2 MySQL的介绍"></a>1.2 MySQL的介绍</h3><p>MySQL是一个关系型数据库管理系统，由瑞典MySQL AB 公司开发，属于Oracle 旗下产品</p><p>08年被SUN公司收购，09年SUN被Oracle收购</p><p>属于<strong>C&#x2F;S架构</strong>的软件，一般安装服务端</p><p>分为<strong>企业版</strong>和<strong>社区版</strong></p><h3 id="1-3-MySQL的优点"><a href="#1-3-MySQL的优点" class="headerlink" title="1.3 MySQL的优点"></a>1.3 MySQL的优点</h3><p>1、开源、免费、成本低<br>2、性能高、移植性也好<br>3、体积小，便于安装</p><h3 id="1-4-MySQL语言的分类"><a href="#1-4-MySQL语言的分类" class="headerlink" title="1.4 MySQL语言的分类"></a>1.4 MySQL语言的分类</h3><h4 id="1-4-1-DML"><a href="#1-4-1-DML" class="headerlink" title="1.4.1 DML"></a>1.4.1 DML</h4><p>Data Manipulation Language：数据操纵语句，用于添加、删除、修改、查询数据库记录，并检查数据完整性</p><h4 id="1-4-2-DDL"><a href="#1-4-2-DDL" class="headerlink" title="1.4.2 DDL"></a>1.4.2 DDL</h4><p>Data Definition Language：数据定义语句，用于库和表的创建、修改、删除。</p><h4 id="1-4-3-DCL"><a href="#1-4-3-DCL" class="headerlink" title="1.4.3 DCL"></a>1.4.3 DCL</h4><p>Data Control Language：数据控制语句，用于定义用户的访问权限和安全级别。</p><h3 id="1-5-MySQL服务的启动和停止"><a href="#1-5-MySQL服务的启动和停止" class="headerlink" title="1.5 MySQL服务的启动和停止"></a>1.5 MySQL服务的启动和停止</h3><p>方式一：通过命令行</p><p>​    <code>net start [服务名]</code><br>​    <code>net stop [服务名]</code></p><p>方式二：计算机——右击——管理——服务</p><h3 id="1-6-MySQL服务的登录和退出"><a href="#1-6-MySQL服务的登录和退出" class="headerlink" title="1.6 MySQL服务的登录和退出"></a>1.6 MySQL服务的登录和退出</h3><p>登录：<code>mysql [-h 主机名 -P 端口号] -u[用户名] -p[密码]</code></p><p>退出：<code>exit</code> 或 <code>ctrl+C</code></p><hr><h2 id="第二章-DQL语言"><a href="#第二章-DQL语言" class="headerlink" title="第二章 DQL语言"></a>第二章 DQL语言</h2><p>DQL（Data Query Language）：数据查询语言，用来查询记录（数据）</p><h3 id="2-1-基础查询"><a href="#2-1-基础查询" class="headerlink" title="2.1 基础查询"></a>2.1 基础查询</h3><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  查询列表 </span><br><span class="line">FROM</span><br><span class="line">  表名 ;</span><br></pre></td></tr></table></figure><p>查询列表：表中的字段、常量值、表达式、函数</p><p>查询的结果是一个虚拟的表格</p><h4 id="2-1-1-查询表中的单个字段"><a href="#2-1-1-查询表中的单个字段" class="headerlink" title="2.1.1 查询表中的单个字段"></a>2.1.1 查询表中的单个字段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name FROM employees;</span><br></pre></td></tr></table></figure><h4 id="2-1-2-查询表中的多个字段"><a href="#2-1-2-查询表中的多个字段" class="headerlink" title="2.1.2 查询表中的多个字段"></a>2.1.2 查询表中的多个字段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT last_name,salary,email FROM employees;</span><br></pre></td></tr></table></figure><h4 id="2-1-3-查询表中的所有字段"><a href="#2-1-3-查询表中的所有字段" class="headerlink" title="2.1.3 查询表中的所有字段"></a>2.1.3 查询表中的所有字段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  `employee_id`,</span><br><span class="line">  `first_name`,</span><br><span class="line">  `last_name`,</span><br><span class="line">  `email`,</span><br><span class="line">  `phone_number`,</span><br><span class="line">  `job_id`,</span><br><span class="line">  `salary`,</span><br><span class="line">  `commission_pct`,</span><br><span class="line">  `manager_id`,</span><br><span class="line">  `department_id`,</span><br><span class="line">  `hiredate` </span><br><span class="line">FROM</span><br><span class="line">  `employees` ;</span><br><span class="line">/*</span><br><span class="line"> * F12 格式化</span><br><span class="line"> * 不是引号，是着重号，用来区分字段和关键字</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><p><strong>或</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM employees;</span><br><span class="line"># 表中字段顺序固定</span><br></pre></td></tr></table></figure><h4 id="2-1-4-查询常量值"><a href="#2-1-4-查询常量值" class="headerlink" title="2.1.4 查询常量值"></a>2.1.4 查询常量值</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 100;</span><br><span class="line">SELECT &#x27;john&#x27;;</span><br><span class="line"># 不区分字符和字符串，都是字符型，用单引号</span><br></pre></td></tr></table></figure><h4 id="2-1-5-查询表达式"><a href="#2-1-5-查询表达式" class="headerlink" title="2.1.5 查询表达式"></a>2.1.5 查询表达式</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 100%98;</span><br></pre></td></tr></table></figure><h4 id="2-1-6-查询函数"><a href="#2-1-6-查询函数" class="headerlink" title="2.1.6 查询函数"></a>2.1.6 查询函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT VERSION();</span><br></pre></td></tr></table></figure><h4 id="2-1-7-起别名"><a href="#2-1-7-起别名" class="headerlink" title="2.1.7 起别名"></a>2.1.7 起别名</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 方式一：使用as</span><br><span class="line">SELECT 100%98 AS 结果;</span><br><span class="line">SELECT last_name AS 姓,first_name AS 名 FROM employees;</span><br><span class="line">/*</span><br><span class="line"> *1 便于理解</span><br><span class="line"> *2 如果要查询的字段有重名的情况，使用别名可以区分开来</span><br><span class="line"> */</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 方式二：使用空格</span><br><span class="line">SELECT last_name 姓,first_name 名 FROM employees;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 案例：查询salary，显示结果为 out put</span><br><span class="line">SELECT salary AS &quot;out put&quot; FROM employees;</span><br><span class="line"># 这里建议使用双引号，单引号也可以</span><br></pre></td></tr></table></figure><h4 id="2-1-8-去重"><a href="#2-1-8-去重" class="headerlink" title="2.1.8 去重"></a>2.1.8 去重</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 使用DISTINCT关键字</span><br><span class="line">SELECT DISTINCT department_id FROM employees;</span><br></pre></td></tr></table></figure><h4 id="2-1-9-号的使用"><a href="#2-1-9-号的使用" class="headerlink" title="2.1.9 +号的使用"></a>2.1.9 <code>+</code>号的使用</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"></span><br><span class="line">java中的+号：</span><br><span class="line">①运算符，两个操作数都为数值型</span><br><span class="line">②连接符，只要有一个操作数为字符串</span><br><span class="line"></span><br><span class="line">mysql中的+号：</span><br><span class="line">仅仅只有一个功能：运算符</span><br><span class="line"></span><br><span class="line">select 100+90; 两个操作数都为数值型，则做加法运算</span><br><span class="line">select &#x27;123&#x27;+90;只要其中一方为字符型，试图将字符型数值转换成数值型</span><br><span class="line">如果转换成功，则继续做加法运算</span><br><span class="line">select &#x27;john&#x27;+90;如果转换失败，则将字符型数值转换成0</span><br><span class="line"></span><br><span class="line">select null+10; 只要其中一方为null，则结果肯定为null</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line"># 案例:查询员工名和姓连接成一个字段，并显示为 姓名</span><br><span class="line"></span><br><span class="line">SELECT CONCAT(&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;) AS 结果;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">  错误的写法</span><br><span class="line">select </span><br><span class="line">  last_name + first_name as 姓名 </span><br><span class="line">from</span><br><span class="line">  employees ;</span><br><span class="line">*/</span><br><span class="line"># 正确的写法，使用CONCAT()函数</span><br><span class="line">SELECT </span><br><span class="line">  CONCAT(`first_name`, `last_name`) AS 姓名 </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br></pre></td></tr></table></figure><h4 id="附：几个函数"><a href="#附：几个函数" class="headerlink" title="附：几个函数"></a>附：几个函数</h4><p>1）<code>concat() </code>函数</p><p>功能：拼接字符</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT CONCAT(str1，str2，str3,...);</span><br></pre></td></tr></table></figure><p>2）<code>ifnull()</code> 函数</p><p>功能：判断某字段或表达式是否为<code>null</code>，如果为<code>null</code>返回指定的值，否则返回原本的值</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT IFNULL(commission_pct,0) from employees;</span><br></pre></td></tr></table></figure><p>3）<code>isnull()</code> 函数</p><p>功能：判断某字段或表达式是否为null，如果是，则返回1，否则返回0</p><h3 id="2-2-条件查询"><a href="#2-2-条件查询" class="headerlink" title="2.2 条件查询"></a>2.2 条件查询</h3><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  查询列表 </span><br><span class="line">FROM</span><br><span class="line">  表名 </span><br><span class="line">WHERE 筛选条件 ;</span><br></pre></td></tr></table></figure><p>筛选条件的分类：</p><p>1）简单条件运算符</p><p>2）逻辑运算符</p><p>3）模糊查询</p><h4 id="2-2-1-简单条件运算符"><a href="#2-2-1-简单条件运算符" class="headerlink" title="2.2.1 简单条件运算符"></a>2.2.1 简单条件运算符</h4><table><thead><tr><th align="center">&gt;</th><th>&lt;</th><th align="center">&#x3D;</th><th align="center">!&#x3D;</th><th align="center">&lt;&gt;</th><th align="center">&gt;&#x3D;</th><th align="center">&lt;&#x3D;</th><th align="center">&lt;&#x3D;&gt;</th></tr></thead><tbody><tr><td align="center">大于</td><td>小于</td><td align="center">等于</td><td align="center">不等于</td><td align="center">不等于</td><td align="center">大于等于</td><td align="center">小于等于</td><td align="center">安全等于</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 案例1：查询工资 &gt; 12000的员工信息</span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE salary &gt; 12000 ;</span><br><span class="line"></span><br><span class="line"># 案例2：查询部门编号不等于90号的员工名和部门编号</span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  department_id </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE department_id &lt;&gt; 90 ;</span><br></pre></td></tr></table></figure><h4 id="2-2-2-逻辑运算符"><a href="#2-2-2-逻辑运算符" class="headerlink" title="2.2.2 逻辑运算符"></a>2.2.2 逻辑运算符</h4><table><thead><tr><th align="center">&amp;&amp;</th><th align="center">||</th><th align="center">!</th></tr></thead><tbody><tr><td align="center">and</td><td align="center">or</td><td align="center">not</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 案例1：查询工资在10000到20000之间的员工名、工资以及奖金</span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  salary,</span><br><span class="line">  commission_pct </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE salary &gt; 10000 </span><br><span class="line">  AND salary &lt; 20000 ;</span><br><span class="line"></span><br><span class="line"># 案例2：查询部门编号不是在90到100之间，或者工资高于15000的员工信息</span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE department_id &lt; 90 </span><br><span class="line">  OR department_id &gt; 110 </span><br><span class="line">  OR salary &gt; 15000 ;</span><br><span class="line">/*</span><br><span class="line">WHERE not (</span><br><span class="line">    department_id &gt;= 90 </span><br><span class="line">    AND department_id &lt;= 110</span><br><span class="line">  ) </span><br><span class="line">  OR salary &gt; 15000 ;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><h4 id="2-2-3-模糊查询"><a href="#2-2-3-模糊查询" class="headerlink" title="2.2.3 模糊查询"></a>2.2.3 模糊查询</h4><p>1）<code>like</code>:一般搭<strong>配通配符</strong>使用，可以判断字符型或数值型</p><p>通配符：</p><ul><li><p>%任意多个字符，，包含0个字符</p></li><li><p>_任意单个字符</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 案例1：查询员工名中包含字符a的员工信息</span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE last_name LIKE &#x27;%a%&#x27; ;</span><br><span class="line"></span><br><span class="line"># 案例2：查询员工名中第三个字符为c，第五个字符为h的员工名和工资</span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  salary </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE last_name LIKE &#x27;__c_h%&#x27; ;</span><br><span class="line"></span><br><span class="line"># 案例三：查询员工名中第二个字符为_的员工名</span><br><span class="line">SELECT </span><br><span class="line">  last_name </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE last_name LIKE &#x27;_\_%&#x27; ;</span><br><span class="line"># WHERE last_name LIKE &#x27;_$_%&#x27; ESCAPE &#x27;$&#x27;;</span><br><span class="line"># 关键字ESCAPE：转义</span><br></pre></td></tr></table></figure><p>2） <code>between and</code></p><ul><li>使用between and可以提高语句的简洁度</li><li>包含临界值</li><li>两个临界值不要调换顺序</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 案例1：查询员工编号在100到120之间的员工信息</span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE employee_id BETWEEN 100 </span><br><span class="line">  AND 120 ;</span><br><span class="line"># 等价于</span><br><span class="line"># employee_id &gt;= 100 AND employee_id &lt;= 120;</span><br></pre></td></tr></table></figure><p>3）<code>in</code><br>含义：判断某字段的值是否属于in列表中的某一项<br>特点：</p><ul><li>使用in提高语句简洁度</li><li>in列表的值类型必须统一或兼容</li><li>in列表中不能使用通配符</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 案例：查询员工的工种编号是 ITPROG、AD_VP、AD_PRES中的一个员工名和工种编号</span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  job_id </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE job_id IN (&#x27;ITPROG&#x27;, &#x27;AD_VP&#x27;, &#x27;AD_PRES&#x27;) ;</span><br><span class="line"># WHERE job_id IN (&#x27;ITPROG&#x27;, &#x27;AD_%&#x27;) ; # 错误</span><br><span class="line">/*</span><br><span class="line">WHERE job_id = &#x27;ITPROG&#x27; </span><br><span class="line">  OR job_id = &#x27;AD_VP&#x27; </span><br><span class="line">  OR job_id = &#x27;AD_PRES&#x27; ;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>4） <code>is null</code> &#x2F;<code>is not null</code>：用于判断null值</p><blockquote><p>&#x3D; 或 &lt;&gt; 不能用于判断null值</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 案例1：查询没有奖金的员工名和奖金率</span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  commission_pct</span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE commission_pct IS NULL ;</span><br><span class="line"></span><br><span class="line"># 案例2：查询有奖金的员工名和奖金率</span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  commission_pct</span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE commission_pct IS NOT NULL ;</span><br></pre></td></tr></table></figure><p><strong>附</strong></p><p><code>IS NULL</code> pk <code>&lt;=&gt;</code><br><code>IS NULL</code>：仅仅可以判断NULL值，可读性较高，建议使用<br><code>&lt;=&gt; </code>：既可以判断NULL值，有可以判断普通的数值，可读性较低</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 安全等于 &lt;=&gt;</span><br><span class="line"># 案例1：查询没有奖金的员工名和奖金率</span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  commission_pct</span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE commission_pct &lt;=&gt; NULL ;</span><br><span class="line"></span><br><span class="line"># 案例2：查询工资为12000的员工信息</span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  salary</span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE salary &lt;=&gt; 12000 ;</span><br></pre></td></tr></table></figure><h3 id="2-3-排序查询"><a href="#2-3-排序查询" class="headerlink" title="2.3 排序查询"></a>2.3 排序查询</h3><h4 id="2-3-1-语法"><a href="#2-3-1-语法" class="headerlink" title="2.3.1 语法"></a>2.3.1 语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  查询列表 </span><br><span class="line">FROM</span><br><span class="line">  表 </span><br><span class="line">WHERE 【筛选条件】 </span><br><span class="line">ORDER BY 排序列表【 ASC | DESC 】</span><br></pre></td></tr></table></figure><h4 id="2-3-2-特点"><a href="#2-3-2-特点" class="headerlink" title="2.3.2 特点"></a>2.3.2 特点</h4><p>​    1 asc表示升序，desc表示降序，如果不写，默认升序<br>​    2 order by 子句中可以支持单个字段、多个字段、表达式、函数、别名<br>​    3 order by 子句一般放在查询语句的最后面，limit子句除外</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"># 案例1：查询员工信息，要求工资从高到低排序</span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">ORDER BY salary ASC ;</span><br><span class="line"># ORDER BY salary ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">ORDER BY salary DESC ;</span><br><span class="line"></span><br><span class="line"># 案例2：查询部门编号大于等于90的员工信息，按入职时间的先后进行排序</span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE department_id &gt;= 90 </span><br><span class="line">ORDER BY hiredate ASC ;</span><br><span class="line"></span><br><span class="line"># 案例3：按年薪的高低显示员工的选型和年薪【按表达式排序】</span><br><span class="line">SELECT </span><br><span class="line">  *,</span><br><span class="line">  salary * 12 * (1 + IFNULL(commission_pct, 0)) 年薪 </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">ORDER BY salary * 12 * (1 + IFNULL(commission_pct, 0)) DESC ;</span><br><span class="line"></span><br><span class="line"># 案例4：按年薪的高低显示员工的选型和年薪【按别名排序】</span><br><span class="line">SELECT </span><br><span class="line">  *,</span><br><span class="line">  salary * 12 * (1 + IFNULL(commission_pct, 0)) 年薪 </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">ORDER BY 年薪 DESC ;</span><br><span class="line"></span><br><span class="line"># 案例5：按姓名的长度显示员工的姓名和工资【按函数排序】</span><br><span class="line">SELECT </span><br><span class="line">  LENGTH(last_name) 字节长度,</span><br><span class="line">  last_name,</span><br><span class="line">  salary </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">ORDER BY LENGTH(last_name) DESC ;</span><br><span class="line"></span><br><span class="line"># 案例6：查询员工信息，要求先按工资排序，再按员工编号排序【按多个字段排序】</span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">ORDER BY salary ASC,</span><br><span class="line">  employee_id DESC ;</span><br></pre></td></tr></table></figure><h4 id="附：常见函数"><a href="#附：常见函数" class="headerlink" title="附：常见函数"></a>附：常见函数</h4><p>1）字符函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"># 1. length 获取参数值的字节个数</span><br><span class="line">SELECT </span><br><span class="line">  LENGTH(&#x27;john&#x27;) ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  LENGTH(&#x27;张三丰hhh&#x27;) ;</span><br><span class="line"></span><br><span class="line">SHOW VARIABLES LIKE &#x27;%char%&#x27; ;</span><br><span class="line"></span><br><span class="line"># 2. concat 拼接字符串</span><br><span class="line">SELECT </span><br><span class="line">  CONCAT(last_name, &#x27;_&#x27;, first_name) 姓名 </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line"># 3. upper、lower </span><br><span class="line">SELECT </span><br><span class="line">  UPPER(&#x27;john&#x27;) ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  LOWER(&#x27;John&#x27;) ;</span><br><span class="line"></span><br><span class="line"># 案例：将姓变大写，名变小写，然后拼接</span><br><span class="line">SELECT </span><br><span class="line">  CONCAT(</span><br><span class="line">    UPPER(last_name),</span><br><span class="line">    &#x27;_&#x27;,</span><br><span class="line">    LOWER(first_name)</span><br><span class="line">  ) 姓名 </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line"># 4. substr、substring </span><br><span class="line"># 注意：索引从1开始</span><br><span class="line"></span><br><span class="line"># 截取从指定索引处后面所有字符</span><br><span class="line">SELECT </span><br><span class="line">  SUBSTR(</span><br><span class="line">    &#x27;李莫愁爱上了陆展元&#x27;,</span><br><span class="line">    7</span><br><span class="line">  ) out_put ;</span><br><span class="line"></span><br><span class="line"># 截取从指定索引处指定长度的字符</span><br><span class="line">SELECT </span><br><span class="line">  SUBSTR(</span><br><span class="line">    &#x27;李莫愁爱上了陆展元&#x27;,</span><br><span class="line">    1,</span><br><span class="line">    3</span><br><span class="line">  ) out_put ;</span><br><span class="line"></span><br><span class="line"># 案例：姓名中首字符大写，其他字符小写，然后用_拼接，显示出来</span><br><span class="line">SELECT </span><br><span class="line">  CONCAT(</span><br><span class="line">    UPPER(SUBSTR(last_name, 1, 1)),</span><br><span class="line">    &#x27;_&#x27;,</span><br><span class="line">    LOWER(SUBSTR(last_name, 2))</span><br><span class="line">  ) out_put </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line"># 5. instr 返回子串第一次出现的索引，如果找不到，返回0</span><br><span class="line">SELECT </span><br><span class="line">  INSTR(</span><br><span class="line">    &#x27;杨不悔爱上了殷六侠&#x27;,</span><br><span class="line">    &#x27;殷六侠&#x27;</span><br><span class="line">  ) AS out_put ;</span><br><span class="line"></span><br><span class="line"># 6. trim</span><br><span class="line">SELECT </span><br><span class="line">  LENGTH(TRIM(&#x27;    张翠山    &#x27;)) AS out_put ;</span><br><span class="line">  </span><br><span class="line">SELECT </span><br><span class="line">  TRIM(&#x27;a&#x27; FROM &#x27;aaa张aaa翠aaa山aaa&#x27;) AS out_put ;</span><br><span class="line"></span><br><span class="line"># 7. lpad 用指定的字符实现左填充指定长度</span><br><span class="line">SELECT </span><br><span class="line">  LPAD(&#x27;殷素素&#x27;, 10, &#x27;*&#x27;) AS out_put ;</span><br><span class="line">  </span><br><span class="line">SELECT </span><br><span class="line">  LPAD(&#x27;殷素素&#x27;, 2, &#x27;*&#x27;) AS out_put ;</span><br><span class="line"></span><br><span class="line"># 8. rpad 用指定的字符实现做右充指定长度</span><br><span class="line">SELECT </span><br><span class="line">  RPAD(&#x27;殷素素&#x27;, 10, &#x27;*&#x27;) AS out_put ;</span><br><span class="line"></span><br><span class="line"># 9. replace 替换</span><br><span class="line">SELECT </span><br><span class="line">  REPLACE(</span><br><span class="line">    &#x27;张无忌爱上了周芷若&#x27;,</span><br><span class="line">    &#x27;周芷若&#x27;,</span><br><span class="line">    &#x27;赵敏&#x27;</span><br><span class="line">  ) AS out_put ;</span><br></pre></td></tr></table></figure><p>2）数学函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 1. round 四舍五入</span><br><span class="line">SELECT </span><br><span class="line">  ROUND(1.65) ; # 2</span><br><span class="line"># ROUND(1.45) ; # 1</span><br><span class="line"># ROUND(-1.65) ; # -2</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  ROUND(1.654,2) ; # 1.65</span><br><span class="line">  </span><br><span class="line"># 2. ceil 向上取整，返回 &gt;=该参数的最小整数</span><br><span class="line">SELECT </span><br><span class="line">  CEIL(1.002) ;</span><br><span class="line"># CEIL(-1.002); # -1</span><br><span class="line"></span><br><span class="line"># 3. floor 向下取整，，返回 &lt;=该参数的最大整数</span><br><span class="line">SELECT </span><br><span class="line">  FLOOR(- 9.99) ; # -10</span><br><span class="line">  </span><br><span class="line"># 4. truncate 截断</span><br><span class="line">SELECT </span><br><span class="line">  TRUNCATE(1.6999, 1) ; # 1.6</span><br><span class="line"># 5. mod 取模、取余</span><br><span class="line"># a mod b --&gt; a-a/b*b</span><br><span class="line">SELECT </span><br><span class="line">  MOD(10, 3) ;</span><br><span class="line"> </span><br><span class="line">SELECT </span><br><span class="line">  10 % 3 ;</span><br></pre></td></tr></table></figure><p>3）日期函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"># 1. now 返回当前系统日期 + 时间</span><br><span class="line">SELECT </span><br><span class="line">  NOW() ;</span><br><span class="line"></span><br><span class="line"># 2. curdate 返回当前系统日期，不包含时间</span><br><span class="line">SELECT </span><br><span class="line">  CURDATE() ;</span><br><span class="line"></span><br><span class="line"># 3. curtime 返回当前系统时间，不包含日期</span><br><span class="line">SELECT </span><br><span class="line">  CURTIME() ;</span><br><span class="line"></span><br><span class="line"># 4. 可以获取指定的部分，年、月、日、小时、分钟、秒</span><br><span class="line">SELECT </span><br><span class="line">  YEAR(NOW()) 年 ;</span><br><span class="line">  </span><br><span class="line">SELECT </span><br><span class="line">  YEAR(&#x27;1997-1-1&#x27;) 年 ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  YEAR(hiredate) 年 </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  MONTH(NOW()) 月 ;</span><br><span class="line">  </span><br><span class="line">SELECT </span><br><span class="line">  DAY(NOW()) 日 ;</span><br><span class="line">  </span><br><span class="line">SELECT </span><br><span class="line">  HOUR(NOW()) 时 ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  MINUTE(NOW()) 分 ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  SECOND(NOW()) 秒 ;</span><br><span class="line"></span><br><span class="line"># 5. str_to_date 将日期格式的字符转换为指定格式的日期</span><br><span class="line">SELECT </span><br><span class="line">  STR_TO_DATE(&#x27;1997-3-2&#x27;, &#x27;%Y-%c-%d&#x27;) AS out_put ;</span><br><span class="line">  </span><br><span class="line"># 案例：查询入职日期为1992-4-3的员工信息</span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE hiredate = &#x27;1992-4-3&#x27; ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE hiredate = STR_TO_DATE(&#x27;4-3 1992&#x27;, &#x27;%c-%d %Y&#x27;) ;</span><br><span class="line"></span><br><span class="line"># 6. date_format 将日期转换为字符</span><br><span class="line">SELECT </span><br><span class="line">  DATE_FORMAT(NOW(), &#x27;%y年%m月%d日&#x27;) AS out_put ;</span><br><span class="line"></span><br><span class="line"># 案例：查询有奖金的员工名和入职日期（xx月/xx日 xx年）</span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  DATE_FORMAT(hiredate, &#x27;%m月/%d日 %y年&#x27;) 入职日期 </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE commission_pct IS NOT NULL ;</span><br></pre></td></tr></table></figure><p>4）流程控制函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"># 1. if函数：if else 的效果</span><br><span class="line">SELECT </span><br><span class="line">  IF(10 &gt; 5, &#x27;大&#x27;, &#x27;小&#x27;) ;</span><br><span class="line">  </span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  commission_pct,</span><br><span class="line">  IF(</span><br><span class="line">    commission_pct IS NULL,</span><br><span class="line">    &#x27;没奖金，呵呵&#x27;,</span><br><span class="line">    &#x27;有奖金，嘻嘻&#x27;</span><br><span class="line">  ) 备注 </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line"># 2. case函数的使用一：switch case 的效果</span><br><span class="line">/*</span><br><span class="line">Java中</span><br><span class="line">switch(变量或表达式)&#123;</span><br><span class="line">case 常量1: 语句1; break; </span><br><span class="line">...</span><br><span class="line">default: 语句n; break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MySQL中</span><br><span class="line">case 要判断的字段或表达式</span><br><span class="line">when 常量1 then 要显示的值1 或 语句1;</span><br><span class="line">when 常量2 then 要显示的值2 或 语句2;</span><br><span class="line">...</span><br><span class="line">else 要显示的值n 或 语句n;</span><br><span class="line">end</span><br><span class="line">*/</span><br><span class="line">/*</span><br><span class="line">案例：查询员工的工资，要求</span><br><span class="line"></span><br><span class="line">部门号 = 30，显示的工资为1.1倍</span><br><span class="line">部门号 = 40，显示的工资为1.2倍</span><br><span class="line">部门号 = 50，显示的工资为1.3倍</span><br><span class="line">其他部门，显示的工资为原工资</span><br><span class="line">*/</span><br><span class="line">SELECT </span><br><span class="line">  salary 原始工资,</span><br><span class="line">  department_id,</span><br><span class="line">  CASE</span><br><span class="line">    department_id </span><br><span class="line">    WHEN 30 </span><br><span class="line">    THEN salary * 1.1 </span><br><span class="line">    WHEN 40 </span><br><span class="line">    THEN salary * 1.2 </span><br><span class="line">    WHEN 50 </span><br><span class="line">    THEN salary * 1.3 </span><br><span class="line">    ELSE salary </span><br><span class="line">  END AS 新工资 </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line"># case函数的使用二：类似于 多重if</span><br><span class="line">/*</span><br><span class="line">java中</span><br><span class="line">if（条件1）&#123;</span><br><span class="line">语句1</span><br><span class="line">&#125; else if（条件2）&#123;</span><br><span class="line">语句2</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">else &#123;</span><br><span class="line">语句n</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MySQL中</span><br><span class="line">case </span><br><span class="line">when 条件1 then 要显示的值1 或 语句1;</span><br><span class="line">when 条件2 then 要显示的值2 或 语句2;</span><br><span class="line">...</span><br><span class="line">else 要显示的值n 或 语句n;</span><br><span class="line">end</span><br><span class="line">*/</span><br><span class="line">/*</span><br><span class="line">案例：查询员工的工资情况</span><br><span class="line">如果工资 &gt; 20000, 显示A级别</span><br><span class="line">如果工资 &gt; 15000, 显示B级别</span><br><span class="line">如果工资 &gt; 10000, 显示C级别</span><br><span class="line">否则，显示D级别</span><br><span class="line">*/</span><br><span class="line">SELECT </span><br><span class="line">  salary,</span><br><span class="line">  CASE</span><br><span class="line">    WHEN salary &gt; 20000 </span><br><span class="line">    THEN &#x27;A&#x27; </span><br><span class="line">    WHEN salary &gt; 15000 </span><br><span class="line">    THEN &#x27;B&#x27; </span><br><span class="line">    WHEN salary &gt; 10000 </span><br><span class="line">    THEN &#x27;C&#x27; </span><br><span class="line">    ELSE &#x27;D&#x27; </span><br><span class="line">  END AS 工资级别 </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br></pre></td></tr></table></figure><p>5）其他函数</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 1. version 查看版本号</span><br><span class="line">SELECT </span><br><span class="line">  VERSION() ;</span><br><span class="line"></span><br><span class="line"># 2. database 查看当前数据库</span><br><span class="line">SELECT </span><br><span class="line">  DATABASE() ;</span><br><span class="line"></span><br><span class="line"># 3. user 查看当前用户</span><br><span class="line">SELECT </span><br><span class="line">  USER() ;</span><br></pre></td></tr></table></figure><h3 id="2-4-分组函数"><a href="#2-4-分组函数" class="headerlink" title="2.4 分组函数"></a>2.4 分组函数</h3><h4 id="2-4-1-功能"><a href="#2-4-1-功能" class="headerlink" title="2.4.1 功能"></a>2.4.1 功能</h4><p>​    用作统计使用，又称为<strong>聚合函数</strong> 或 <strong>统计函数</strong> 或 <strong>组函数</strong></p><h4 id="2-4-2-分类"><a href="#2-4-2-分类" class="headerlink" title="2.4.2 分类"></a>2.4.2 分类</h4><p>​    sum 求和、avg 平均值、max 最大值、min 最小值、count 计算个数</p><h4 id="2-4-3-特点"><a href="#2-4-3-特点" class="headerlink" title="2.4.3 特点"></a>2.4.3 特点</h4><ol><li>sum、avg一般用于处理<strong>数值类型</strong>；max、min、count可以处理<strong>任何类型</strong></li><li>以上分组函数都忽略null值</li><li>可以和distinct搭配实现去重的运算</li><li>count函数：一般使用count(*)用作统计行数</li><li>和分组函数一同查询的字段要求是group by后的字段</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"># 1 简单使用</span><br><span class="line">SELECT </span><br><span class="line">  SUM(salary) </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  AVG(salary) </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  MAX(salary) </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  MIN(salary) </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  COUNT(salary) </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line">  </span><br><span class="line">SELECT </span><br><span class="line">  SUM(salary) 和,</span><br><span class="line">  ROUND(AVG(salary), 2) 平均,</span><br><span class="line">  MAX(salary) 最大,</span><br><span class="line">  MIN(salary) 最小,</span><br><span class="line">  COUNT(salary) 个数 </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line"># 参数支持哪些类型</span><br><span class="line"># select sum(last_name), avg(last_name) from employees;</span><br><span class="line">SELECT </span><br><span class="line">  SUM(hiredate),</span><br><span class="line">  AVG(hiredate) </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  MAX(last_name),</span><br><span class="line">  MIN(last_name) </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  MAX(hiredate),</span><br><span class="line">  MIN(hiredate) </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line">  </span><br><span class="line">SELECT </span><br><span class="line">  COUNT(commission_pct) </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line"># 3 是否忽略null值</span><br><span class="line">SELECT </span><br><span class="line">  SUM(commission_pct),</span><br><span class="line">  AVG(commission_pct),</span><br><span class="line">  SUM(commission_pct)/35,</span><br><span class="line">  SUM(commission_pct)/107</span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  MAX(commission_pct),</span><br><span class="line">  MIN(commission_pct)</span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line">  </span><br><span class="line">SELECT </span><br><span class="line">  COUNT(commission_pct)</span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line">  </span><br><span class="line"># 4 和distinct搭配</span><br><span class="line">SELECT </span><br><span class="line">  SUM(DISTINCT salary),</span><br><span class="line">  SUM(salary) </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  COUNT(DISTINCT salary),</span><br><span class="line">  COUNT(salary) </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line"># 5 count函数的详细介绍</span><br><span class="line">SELECT </span><br><span class="line">  COUNT(salary) </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  COUNT(*) </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line">  </span><br><span class="line">SELECT </span><br><span class="line">  COUNT(1) </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">效率：</span><br><span class="line">myisam存储引擎下，count(*)的效率高</span><br><span class="line">innodb存储引擎下，COUNT(*)和COUNT(1)的效率差不多，比COUNT(字段)要高一些</span><br><span class="line">*/</span><br><span class="line"># 6 和分组函数一同查询的字段有限制</span><br><span class="line"></span><br><span class="line"># select avg(salary),employees_id from employee;</span><br><span class="line"># 和分组函数一同查询的字段要求是group by后的字段</span><br></pre></td></tr></table></figure><h3 id="2-5-分组查询"><a href="#2-5-分组查询" class="headerlink" title="2.5 分组查询"></a>2.5 分组查询</h3><h4 id="2-5-1-语法"><a href="#2-5-1-语法" class="headerlink" title="2.5.1 语法"></a>2.5.1 语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">select 分组函数，列（要求出现在group by的后面）</span><br><span class="line">from 表名</span><br><span class="line">【where 筛选条件】</span><br><span class="line">group by 分组的列表</span><br><span class="line">【order by 子句】</span><br></pre></td></tr></table></figure><blockquote><p>注意：查询列表必须特殊，要求是分组函数和group by后出现的字段</p></blockquote><h4 id="2-5-2-特点"><a href="#2-5-2-特点" class="headerlink" title="2.5.2 特点"></a>2.5.2 特点</h4><ol><li>分组查询中的筛选条件分为两类</li></ol><table><thead><tr><th align="center"></th><th align="center">数据源</th><th align="center">位置</th><th align="center">关键字</th></tr></thead><tbody><tr><td align="center">分组前筛选</td><td align="center">原始表</td><td align="center">group by 子句的前面</td><td align="center">where</td></tr><tr><td align="center">分组后筛选</td><td align="center">分组后的结果集</td><td align="center">group by 子句的后面</td><td align="center">having</td></tr></tbody></table><blockquote><p>①分组函数做条件肯定是放在having子句中<br>②能用分组前筛选的，就优先考虑使用分组前筛选</p></blockquote><ol start="2"><li>group by子句支持单个字段分组，多个字段分组（多个字段之间用逗号隔开，没有顺序要求），表达式或函数（用得较少）</li><li>也可以添加排序（排序放在整个分组查询的最后）</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"># 案例1：查询每个工种的最高工资</span><br><span class="line">SELECT </span><br><span class="line">  MAX(salary),</span><br><span class="line">  job_id </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">GROUP BY job_id ;</span><br><span class="line"></span><br><span class="line"># 案例2： 查询每个位置上部门个数</span><br><span class="line">SELECT COUNT(*),location_id</span><br><span class="line">FROM departments</span><br><span class="line">GROUP BY location_id;</span><br><span class="line"></span><br><span class="line"># 添加筛选条件</span><br><span class="line"># 案例1：查询邮箱中包含a字符的，每个部门的平均工资</span><br><span class="line">SELECT </span><br><span class="line">  AVG(salary),</span><br><span class="line">  department_id </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE email LIKE &#x27;%a%&#x27; </span><br><span class="line">GROUP BY department_id ;</span><br><span class="line"></span><br><span class="line"># 案例2：查询有奖金的每个领导手下员工的最高工资</span><br><span class="line">SELECT MAX(salary),manager_id</span><br><span class="line">FROM employees</span><br><span class="line">WHERE commission_pct IS NOT NULL</span><br><span class="line">GROUP BY manager_id;</span><br><span class="line"></span><br><span class="line"># 添加复杂的筛选条件</span><br><span class="line"># 案例1：查询哪个部门的员工数 &gt; 2</span><br><span class="line"># ①查询每个部门的员工个数</span><br><span class="line">SELECT </span><br><span class="line">  COUNT(*),</span><br><span class="line">  department_id </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">GROUP BY department_id ;</span><br><span class="line"></span><br><span class="line"># ②根据①的结果进行筛选，查询哪个部门的员工数&gt;2</span><br><span class="line">SELECT </span><br><span class="line">  COUNT(*),</span><br><span class="line">  department_id </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">GROUP BY department_id </span><br><span class="line">HAVING COUNT(*)&gt;2;</span><br><span class="line"></span><br><span class="line"># 案例2：查询每个工种有奖金的员工的最高工资&gt;12000的工种编号和最高工资</span><br><span class="line"># ①查询每个工种有奖金的员工的最高工资</span><br><span class="line">SELECT </span><br><span class="line">  MAX(salary),</span><br><span class="line">  job_id </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE commission_pct IS NOT NULL </span><br><span class="line">GROUP BY job_id ;</span><br><span class="line"></span><br><span class="line"># ②根据①结果继续筛选，最高工资 &gt; 12000</span><br><span class="line">SELECT </span><br><span class="line">  MAX(salary),</span><br><span class="line">  job_id </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE commission_pct IS NOT NULL </span><br><span class="line">GROUP BY job_id </span><br><span class="line">HAVING MAX(salary) &gt; 12000 ;</span><br><span class="line"></span><br><span class="line"># 案例3：查询领导编号&gt;102的每个领导手下的最低工资&gt;5000的领导编号是哪个，以及其最低工资</span><br><span class="line"># ①查询每个领导手下的员工最低工资</span><br><span class="line">SELECT MIN(salary),manager_id</span><br><span class="line">FROM employees</span><br><span class="line">GROUP BY manager_id;</span><br><span class="line"></span><br><span class="line"># ②添加筛选条件：编号&gt;102</span><br><span class="line">SELECT </span><br><span class="line">  MIN(salary),</span><br><span class="line">  manager_id </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE manager_id &gt; 102 </span><br><span class="line">GROUP BY manager_id ;</span><br><span class="line"></span><br><span class="line"># ③添加筛选条件：最低工资&gt;5000</span><br><span class="line">SELECT </span><br><span class="line">  MIN(salary),</span><br><span class="line">  manager_id </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE manager_id &gt; 102 </span><br><span class="line">GROUP BY manager_id </span><br><span class="line">HAVING MIN(salary) &gt; 5000 ;</span><br><span class="line"></span><br><span class="line"># 按表达式或函数分组</span><br><span class="line"># 案例：按员工姓名的长度分组，查询每一组的员工个数，筛选员工个数&gt;5的有哪些</span><br><span class="line"># ①查询每个长度的员工个数</span><br><span class="line">SELECT </span><br><span class="line">  COUNT(*),</span><br><span class="line">  LENGTH(last_name) len_name </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">GROUP BY LENGTH(last_name) ;</span><br><span class="line"></span><br><span class="line"># ②添加筛选条件</span><br><span class="line">SELECT </span><br><span class="line">  COUNT(*) C,</span><br><span class="line">  LENGTH(last_name) len_name </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">GROUP BY len_name </span><br><span class="line">HAVING C &gt; 5 ;</span><br><span class="line"></span><br><span class="line"># 按多个字段分组</span><br><span class="line"># 案例：查询每个部门每个工种的员工的平均工资</span><br><span class="line">SELECT </span><br><span class="line">  AVG(salary),</span><br><span class="line">  department_id,</span><br><span class="line">  job_id </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">GROUP BY job_id,</span><br><span class="line">  department_id ;</span><br><span class="line"></span><br><span class="line"># 添加排序</span><br><span class="line"># 案例：查询每个部门每个工种的员工的平均工资，并且按平均工资的高低显示</span><br><span class="line">SELECT </span><br><span class="line">  AVG(salary),</span><br><span class="line">  department_id,</span><br><span class="line">  job_id </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE department_id IS NOT NULL </span><br><span class="line">GROUP BY job_id,</span><br><span class="line">  department_id </span><br><span class="line">HAVING AVG(salary) &gt; 10000 </span><br><span class="line">ORDER BY AVG(salary) DESC ;</span><br></pre></td></tr></table></figure><h3 id="2-5-连接查询"><a href="#2-5-连接查询" class="headerlink" title="2.5 连接查询"></a>2.5 连接查询</h3><h4 id="2-5-1-含义"><a href="#2-5-1-含义" class="headerlink" title="2.5.1 含义"></a>2.5.1 含义</h4><p>又称多表查询，当查询的字段来自于多个表时，就会用到连接查询</p><blockquote><p><strong>笛卡尔乘积现象</strong>：表1 有 m 行，表2有 n 行，结果有 m*n 行</p><p>发生原因：没有有效的连接条件<br>如何避免：添加有效的连接条件</p></blockquote><h4 id="2-5-2-分类"><a href="#2-5-2-分类" class="headerlink" title="2.5.2 分类"></a>2.5.2 分类</h4><p>1）按年代分类：<br>    ① sql92标准：仅仅支持内连接<br>    ② sql99标准【推荐】：支持内连接+外连接（左外和右外）+交叉连接<br>2）按功能分类：<br>    ① 内连接：等值连接、非等值连接、自连接<br>    ② 外连接：左外连接、右外连接、全外连接<br>    ③ 交叉连接</p><h4 id="2-5-3-sql92标准"><a href="#2-5-3-sql92标准" class="headerlink" title="2.5.3 sql92标准"></a>2.5.3 sql92标准</h4><p>1）等值连接</p><p>​    ① 多表等值连接的结果为多表的交集部分<br>​    ② n表连接，至少需要n-1个连接条件<br>​    ③ 多表的顺序没有要求<br>​    ④ 一般需要为表起别名<br>​    ⑤ 可以搭配前面介绍的所有子句使用，比如排序、分组、筛选</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line"># 案例1：查询女神名和对应的男神名</span><br><span class="line">SELECT </span><br><span class="line">  NAME,</span><br><span class="line">  boyName </span><br><span class="line">FROM</span><br><span class="line">  beaupty,</span><br><span class="line">  boys </span><br><span class="line">WHERE beauty.boyfriend_id = boys.id ;</span><br><span class="line"></span><br><span class="line">USE myemployees;</span><br><span class="line"># 案例2：查询员工名和对应的部门名</span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  department_name </span><br><span class="line">FROM</span><br><span class="line">  employees,</span><br><span class="line">  departments </span><br><span class="line">WHERE employees.`department_id` = departments.`department_id` ;</span><br><span class="line"></span><br><span class="line"># 2、为表取别名</span><br><span class="line">/*</span><br><span class="line">①提高语句的简洁度</span><br><span class="line">②区分多个重名的字段</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line"># 查询员工名、工种号、工种名</span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  e.job_id,</span><br><span class="line">  job_title </span><br><span class="line">FROM</span><br><span class="line">  employees e,</span><br><span class="line">  jobs j</span><br><span class="line">WHERE e.`job_id` = j.`job_id` ;</span><br><span class="line"></span><br><span class="line"># 3、两个表的顺序是否可以调换</span><br><span class="line"># 查询员工名、工种号、工种名</span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  e.job_id,</span><br><span class="line">  job_title </span><br><span class="line">FROM</span><br><span class="line">  jobs j,</span><br><span class="line">  employees e</span><br><span class="line">WHERE e.`job_id` = j.`job_id` ;</span><br><span class="line"></span><br><span class="line"># 4、可以加筛选吗？</span><br><span class="line"># 案例1：查询有奖金的员工名、部门名</span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  department_name,</span><br><span class="line">  commission_pct </span><br><span class="line">FROM</span><br><span class="line">  employees e,</span><br><span class="line">  departments d </span><br><span class="line">WHERE e.`department_id` = d.`department_id` </span><br><span class="line">  AND e.`commission_pct` IS NOT NULL ;</span><br><span class="line"></span><br><span class="line"># 案例2：查询城市名中第二个字符为o的部门名和城市名</span><br><span class="line">SELECT </span><br><span class="line">  department_name,</span><br><span class="line">  city </span><br><span class="line">FROM</span><br><span class="line">  departments d,</span><br><span class="line">  locations l </span><br><span class="line">WHERE d.`location_id` = l.`location_id` </span><br><span class="line">  AND city LIKE &#x27;_o%&#x27; ;</span><br><span class="line"></span><br><span class="line"># 5、可以加分组吗？</span><br><span class="line"># 案例1：查询每个城市的部门个数</span><br><span class="line">SELECT </span><br><span class="line">  COUNT(*) 个数,</span><br><span class="line">  city </span><br><span class="line">FROM</span><br><span class="line">  locations l,</span><br><span class="line">  departments d </span><br><span class="line">WHERE l.`location_id` = d.`location_id` </span><br><span class="line">GROUP BY city ;</span><br><span class="line"></span><br><span class="line"># 案例2：查询有奖金的每个部门的部门名和部门的领导编号和该部门的最低工资</span><br><span class="line">SELECT </span><br><span class="line">  department_name,</span><br><span class="line">  d.manager_id,</span><br><span class="line">  MIN(salary) </span><br><span class="line">FROM</span><br><span class="line">  departments d,</span><br><span class="line">  employees e </span><br><span class="line">WHERE d.`department_id` = e.`department_id`</span><br><span class="line">  AND commission_pct IS NOT NULL </span><br><span class="line">GROUP BY department_name,</span><br><span class="line">  d.manager_id ;</span><br><span class="line"></span><br><span class="line"># 6、可以加排序吗？</span><br><span class="line"># 案例：查询每个工种的工种名和员工的个数，并且按员工个数降序</span><br><span class="line">SELECT </span><br><span class="line">  job_title,</span><br><span class="line">  COUNT(*) 个数 </span><br><span class="line">FROM</span><br><span class="line">  jobs j,</span><br><span class="line">  employees e </span><br><span class="line">WHERE e.`job_id` = j.`job_id` </span><br><span class="line">GROUP BY job_title </span><br><span class="line">ORDER BY COUNT(*) DESC ;</span><br><span class="line"></span><br><span class="line"># 7、可以实现三表连接吗？</span><br><span class="line"># 案例：查询员工名、部门名和所在的城市</span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  department_name,</span><br><span class="line">  city </span><br><span class="line">FROM</span><br><span class="line">  employees e,</span><br><span class="line">  departments d,</span><br><span class="line">  locations l </span><br><span class="line">WHERE e.`department_id` = d.`department_id` </span><br><span class="line">  AND d.`location_id` = l.`location_id` ;</span><br><span class="line">#  and city like &#x27;s%&#x27; </span><br><span class="line"># order by last_name ;</span><br></pre></td></tr></table></figure><p>2）非等值连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 案例1：查询员工的工资和工资等级</span><br><span class="line"></span><br><span class="line">SELECT salary, grade_level</span><br><span class="line">FROM employees e, job_grades j</span><br><span class="line">WHERE salary BETWEEN j.`lowest_sal` AND j.`highest_sal`;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">CREATE TABLE job_grades (</span><br><span class="line">  grade_level VARCHAR (3),</span><br><span class="line">  lowest_sal int,</span><br><span class="line">  highest_sal int</span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line">INSERT INTO job_grades</span><br><span class="line">VALUES (&#x27;A&#x27;, 1000, 2999);</span><br><span class="line"></span><br><span class="line">INSERT INTO job_grades</span><br><span class="line">VALUES (&#x27;B&#x27;, 3000, 5999);</span><br><span class="line"></span><br><span class="line">INSERT INTO job_grades</span><br><span class="line">VALUES(&#x27;C&#x27;, 6000, 9999);</span><br><span class="line"></span><br><span class="line">INSERT INTO job_grades</span><br><span class="line">VALUES(&#x27;D&#x27;, 10000, 14999);</span><br><span class="line"></span><br><span class="line">INSERT INTO job_grades</span><br><span class="line">VALUES(&#x27;E&#x27;, 15000, 24999);</span><br><span class="line"></span><br><span class="line">INSERT INTO job_grades</span><br><span class="line">VALUES(&#x27;F&#x27;, 25000, 40000);</span><br><span class="line"></span><br><span class="line">select * from job_grades;</span><br><span class="line"></span><br><span class="line">*/</span><br></pre></td></tr></table></figure><p>3）自连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 案例：查询员工名和上级领导名</span><br><span class="line">SELECT e.employee_id, e.last_name, m.employee_id, m.last_name</span><br><span class="line">FROM employees e, employees m</span><br><span class="line">WHERE e.`manager_id` = m.`employee_id`;</span><br></pre></td></tr></table></figure><h4 id="2-5-4-sql99标准"><a href="#2-5-4-sql99标准" class="headerlink" title="2.5.4 sql99标准"></a>2.5.4 sql99标准</h4><p><strong>语法</strong>    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表1 别名 【连接类型】</span><br><span class="line">join 表2 别名</span><br><span class="line">on 连接条件</span><br><span class="line">【where 筛选条件】</span><br><span class="line">【group by 分组】</span><br><span class="line">【having 筛选条件】</span><br><span class="line">【order by 排序列表】</span><br></pre></td></tr></table></figure><p><strong>分类</strong></p><p>① 内连接（★）：inner</p><p>② 外连接</p><ul><li>左外（★）：left 【outer】</li><li>右外（★）：right 【outer】</li><li>全外：full 【outer】</li></ul><p>③ 交叉连接：cross</p><p><strong>1） 内连接</strong></p><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表1 别名</span><br><span class="line">inner join 表2 别名</span><br><span class="line">on 连接条件</span><br></pre></td></tr></table></figure><p><strong>分类</strong></p><p>① 等值连接<br>② 非等值连接<br>③ 自连接</p><p>特点：<br>① 添加排序、分组、筛选<br>② inner可以省略<br>③ 筛选条件放在where后面，连接条件放在on后面，提高分离性，便于阅读<br>④ inner join连接和sql92语法中的等值连接效果是一样的，都是查询多表的交集</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">USE myemployees;</span><br><span class="line"></span><br><span class="line"># 1 等值连接</span><br><span class="line"># 案例1：查询员工名、部门名</span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  department_name </span><br><span class="line">FROM</span><br><span class="line">  employees e </span><br><span class="line">  INNER JOIN departments d </span><br><span class="line">    ON e.`department_id` = d.`department_id` ;</span><br><span class="line"></span><br><span class="line"># 案例2：查询名字中包含e的员工名和工种名（添加筛选）</span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  job_title </span><br><span class="line">FROM</span><br><span class="line">  employees e </span><br><span class="line">  INNER JOIN jobs j </span><br><span class="line">    ON e.`job_id` = j.`job_id` </span><br><span class="line">WHERE last_name LIKE &#x27;%e%&#x27; ;</span><br><span class="line"></span><br><span class="line"># 案例3：查询部门个数&gt;3的城市名和部门个数，（添加分组+筛选）</span><br><span class="line">SELECT </span><br><span class="line">  city,</span><br><span class="line">  COUNT(*) 个数</span><br><span class="line">FROM</span><br><span class="line">  locations l </span><br><span class="line">  INNER JOIN departments d </span><br><span class="line">    ON l.`location_id` = d.`location_id` </span><br><span class="line">GROUP BY city </span><br><span class="line">HAVING COUNT(*) &gt; 3 ;</span><br><span class="line"></span><br><span class="line"># 案例4：查询哪个部门的员工个数&gt;3的部门名和员工个数，并按个数降序（添加排序）</span><br><span class="line">SELECT </span><br><span class="line">  department_name,</span><br><span class="line">  COUNT(*) 个数</span><br><span class="line">FROM</span><br><span class="line">  departments d </span><br><span class="line">  INNER JOIN employees e </span><br><span class="line">    ON d.`department_id` = e.`department_id` </span><br><span class="line">GROUP BY department_name </span><br><span class="line">HAVING COUNT(*) &gt; 3 </span><br><span class="line">ORDER BY COUNT(*) DESC ;</span><br><span class="line"></span><br><span class="line"># 案例5：查询员工名、部门名、工种名，并按部门名降序（添加三表连接）</span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  department_name,</span><br><span class="line">  job_title </span><br><span class="line">FROM</span><br><span class="line">  employees e </span><br><span class="line">  INNER JOIN departments d </span><br><span class="line">    ON e.`department_id` = d.`department_id` </span><br><span class="line">  INNER JOIN jobs j </span><br><span class="line">    ON e.`job_id` = j.`job_id` </span><br><span class="line">ORDER BY department_name DESC ;</span><br><span class="line"></span><br><span class="line"># 2 非等值连接</span><br><span class="line"># 案例1：查询员工的工资级别</span><br><span class="line">SELECT </span><br><span class="line">  salary,</span><br><span class="line">  grade_level </span><br><span class="line">FROM</span><br><span class="line">  employees e </span><br><span class="line">  JOIN job_grades g </span><br><span class="line">    ON e.`salary` BETWEEN g.`lowest_sal` </span><br><span class="line">    AND g.`highest_sal` ;</span><br><span class="line"></span><br><span class="line"># 案例2：查询工资级别的个数&gt;20的个数，并且按工资级别降序</span><br><span class="line">SELECT </span><br><span class="line">  grade_level,</span><br><span class="line">  COUNT(*) </span><br><span class="line">FROM</span><br><span class="line">  employees e </span><br><span class="line">  JOIN job_grades g </span><br><span class="line">    ON e.`salary` BETWEEN g.`lowest_sal` </span><br><span class="line">    AND g.`highest_sal` </span><br><span class="line">GROUP BY grade_level </span><br><span class="line">HAVING COUNT(*) &gt; 20 </span><br><span class="line">ORDER BY grade_level DESC ;</span><br><span class="line"></span><br><span class="line"># 3 自连接</span><br><span class="line"># 案例1：查询员工的名字、上级的名字</span><br><span class="line">SELECT </span><br><span class="line">  e.last_name 员工,</span><br><span class="line">  m.last_name 上级 </span><br><span class="line">FROM</span><br><span class="line">  employees e </span><br><span class="line">  JOIN employees m </span><br><span class="line">    ON e.`manager_id` = m.`employee_id` ;</span><br><span class="line"></span><br><span class="line"># 案例2：查询姓名中包含字符k的员工的名字、上级的名字</span><br><span class="line">SELECT </span><br><span class="line">  e.last_name 员工,</span><br><span class="line">  m.last_name 上级 </span><br><span class="line">FROM</span><br><span class="line">  employees e </span><br><span class="line">  JOIN employees m </span><br><span class="line">    ON e.`manager_id` = m.`employee_id` </span><br><span class="line">WHERE e.`last_name` LIKE &#x27;%k%&#x27; ;</span><br></pre></td></tr></table></figure><p><strong>2）外连接</strong></p><p> <strong>应用场景</strong>：用于查询一个表中有，另一个表没有的记录</p><p> <strong>特点</strong><br>① 外连接的查询结果为主表中的所有记录，<br>    如果从表中有和它匹配的，则显示匹配的值；<br>    如果从表中没有和它匹配的，则显示null；<br>    外连接查询结果 &#x3D; 内连接结果 + 主表中有而从表没有的记录</p><p>② 左外连接 ，left join 左边的是主表；<br>    右外连接，right join 右边的是主表</p><p>③ 左外和右外交换两个表的顺序，可以实现同样的效果 </p><p>④ 全外连接 &#x3D; 内连接的结果 + 表1中有但表2没有的 + 表2中有但表1没有的</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"># 引入：查询男朋友不在男神表的女神名</span><br><span class="line">USE girls;</span><br><span class="line">SELECT * FROM beauty;</span><br><span class="line">SELECT * FROM boys;</span><br><span class="line"></span><br><span class="line"># 左外连接</span><br><span class="line">SELECT </span><br><span class="line">  b.name </span><br><span class="line">FROM</span><br><span class="line">  beauty b </span><br><span class="line">  LEFT OUTER JOIN boys bo </span><br><span class="line">    ON b.`boyfriend_id` = bo.`id` </span><br><span class="line">WHERE bo.`id` IS NULL ;</span><br><span class="line"></span><br><span class="line"># 右外连接</span><br><span class="line">SELECT </span><br><span class="line">  b.name </span><br><span class="line">FROM</span><br><span class="line">  boys bo </span><br><span class="line">  RIGHT OUTER JOIN beauty b </span><br><span class="line">    ON b.`boyfriend_id` = bo.`id` </span><br><span class="line">WHERE bo.`id` IS NULL ;</span><br><span class="line"></span><br><span class="line"># 案例1：查询哪个部门没有员工</span><br><span class="line">USE myemployees;</span><br><span class="line"></span><br><span class="line"># 左外</span><br><span class="line">SELECT </span><br><span class="line">  d.*,</span><br><span class="line">  e.employee_id </span><br><span class="line">FROM</span><br><span class="line">  departments d </span><br><span class="line">  LEFT OUTER JOIN employees e </span><br><span class="line">    ON d.`department_id` = e.`department_id` </span><br><span class="line">WHERE employee_id IS NULL ;</span><br><span class="line"></span><br><span class="line"># 右外</span><br><span class="line">SELECT </span><br><span class="line">  d.*,</span><br><span class="line">  e.employee_id </span><br><span class="line">FROM</span><br><span class="line">  employees e </span><br><span class="line">  RIGHT </span><br><span class="line">  OUTER JOIN departments d </span><br><span class="line">    ON d.`department_id` = e.`department_id` </span><br><span class="line">WHERE e.`employee_id` IS NULL ;</span><br><span class="line"></span><br><span class="line"># 全外</span><br><span class="line">USE girls ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  b.*,</span><br><span class="line">  bo.* </span><br><span class="line">FROM</span><br><span class="line">  beauty b FULL </span><br><span class="line">  OUTER JOIN boys bo </span><br><span class="line">    ON b.`boyfriend_id` = bo.id ;</span><br><span class="line"># MySQL不支持全外连接</span><br></pre></td></tr></table></figure><p><strong>3）交叉连接</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  b.*,</span><br><span class="line">  bo.* </span><br><span class="line">FROM</span><br><span class="line">  beauty b </span><br><span class="line">  CROSS JOIN boys bo ;</span><br></pre></td></tr></table></figure><blockquote><p><strong>sql92 vs sql99</strong><br>功能：sql99支持的较多<br>可读性：sql99实现连接条件和筛选条件的分离，可读性较高</p></blockquote><h3 id="2-6-子查询"><a href="#2-6-子查询" class="headerlink" title="2.6 子查询"></a>2.6 子查询</h3><h4 id="2-6-1-含义"><a href="#2-6-1-含义" class="headerlink" title="2.6.1 含义"></a>2.6.1 含义</h4><p>出现在其他语句中的select语句，称为 子查询 或 内查询<br>外部的查询语句，称为 主查询 或 外查询</p><h4 id="2-6-2-分类"><a href="#2-6-2-分类" class="headerlink" title="2.6.2 分类"></a>2.6.2 分类</h4><p>① 按子查询出现的位置：</p><ul><li>select后面：<br>仅仅支持标量子查询</li><li>from后面：<br>支持表子查询</li><li>where 或 having后面：★<br>标量子查询（单行） √<br>    列子查询（多行） √<br>    行子查询</li><li>exists后面（相关子查询）：<br>表子查询</li></ul><p>②  按结果集的行列数不同：</p><ul><li>标量子查询（结果集中只有一行一列）</li><li>列子查询（结果集有一列多行）</li><li>行子查询（结果集有一行多列）</li><li>表子查询（结果集一般为多行多列）</li></ul><h4 id="2-6-3-where-或-having-后面"><a href="#2-6-3-where-或-having-后面" class="headerlink" title="2.6.3 where 或 having 后面"></a>2.6.3 where 或 having 后面</h4><p><strong>特点</strong><br>① 子查询放在小括号内<br>② 子查询一般放在条件的右侧<br>③ 标量子查询，一般搭配着<strong>单行操作符</strong>使用；<br>     列子查询，一般搭配着<strong>多行操作符</strong>使用</p><blockquote><p><strong>单行操作符</strong>：&gt; 、&lt; 、&gt;&#x3D;、 &lt;&#x3D; 、&#x3D; 、&lt;&gt;</p><p><strong>多行操作符</strong>：in、any&#x2F;some、all</p></blockquote><p>④ 子查询的执行优先于主查询执行，主查询的条件用到了子查询的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">1、标量子查询（单行子查询）</span><br><span class="line">2、列子查询（多行子查询）</span><br><span class="line"></span><br><span class="line">3、行子查询（多列多行）</span><br><span class="line">*/</span><br><span class="line"># 1 标量子查询★</span><br><span class="line"># 案例1：谁的工资比 Abel 高?</span><br><span class="line"># ① 查询Abel的工资</span><br><span class="line">SELECT </span><br><span class="line">  salary </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE last_name = &#x27;Abel&#x27; ;</span><br><span class="line"></span><br><span class="line"># ② 查询员工的信息，满足 salary&gt;① 结果</span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE salary &gt; </span><br><span class="line">  (SELECT </span><br><span class="line">    salary </span><br><span class="line">  FROM</span><br><span class="line">    employees </span><br><span class="line">  WHERE last_name = &#x27;Abel&#x27;) ;</span><br><span class="line"></span><br><span class="line"># 案例2：返回job_id与141号员工相同，salary比143号员工多的员工 姓名，job_id 和工资</span><br><span class="line"># ① 查询141号员工的job_id</span><br><span class="line">SELECT </span><br><span class="line">  job_id </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE employee_id = 141 ;</span><br><span class="line"></span><br><span class="line"># ② 查询143号员工的salary</span><br><span class="line">SELECT </span><br><span class="line">  salary </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE employee_id = 143 ;</span><br><span class="line"></span><br><span class="line"># ③ 查询员工的姓名，job_id 和工资，要求job_id=①并且salary&gt;②</span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  job_id,</span><br><span class="line">  salary </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE job_id = </span><br><span class="line">  (SELECT </span><br><span class="line">    job_id </span><br><span class="line">  FROM</span><br><span class="line">    employees </span><br><span class="line">  WHERE employee_id = 141) </span><br><span class="line">  AND salary &gt; </span><br><span class="line">  (SELECT </span><br><span class="line">    salary </span><br><span class="line">  FROM</span><br><span class="line">    employees </span><br><span class="line">  WHERE employee_id = 143) ;</span><br><span class="line"></span><br><span class="line"># 案例3：返回公司工资最少的员工的last_name,job_id和salary</span><br><span class="line"># ① 查询公司的 最低工资</span><br><span class="line">SELECT MIN(salary)</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line"># ② 查询last_name,job_id和salary，要求salary=①</span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  job_id,</span><br><span class="line">  salary </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE salary = </span><br><span class="line">  (SELECT </span><br><span class="line">    MIN(salary) </span><br><span class="line">  FROM</span><br><span class="line">    employees) ;</span><br><span class="line"></span><br><span class="line"># 案例4：查询最低工资大于50号部门最低工资的部门id和其最低工资</span><br><span class="line"># ① 查询50号部门的最低工资</span><br><span class="line">SELECT </span><br><span class="line">  MIN(salary) </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE department_id = 50 ;</span><br><span class="line"></span><br><span class="line"># ② 查询每个部门的最低工资</span><br><span class="line">SELECT </span><br><span class="line">  MIN(salary),</span><br><span class="line">  department_id </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">GROUP BY department_id ;</span><br><span class="line"></span><br><span class="line">#③ 在②基础上筛选，满足min(salary)&gt;①</span><br><span class="line">SELECT </span><br><span class="line">  MIN(salary),</span><br><span class="line">  department_id </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">GROUP BY department_id </span><br><span class="line">HAVING MIN(salary) &gt; </span><br><span class="line">  (SELECT </span><br><span class="line">    MIN(salary) </span><br><span class="line">  FROM</span><br><span class="line">    employees </span><br><span class="line">  WHERE department_id = 50) ;</span><br><span class="line"></span><br><span class="line"># 非法使用标量子查询</span><br><span class="line">SELECT </span><br><span class="line">  MIN(salary),</span><br><span class="line">  department_id </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">GROUP BY department_id </span><br><span class="line">HAVING MIN(salary) &gt; </span><br><span class="line">  (SELECT </span><br><span class="line">    MIN(salary) #    salary </span><br><span class="line">  FROM</span><br><span class="line">    employees </span><br><span class="line">  WHERE department_id = 50) ;</span><br><span class="line">#  WHERE department_id = 250) ;</span><br><span class="line"></span><br><span class="line"># 2 列子查询（多行子查询）</span><br><span class="line"># 案例1：返回location_id是1400或1700的部门中的所有员工姓名</span><br><span class="line"># ① 查询location_id是1400或1700的部门编号</span><br><span class="line">SELECT DISTINCT </span><br><span class="line">  department_id </span><br><span class="line">FROM</span><br><span class="line">  departments </span><br><span class="line">WHERE location_id IN (1400, 1700) ;</span><br><span class="line"></span><br><span class="line"># ② 查询员工姓名，要求部门号是①列表中的某一个</span><br><span class="line"> </span><br><span class="line">SELECT </span><br><span class="line">  last_name </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE department_id IN </span><br><span class="line">  (SELECT DISTINCT </span><br><span class="line">    department_id </span><br><span class="line">  FROM</span><br><span class="line">    departments </span><br><span class="line">  WHERE location_id IN (1400, 1700)</span><br><span class="line"></span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line"># 案例2：返回其它工种中比job_id为‘IT_PROG’工种任一工资低的员工的员工号、姓名、job_id 以及salary</span><br><span class="line"># ① 查询job_id为‘IT_PROG’部门任一工资</span><br><span class="line">SELECT DISTINCT </span><br><span class="line">  salary </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE job_id = &#x27;IT_PROG&#x27; ;</span><br><span class="line"></span><br><span class="line"># ② 查询员工号、姓名、job_id 以及salary，salary&lt;(①)的任意一个</span><br><span class="line">SELECT </span><br><span class="line">  employee_id,</span><br><span class="line">  last_name,</span><br><span class="line">  job_id,</span><br><span class="line">  salary </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE salary &lt; ANY </span><br><span class="line">  (SELECT DISTINCT </span><br><span class="line">    salary </span><br><span class="line">  FROM</span><br><span class="line">    employees </span><br><span class="line">  WHERE job_id = &#x27;IT_PROG&#x27;) </span><br><span class="line">  AND job_id &lt;&gt; &#x27;IT_PROG&#x27; ;</span><br><span class="line"></span><br><span class="line"># 或</span><br><span class="line">SELECT </span><br><span class="line">  employee_id,</span><br><span class="line">  last_name,</span><br><span class="line">  job_id,</span><br><span class="line">  salary </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE salary &lt; </span><br><span class="line">  (SELECT DISTINCT </span><br><span class="line">    MAX(salary) </span><br><span class="line">  FROM</span><br><span class="line">    employees </span><br><span class="line">  WHERE job_id = &#x27;IT_PROG&#x27;) </span><br><span class="line">  AND job_id &lt;&gt; &#x27;IT_PROG&#x27; ;</span><br><span class="line"></span><br><span class="line"># 案例3：返回其它部门中比job_id为‘IT_PROG’部门所有工资都低的员工的员工号、姓名、job_id 以及salary</span><br><span class="line">SELECT </span><br><span class="line">  employee_id,</span><br><span class="line">  last_name,</span><br><span class="line">  job_id,</span><br><span class="line">  salary </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE salary &lt; ALL </span><br><span class="line">  (SELECT DISTINCT </span><br><span class="line">    salary </span><br><span class="line">  FROM</span><br><span class="line">    employees </span><br><span class="line">  WHERE job_id = &#x27;IT_PROG&#x27;) </span><br><span class="line">  AND job_id &lt;&gt; &#x27;IT_PROG&#x27; ;</span><br><span class="line"></span><br><span class="line"># 或</span><br><span class="line">SELECT </span><br><span class="line">  employee_id,</span><br><span class="line">  last_name,</span><br><span class="line">  job_id,</span><br><span class="line">  salary </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE salary &lt; </span><br><span class="line">  (SELECT DISTINCT </span><br><span class="line">    MIN(salary) </span><br><span class="line">  FROM</span><br><span class="line">    employees </span><br><span class="line">  WHERE job_id = &#x27;IT_PROG&#x27;) </span><br><span class="line">  AND job_id &lt;&gt; &#x27;IT_PROG&#x27; ;</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"># 3 行子查询（结果集一行多列或多行多列）</span><br><span class="line"># 案例：查询员工编号最小并且工资最高的员工信息</span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE (employee_id, salary) = </span><br><span class="line">  (SELECT </span><br><span class="line">    MIN(employee_id),</span><br><span class="line">    MAX(salary) </span><br><span class="line">  FROM</span><br><span class="line">    employees) ;</span><br><span class="line"></span><br><span class="line"># 用前面的知识</span><br><span class="line"># ① 查询最小的员工编号</span><br><span class="line">SELECT </span><br><span class="line">  MIN(employee_id) </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line"># ② 查询最高工资</span><br><span class="line">SELECT </span><br><span class="line">  MAX(salary) </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line"># ③ 查询员工信息</span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE employee_id = </span><br><span class="line">  (SELECT </span><br><span class="line">    MIN(employee_id) </span><br><span class="line">  FROM</span><br><span class="line">    employees) </span><br><span class="line">  AND salary = </span><br><span class="line">  (SELECT </span><br><span class="line">    MAX(salary) </span><br><span class="line">  FROM</span><br><span class="line">    employees) ;</span><br></pre></td></tr></table></figure><h4 id="2-6-4-select后面"><a href="#2-6-4-select后面" class="headerlink" title="2.6.4 select后面"></a>2.6.4 select后面</h4><blockquote><p>仅仅支持标量子查询</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># 案例1：查询每个部门的员工个数</span><br><span class="line">SELECT </span><br><span class="line">  d.*,</span><br><span class="line">  (SELECT </span><br><span class="line">    COUNT(*) </span><br><span class="line">  FROM</span><br><span class="line">    employees e </span><br><span class="line">  WHERE e.department_id = d.`department_id`) 个数</span><br><span class="line">FROM</span><br><span class="line">  departments d ;</span><br><span class="line"></span><br><span class="line"># 案例2：查询员工号=102的部门名</span><br><span class="line">SELECT </span><br><span class="line">  (SELECT </span><br><span class="line">    department_name</span><br><span class="line">  FROM</span><br><span class="line">    departments d </span><br><span class="line">    INNER JOIN employees e </span><br><span class="line">      ON d.department_id = e.department_id </span><br><span class="line">  WHERE e.employee_id = 102) 部门名 ;</span><br></pre></td></tr></table></figure><h4 id="2-6-5-from后面"><a href="#2-6-5-from后面" class="headerlink" title="2.6.5 from后面"></a>2.6.5 from后面</h4><blockquote><p>将子查询结果充当一张表，要求必须起别名</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 案例：查询每个部门的平均工资的工资等级</span><br><span class="line"># ① 查询每个部门的平均工资</span><br><span class="line">SELECT </span><br><span class="line">  AVG(salary),</span><br><span class="line">  department_id </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">GROUP BY department_id ;</span><br><span class="line"></span><br><span class="line"># ② 连接①的结果集和job_grades表，筛选条件平均工资 between lowest_sal and highest_sal</span><br><span class="line">SELECT </span><br><span class="line">  ag_dep.*,</span><br><span class="line">  g.`grade_level` </span><br><span class="line">FROM</span><br><span class="line">  (SELECT </span><br><span class="line">    AVG(salary) ag,</span><br><span class="line">    department_id </span><br><span class="line">  FROM</span><br><span class="line">    employees </span><br><span class="line">  GROUP BY department_id) ag_dep </span><br><span class="line">  INNER JOIN job_grades g </span><br><span class="line">    ON ag_dep.ag BETWEEN lowest_sal </span><br><span class="line">    AND highest_sal ;</span><br></pre></td></tr></table></figure><h4 id="2-6-6-exists后面（相关子查询）"><a href="#2-6-6-exists后面（相关子查询）" class="headerlink" title="2.6.6 exists后面（相关子查询）"></a>2.6.6 exists后面（相关子查询）</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line">语法：</span><br><span class="line">exists(完整的查询语句)</span><br><span class="line">结果：</span><br><span class="line">1或0</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">SELECT </span><br><span class="line">  EXISTS </span><br><span class="line">  (SELECT </span><br><span class="line">    employee_id </span><br><span class="line">  FROM</span><br><span class="line">    employees </span><br><span class="line">  WHERE salary = 300000) ;</span><br><span class="line"></span><br><span class="line"># 案例1：查询有员工的部门名</span><br><span class="line"># in</span><br><span class="line">SELECT </span><br><span class="line">  department_name </span><br><span class="line">FROM</span><br><span class="line">  departments d </span><br><span class="line">WHERE d.`department_id` IN </span><br><span class="line">  (SELECT </span><br><span class="line">    department_id </span><br><span class="line">  FROM</span><br><span class="line">    employees) ;</span><br><span class="line"></span><br><span class="line"># exists</span><br><span class="line">SELECT </span><br><span class="line">  department_name </span><br><span class="line">FROM</span><br><span class="line">  departments d </span><br><span class="line">WHERE EXISTS </span><br><span class="line">  (SELECT </span><br><span class="line">    * </span><br><span class="line">  FROM</span><br><span class="line">    employees e </span><br><span class="line">  WHERE d.`department_id` = e.`department_id`) ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  department_id </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line"></span><br><span class="line"># 案例2：查询没有女朋友的男神信息</span><br><span class="line"># in</span><br><span class="line">  SELECT </span><br><span class="line">    bo.* </span><br><span class="line">  FROM</span><br><span class="line">    boys bo </span><br><span class="line">  WHERE bo.id NOT IN </span><br><span class="line">    (SELECT </span><br><span class="line">      boyfriend_id </span><br><span class="line">    FROM</span><br><span class="line">      beauty) ;</span><br><span class="line"></span><br><span class="line"># exists</span><br><span class="line">SELECT </span><br><span class="line">  bo.* </span><br><span class="line">FROM</span><br><span class="line">  boys bo </span><br><span class="line">WHERE NOT EXISTS </span><br><span class="line">  (SELECT </span><br><span class="line">    boyfriend_id </span><br><span class="line">  FROM</span><br><span class="line">    beauty b </span><br><span class="line">  WHERE bo.`id` = b.`boyfriend_id`) ;</span><br></pre></td></tr></table></figure><h3 id="2-7-分页查询"><a href="#2-7-分页查询" class="headerlink" title="2.7 分页查询"></a>2.7 分页查询</h3><h4 id="2-7-1-应用场景"><a href="#2-7-1-应用场景" class="headerlink" title="2.7.1 应用场景"></a>2.7.1 应用场景</h4><p>当要查询的条目数太多，一页显示不全,需要分页提交sql请求</p><h4 id="2-7-2-语法"><a href="#2-7-2-语法" class="headerlink" title="2.7.2 语法"></a>2.7.2 语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">select 查询列表</span><br><span class="line">from 表1</span><br><span class="line">【join type join 表2</span><br><span class="line">on 连接条件</span><br><span class="line">where 筛选条件</span><br><span class="line">group by 分组字段</span><br><span class="line">having 分组后的筛选</span><br><span class="line">order by 排序的字段】</span><br><span class="line">limit offset, size;</span><br></pre></td></tr></table></figure><blockquote><p>offset：要显示条目的起始索引（起始索引从0开始）<br>size：要显示的条目个数</p></blockquote><h4 id="2-7-3-特点"><a href="#2-7-3-特点" class="headerlink" title="2.7.3 特点"></a>2.7.3 特点</h4><p>① limit语句放在查询语句的最后<br>② 公式：<code>limit (page-1)*size,size;</code></p><blockquote><p>要显示的页数 page，没有条目数 size</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">USE myemployees;</span><br><span class="line"># 案例1：查询前五条员工信息</span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">LIMIT 0, 5 ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">LIMIT 5 ;</span><br><span class="line"></span><br><span class="line"># 案例2：查询第11-25条员工信息</span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">LIMIT 11, 15 ;</span><br><span class="line"></span><br><span class="line"># 案例3：有奖金的员工信息，并且工资较高的前10名显示出来</span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE commission_pct IS NOT NULL </span><br><span class="line">ORDER BY salary DESC </span><br><span class="line">LIMIT 10 ;</span><br></pre></td></tr></table></figure><h3 id="2-8-联合查询"><a href="#2-8-联合查询" class="headerlink" title="2.8 联合查询"></a>2.8 联合查询</h3><h4 id="2-8-1-应用场景"><a href="#2-8-1-应用场景" class="headerlink" title="2.8.1 应用场景"></a>2.8.1 应用场景</h4><p>要查询的结果来自于多个表，且多个表没有直接的连接关系，但查询的信息一致时</p><h4 id="2-8-2-语法"><a href="#2-8-2-语法" class="headerlink" title="2.8.2 语法"></a>2.8.2 语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">查询语句1</span><br><span class="line">union</span><br><span class="line">查询语句2</span><br><span class="line">union</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p><code>union</code>: 联合、合并。将多条查询语句的结果合并成一个结果</p><h4 id="2-8-3-特点★"><a href="#2-8-3-特点★" class="headerlink" title="2.8.3 特点★"></a>2.8.3 特点★</h4><p>① 要求多条查询语句的查询列数是一致的！</p><p>② 要求多条查询语句的查询的每一列的类型和顺序最好一致</p><p>③ union关键字默认去重，如果使用union all 可以包含重复项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">USE myemployees;</span><br><span class="line"># 引入：查询部门编号&gt;90 或 邮箱包含a的员工信息</span><br><span class="line"> </span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE email LIKE &#x27;%a%&#x27; </span><br><span class="line">  OR department_id &gt; 90 ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE email LIKE &#x27;%a%&#x27; </span><br><span class="line">UNION</span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">WHERE department_id &gt; 90 ;</span><br></pre></td></tr></table></figure><hr><h2 id="第三章-DML语言"><a href="#第三章-DML语言" class="headerlink" title="第三章 DML语言"></a>第三章 DML语言</h2><p>DML（Data Manipulation Language）：数据操作语言，用来定义数据库记录（数据）</p><blockquote><p>插入：insert<br>修改：update<br>删除：delete</p></blockquote><h3 id="3-1-插入语言"><a href="#3-1-插入语言" class="headerlink" title="3.1 插入语言"></a>3.1 插入语言</h3><h4 id="3-1-1-方式一"><a href="#3-1-1-方式一" class="headerlink" title="3.1.1 方式一"></a>3.1.1 方式一</h4><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名（列名，……） value（值1，……）</span><br></pre></td></tr></table></figure><h4 id="3-1-2-方式二"><a href="#3-1-2-方式二" class="headerlink" title="3.1.2 方式二"></a>3.1.2 方式二</h4><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into 表名</span><br><span class="line">set 列名 = 值, 列名 = 值, ...</span><br></pre></td></tr></table></figure><h4 id="3-1-3-两种方式对比"><a href="#3-1-3-两种方式对比" class="headerlink" title="3.1.3 两种方式对比"></a>3.1.3 两种方式对比</h4><p>① 方式一支持插入多行，方式二不支持</p><p>② 方式一支持子查询，方式二不支持</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"># 1.插入的值的类型要与列的类型一致或兼容</span><br><span class="line"></span><br><span class="line">USE girls;</span><br><span class="line">INSERT INTO beauty(id, NAME, sex, borndate, phone, photo, boyfriend_id)</span><br><span class="line">VALUE(13, &#x27;王小虎&#x27;, &#x27;男&#x27;, &#x27;1990-4-23&#x27;, &#x27;18288668899&#x27;, NULL, 2);</span><br><span class="line"></span><br><span class="line">SELECT * FROM beauty;</span><br><span class="line"></span><br><span class="line"># 2.不可以为null的列必须插入值，可以为null的列如何插入值？</span><br><span class="line"># 方式一：null</span><br><span class="line">INSERT INTO beauty (</span><br><span class="line">  id,</span><br><span class="line">  NAME,</span><br><span class="line">  sex,</span><br><span class="line">  borndate,</span><br><span class="line">  phone,</span><br><span class="line">  photo,</span><br><span class="line">  boyfriend_id</span><br><span class="line">) VALUE (</span><br><span class="line">  13,</span><br><span class="line">  &#x27;王小虎&#x27;,</span><br><span class="line">  &#x27;男&#x27;,</span><br><span class="line">  &#x27;1990-4-23&#x27;,</span><br><span class="line">  &#x27;18288668899&#x27;,</span><br><span class="line">  NULL,</span><br><span class="line">  2</span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line"># 方式二：省略</span><br><span class="line">INSERT INTO beauty (</span><br><span class="line">  id,</span><br><span class="line">  NAME,</span><br><span class="line">  sex,</span><br><span class="line">  borndate,</span><br><span class="line">  phone,</span><br><span class="line">  boyfriend_id</span><br><span class="line">) VALUE (</span><br><span class="line">  14,</span><br><span class="line">  &#x27;金星&#x27;,</span><br><span class="line">  &#x27;女&#x27;,</span><br><span class="line">  &#x27;1990-4-23&#x27;,</span><br><span class="line">  &#x27;18288778899&#x27;,</span><br><span class="line">  2</span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line">INSERT INTO beauty (id, NAME, sex, phone) VALUE (15, &#x27;娜扎&#x27;, &#x27;女&#x27;, &#x27;18288770099&#x27;) ;</span><br><span class="line"></span><br><span class="line"># 3.列的顺序能否调换？ # 能，但必须对应</span><br><span class="line">INSERT INTO beauty (NAME, id, sex, phone) VALUE (&#x27;蒋欣&#x27;, 16, &#x27;女&#x27;, &#x27;18266778899&#x27;) ;</span><br><span class="line"></span><br><span class="line"># 4.列数和值的个数必须一致</span><br><span class="line">INSERT INTO beauty (NAME, id, sex, phone) VALUE (&#x27;关晓彤&#x27;, 17, &#x27;女&#x27;, &#x27;18288778899&#x27;) ;</span><br><span class="line"></span><br><span class="line"># 5.可以省略列名，默认所有列，而且列的顺序和表中列的顺序一致</span><br><span class="line">INSERT INTO beauty VALUE (</span><br><span class="line">  18,</span><br><span class="line">  &#x27;张飞&#x27;,</span><br><span class="line">  &#x27;男&#x27;,</span><br><span class="line">  NULL,</span><br><span class="line">  &#x27;110&#x27;,</span><br><span class="line">  NULL,</span><br><span class="line">  NULL</span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line"># 方式二：</span><br><span class="line">/*</span><br><span class="line">语法：</span><br><span class="line">insert into 表名</span><br><span class="line">set 列名 = 值, 列名 = 值, ...</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">INSERT INTO beauty SET id = 19,</span><br><span class="line">NAME = &#x27;刘涛&#x27;,</span><br><span class="line">phone = &#x27;199&#x27; ;</span><br><span class="line"></span><br><span class="line"># 两种方式大pk ★</span><br><span class="line"># 1、方式一支持插入多行,方式二不支持</span><br><span class="line">INSERT INTO beauty </span><br><span class="line">VALUES</span><br><span class="line">  (</span><br><span class="line">    23,</span><br><span class="line">    &#x27;唐艺昕1&#x27;,</span><br><span class="line">    &#x27;女&#x27;,</span><br><span class="line">    &#x27;1990-4-23&#x27;,</span><br><span class="line">    &#x27;1898888888&#x27;,</span><br><span class="line">    NULL,</span><br><span class="line">    2</span><br><span class="line">  ),</span><br><span class="line">  (</span><br><span class="line">    24,</span><br><span class="line">    &#x27;唐艺昕2&#x27;,</span><br><span class="line">    &#x27;女&#x27;,</span><br><span class="line">    &#x27;1990-4-23&#x27;,</span><br><span class="line">    &#x27;1898888888&#x27;,</span><br><span class="line">    NULL,</span><br><span class="line">    2</span><br><span class="line">  ),</span><br><span class="line">  (</span><br><span class="line">    25,</span><br><span class="line">    &#x27;唐艺昕3&#x27;,</span><br><span class="line">    &#x27;女&#x27;,</span><br><span class="line">    &#x27;1990-4-23&#x27;,</span><br><span class="line">    &#x27;1898888888&#x27;,</span><br><span class="line">    NULL,</span><br><span class="line">    2</span><br><span class="line">  ) ;</span><br><span class="line"></span><br><span class="line"># 2、方式一支持子查询，方式二不支持</span><br><span class="line">INSERT INTO beauty (id, NAME, phone) </span><br><span class="line">SELECT </span><br><span class="line">  26,</span><br><span class="line">  &#x27;宋茜&#x27;,</span><br><span class="line">  &#x27;11809866&#x27; ;</span><br><span class="line"></span><br><span class="line">INSERT INTO beauty (id, NAME, phone) </span><br><span class="line">SELECT </span><br><span class="line">  id,</span><br><span class="line">  boyname,</span><br><span class="line">  &#x27;1234567&#x27; </span><br><span class="line">FROM</span><br><span class="line">  boys </span><br><span class="line">WHERE id &lt; 3 ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  beauty ;</span><br></pre></td></tr></table></figure><h3 id="3-2-修改语句"><a href="#3-2-修改语句" class="headerlink" title="3.2 修改语句"></a>3.2 修改语句</h3><h4 id="3-2-1-修改单表的记录★"><a href="#3-2-1-修改单表的记录★" class="headerlink" title="3.2.1 修改单表的记录★"></a>3.2.1 修改单表的记录★</h4><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">update 表名</span><br><span class="line">set 列=新值,列=新值,...</span><br><span class="line">where 筛选条件;</span><br></pre></td></tr></table></figure><h4 id="3-2-2-修改多表的记录【补充】"><a href="#3-2-2-修改多表的记录【补充】" class="headerlink" title="3.2.2 修改多表的记录【补充】"></a>3.2.2 修改多表的记录【补充】</h4><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># sql92语法：</span><br><span class="line">update 表1 别名1,表2 别名2</span><br><span class="line">set 列=值,...</span><br><span class="line">where 连接条件</span><br><span class="line">and 筛选条件;</span><br><span class="line"></span><br><span class="line"># sql99语法：</span><br><span class="line">update 表1 别名1</span><br><span class="line">inner|left|right join 表2 别名2</span><br><span class="line">on 连接条件</span><br><span class="line">set 列=值,...</span><br><span class="line">where 筛选条件;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"># 1.修改单表的记录</span><br><span class="line"># 案例1：修改beauty表中姓唐的女神的电话为13899888899</span><br><span class="line">UPDATE </span><br><span class="line">  beauty </span><br><span class="line">SET</span><br><span class="line">  phone = &#x27;13899888899&#x27; </span><br><span class="line">WHERE NAME LIKE &#x27;唐%&#x27; ;</span><br><span class="line"></span><br><span class="line"># 案例2：修改boys表中id好为2的名称为张飞，魅力值 10</span><br><span class="line">UPDATE </span><br><span class="line">  boys </span><br><span class="line">SET</span><br><span class="line">  boyname = &#x27;张飞&#x27;,</span><br><span class="line">  usercp = 10 </span><br><span class="line">WHERE id = 2 ;</span><br><span class="line"></span><br><span class="line"># 2.修改多表的记录</span><br><span class="line"># 案例 1：修改张无忌的女朋友的手机号为114</span><br><span class="line">UPDATE </span><br><span class="line">  boys bo </span><br><span class="line">  INNER JOIN beauty b </span><br><span class="line">    ON bo.`id` = b.`id` SET b.`phone` = &#x27;120&#x27;,</span><br><span class="line">  bo.`userCP` = 120 </span><br><span class="line">WHERE bo.`boyName` = &#x27;张无忌&#x27; ;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#案例2：修改没有男朋友的女神的男朋友编号都为2号</span><br><span class="line">UPDATE </span><br><span class="line">  boys bo </span><br><span class="line">  RIGHT JOIN beauty b </span><br><span class="line">    ON bo.`id` = b.`boyfriend_id` SET b.`boyfriend_id` = 2 </span><br><span class="line">WHERE bo.`id` IS NULL ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  boys ;</span><br></pre></td></tr></table></figure><h3 id="3-4-删除语句"><a href="#3-4-删除语句" class="headerlink" title="3.4 删除语句"></a>3.4 删除语句</h3><h4 id="3-4-1-方式一：delete"><a href="#3-4-1-方式一：delete" class="headerlink" title="3.4.1 方式一：delete"></a>3.4.1 方式一：delete</h4><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 1 单表的删除【★】</span><br><span class="line">delete from 表名 where 筛选条件</span><br><span class="line"></span><br><span class="line"># 2 多表的删除【补充】</span><br><span class="line"># sql92语法：</span><br><span class="line">delete 表1的别名,表2的别名</span><br><span class="line">from 表1 别名,表2 别名</span><br><span class="line">where 连接条件</span><br><span class="line">and 筛选条件;</span><br><span class="line"></span><br><span class="line"># sql99语法：</span><br><span class="line">delete 表1的别名,表2的别名</span><br><span class="line">from 表1 别名</span><br><span class="line">inner|left|right join 表2 别名 on 连接条件</span><br><span class="line">where 筛选条件;</span><br></pre></td></tr></table></figure><h4 id="3-4-2-方式二：truncate"><a href="#3-4-2-方式二：truncate" class="headerlink" title="3.4.2 方式二：truncate"></a>3.4.2 方式二：truncate</h4><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">truncate table 表名;</span><br></pre></td></tr></table></figure><blockquote><p>delete vs truncate【面试题★】</p><ol><li>delete 可以加where 条件，truncate不能加</li><li>truncate删除，效率高一丢丢</li><li>假如要删除的表中有自增长列，如果<br>用delete删除后，再插入数据，自增长列的值从断点开始，<br>  而truncate删除后，再插入数据，自增长列的值从1开始。</li><li>truncate删除没有返回值，delete删除有返回值</li><li>truncate删除不能回滚，delete删除可以回滚.</li></ol></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"># 方式一：delete</span><br><span class="line"># 1.单表的删除</span><br><span class="line"># 案例1：删除手机号以9结尾的女神信息</span><br><span class="line">DELETE </span><br><span class="line">FROM</span><br><span class="line">  beauty </span><br><span class="line">WHERE phone LIKE &#x27;%9&#x27; ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  beauty ;</span><br><span class="line"></span><br><span class="line"># 2.多表的删除</span><br><span class="line"># 案例1：删除张无忌的女朋友的信息</span><br><span class="line">DELETE </span><br><span class="line">  b </span><br><span class="line">FROM</span><br><span class="line">  beauty b </span><br><span class="line">  INNER JOIN boys bo </span><br><span class="line">    ON b.`boyfriend_id` = bo.`id` </span><br><span class="line">WHERE bo.`boyName` = &#x27;张无忌&#x27; ;</span><br><span class="line"></span><br><span class="line"># 案例2：删除黄晓明的信息以及他女朋友的信息</span><br><span class="line">DELETE </span><br><span class="line">  b,</span><br><span class="line">  bo </span><br><span class="line">FROM</span><br><span class="line">  beauty b </span><br><span class="line">  INNER JOIN boys bo </span><br><span class="line">    ON b.`boyfriend_id` = bo.`id` </span><br><span class="line">WHERE bo.`boyName` = &#x27;黄晓明&#x27; ;</span><br><span class="line"></span><br><span class="line"># 方式二：truncate语句</span><br><span class="line"># 案例：将魅力值&gt;100的男神信息删除</span><br><span class="line">TRUNCATE TABLE boys ;</span><br><span class="line"># 删除整个表</span><br><span class="line"># delete pk truncate【面试题★】</span><br><span class="line">/*</span><br><span class="line">1.delete 可以加where 条件，truncate不能加</span><br><span class="line">2.truncate删除，效率高一丢丢</span><br><span class="line">3.假如要删除的表中有自增长列，</span><br><span class="line">如果用delete删除后，再插入数据，自增长列的值从断点开始，</span><br><span class="line">而truncate删除后，再插入数据，自增长列的值从1开始。</span><br><span class="line">4.truncate删除没有返回值，delete删除有返回值</span><br><span class="line">5.truncate删除不能回滚，delete删除可以回滚.</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  boys ;</span><br><span class="line"></span><br><span class="line">DELETE </span><br><span class="line">FROM</span><br><span class="line">  boys ;</span><br><span class="line"></span><br><span class="line">TRUNCATE TABLE boys ;</span><br><span class="line"></span><br><span class="line">INSERT INTO boys (boyname, usercp) </span><br><span class="line">VALUES</span><br><span class="line">  (&#x27;张飞&#x27;, 100),</span><br><span class="line">  (&#x27;刘备&#x27;, 100),</span><br><span class="line">  (&#x27;关云长&#x27;, 100) ;</span><br></pre></td></tr></table></figure><hr><h2 id="第四章-DDL语言"><a href="#第四章-DDL语言" class="headerlink" title="第四章 DDL语言"></a>第四章 DDL语言</h2><p>DDL（Data Definition Language）：数据定义语言，用来定义数据库对象：库、表、列等</p><h3 id="4-1-库的管理"><a href="#4-1-库的管理" class="headerlink" title="4.1 库的管理"></a>4.1 库的管理</h3><h4 id="4-1-1-库的创建"><a href="#4-1-1-库的创建" class="headerlink" title="4.1.1 库的创建"></a>4.1.1 库的创建</h4><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create database [if not exists] 库名;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 案例：创建库books</span><br><span class="line"></span><br><span class="line">CREATE DATABASE IF NOT EXISTS books ;</span><br></pre></td></tr></table></figure><h4 id="4-1-2-库的修改"><a href="#4-1-2-库的修改" class="headerlink" title="4.1.2 库的修改"></a>4.1.2 库的修改</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RENAME DATABASE books TO 新库名; # 不安全，弃用</span><br><span class="line"></span><br><span class="line"># 更改库的字符集</span><br><span class="line">ALTER DATABASE books </span><br><span class="line">  CHARACTER SET gbk ;</span><br></pre></td></tr></table></figure><h4 id="4-1-3-库的删除"><a href="#4-1-3-库的删除" class="headerlink" title="4.1.3 库的删除"></a>4.1.3 库的删除</h4><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE IF EXISTS 库名 ;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 案例：删除库books</span><br><span class="line">DROP DATABASE IF EXISTS books ;</span><br></pre></td></tr></table></figure><h3 id="4-2-表的管理"><a href="#4-2-表的管理" class="headerlink" title="4.2 表的管理"></a>4.2 表的管理</h3><h4 id="4-2-1-表的创建"><a href="#4-2-1-表的创建" class="headerlink" title="4.2.1 表的创建"></a>4.2.1 表的创建</h4><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">create table 表名(</span><br><span class="line">列名 列的类型【（长度）约束】,</span><br><span class="line">列名 列的类型【（长度）约束】,</span><br><span class="line">列名 列的类型【（长度）约束】,</span><br><span class="line">...</span><br><span class="line">列名 列的类型【（长度）约束】,</span><br><span class="line">) ;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 案例1：创建表book</span><br><span class="line">CREATE TABLE book (</span><br><span class="line">  id INT,</span><br><span class="line">  # 编号</span><br><span class="line">  bName VARCHAR (20),</span><br><span class="line">  # 书名</span><br><span class="line">  price DOUBLE,</span><br><span class="line">  # 价格</span><br><span class="line">  authorId INT,</span><br><span class="line">  # 作者编号</span><br><span class="line">  publishDate DATETIME#出版日期</span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line"># 案例2：创建表author</span><br><span class="line">CREATE TABLE IF NOT EXISTS author (</span><br><span class="line">  id INT,</span><br><span class="line">  au_name VARCHAR (20),</span><br><span class="line">  nation VARCHAR (10)</span><br><span class="line">) ;</span><br></pre></td></tr></table></figure><h4 id="4-2-2-表的修改"><a href="#4-2-2-表的修改" class="headerlink" title="4.2.2 表的修改"></a>4.2.2 表的修改</h4><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter table 表名 add|drop|modify|change column 列名 【列类型 约束】;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># ① 修改列名</span><br><span class="line">ALTER TABLE book </span><br><span class="line">  CHANGE COLUMN publishdate pubDate DATETIME ;</span><br><span class="line"></span><br><span class="line"># ② 修改列的类型或约束</span><br><span class="line">ALTER TABLE book </span><br><span class="line">  MODIFY COLUMN pubdate TIMESTAMP ;</span><br><span class="line"></span><br><span class="line"># ③ 添加新列</span><br><span class="line">ALTER TABLE author </span><br><span class="line">  ADD COLUMN annual DOUBLE ;</span><br><span class="line"></span><br><span class="line"># ④ 删除列</span><br><span class="line">ALTER TABLE author </span><br><span class="line">  DROP COLUMN annual ;</span><br><span class="line"></span><br><span class="line"># ⑤ 修改表名</span><br><span class="line">ALTER TABLE author </span><br><span class="line">  RENAME TO book_author ;</span><br></pre></td></tr></table></figure><h4 id="4-2-3-表的删除"><a href="#4-2-3-表的删除" class="headerlink" title="4.2.3 表的删除"></a>4.2.3 表的删除</h4><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP TABLE 【IF EXISTS】 表名 ; </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 删除表book_author</span><br><span class="line">DROP TABLE IF EXISTS book_author ;</span><br><span class="line"></span><br><span class="line">SHOW TABLES ;</span><br><span class="line"></span><br><span class="line"># 通用的写法：</span><br><span class="line">DROP DATABASE IF EXISTS 旧库名 ;</span><br><span class="line">CREATE DATABASE 新库名;</span><br><span class="line"></span><br><span class="line">DROP TABLE IF EXISTS 旧表名 ;</span><br><span class="line">CREATE TABLE 表名 ;</span><br></pre></td></tr></table></figure><h4 id="4-2-4-表的复制"><a href="#4-2-4-表的复制" class="headerlink" title="4.2.4 表的复制"></a>4.2.4 表的复制</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">INSERT INTO author </span><br><span class="line">VALUES</span><br><span class="line">  (1, &#x27;村上春树&#x27;, &#x27;日本&#x27;),</span><br><span class="line">  (2, &#x27;莫言&#x27;, &#x27;中国&#x27;),</span><br><span class="line">  (3, &#x27;冯唐&#x27;, &#x27;中国&#x27;),</span><br><span class="line">  (4, &#x27;金庸&#x27;, &#x27;中国&#x27;) ;</span><br><span class="line"></span><br><span class="line"># 1、仅仅复制表的结构</span><br><span class="line">CREATE TABLE copy LIKE author;</span><br><span class="line"></span><br><span class="line"># 2、复制表的结构 + 数据</span><br><span class="line">CREATE TABLE copy1 </span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  author ;</span><br><span class="line">  </span><br><span class="line"># 3、只复制部分数据</span><br><span class="line">CREATE TABLE copy2 </span><br><span class="line">SELECT </span><br><span class="line">  id,</span><br><span class="line">  au_name </span><br><span class="line">FROM</span><br><span class="line">  author </span><br><span class="line">WHERE nation = &#x27;中国&#x27; ;</span><br><span class="line"></span><br><span class="line"># 4、仅仅复制某些字段</span><br><span class="line">CREATE TABLE copy3 </span><br><span class="line">SELECT </span><br><span class="line">  id,</span><br><span class="line">  au_name </span><br><span class="line">FROM</span><br><span class="line">  author </span><br><span class="line">WHERE 0;</span><br></pre></td></tr></table></figure><h3 id="4-3-数据类型"><a href="#4-3-数据类型" class="headerlink" title="4.3 数据类型"></a>4.3 数据类型</h3><h4 id="4-3-1-分类"><a href="#4-3-1-分类" class="headerlink" title="4.3.1 分类"></a>4.3.1 分类</h4><p><strong>数值型</strong></p><ul><li>整型</li><li>小数：<ul><li>定点数</li><li>浮点数</li></ul></li></ul><p><strong>字符型</strong></p><ul><li>较短的文本：char、varchar</li><li>较长的文本：text、blob（较长的二进制数据）</li></ul><p><strong>日期型</strong></p><h4 id="4-3-2-整型"><a href="#4-3-2-整型" class="headerlink" title="4.3.2 整型"></a>4.3.2 整型</h4><p><strong>1）分类</strong></p><table><thead><tr><th align="center">tinyint</th><th align="center">smallint</th><th align="center">mediumint</th><th align="center">int&#x2F;integer</th><th align="center">bigint</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">2</td><td align="center">3</td><td align="center">4</td><td align="center">8</td></tr></tbody></table><p><strong>2）特点</strong></p><p>① 如果不设置无符号还是有符号，默认是有符号，如果想设置无符号，需要添加unsigned关键字</p><p>② 如果插入的数值超出了整型的范围，会报out of range异常，并且插入临界值</p><p>③ 如果不设置长度，会有默认的长度；长度代表显示的最大宽度，如果不够会用0在左边填充，但必须搭配zerofill使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 如何设置无符号和有符号</span><br><span class="line">DROP TABLE IF EXISTS tab_int ;</span><br><span class="line"></span><br><span class="line">CREATE TABLE tab_int (</span><br><span class="line">  t1 INT (7) ZEROFILL,</span><br><span class="line">  t2 INT (7) UNSIGNED ZEROFILL</span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line">DESC tab_int ;</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_int </span><br><span class="line">VALUES</span><br><span class="line">  (- 12345, 12345) ;</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_int </span><br><span class="line">VALUES</span><br><span class="line">  (24545444, 12345) ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  tab_int ;</span><br></pre></td></tr></table></figure><h4 id="4-3-3-小数"><a href="#4-3-3-小数" class="headerlink" title="4.3.3 小数"></a>4.3.3 小数</h4><p><strong>1）分类</strong></p><p>① <strong>定点数</strong>：float(M,D)、double(M,D)</p><p>② <strong>浮点数</strong>：dec((M,D)、decimal(M,D)</p><p><strong>2）特点</strong></p><p>① M和D</p><p>M：整数部位 + 小数部位</p><p>D：小数部位</p><p>如果超过范围，则插入临界值</p><p>② M和D都可以省略</p><p>如果是decimal，则M默认为10，D默认为0</p><p>如果是float和double，则会根据插入的数值的精度来决定精度</p><p>③ 定点型的精度较高，如果要求插入数值的精度较高，如货币运算等，则考虑使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># M和D测试</span><br><span class="line">CREATE TABLE tab_float(</span><br><span class="line">f1 FLOAT(5,2),</span><br><span class="line">f2 DOUBLE(5,2),</span><br><span class="line">f3 DECIMAL(5,2)</span><br><span class="line">);</span><br><span class="line">SELECT * FROM tab_float VALUES(123.4, 123.4, 123.4);</span><br><span class="line">SELECT * FROM tab_float VALUES(123.45, 123.45, 123.45);</span><br><span class="line">SELECT * FROM tab_float VALUES(123.456, 123.456, 123.456);</span><br></pre></td></tr></table></figure><h4 id="4-3-4-字符型"><a href="#4-3-4-字符型" class="headerlink" title="4.3.4 字符型"></a>4.3.4 字符型</h4><p><strong>1）分类</strong></p><p>① 较短的文本：char、varchar</p><p>其他：binary 和 varbinary用于保存较短的二进制、enum用于保存枚举、set用于保存集合</p><p>② 较长的文本：text、blob（较大的二进制）</p><p><strong>2）特点</strong></p><table><thead><tr><th></th><th>写法</th><th>M的意思</th><th>特点</th><th>空间的耗费</th><th>效率</th></tr></thead><tbody><tr><td>char</td><td>char(M)</td><td>最大的字符数，可以省略，默认为1</td><td>固定长度的字符</td><td>比较耗费</td><td>高</td></tr><tr><td>varchar</td><td>varchar(M)</td><td>最大的字符数，不可以省略</td><td>可变长度的字符</td><td>比较节省</td><td>低</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tab_char (c1 ENUM (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;)) ;</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_char VALUES(&#x27;a&#x27;);</span><br><span class="line">INSERT INTO tab_char VALUES(&#x27;b&#x27;);</span><br><span class="line">INSERT INTO tab_char VALUES(&#x27;c&#x27;);</span><br><span class="line">INSERT INTO tab_char VALUES(&#x27;m&#x27;);</span><br><span class="line">INSERT INTO tab_char VALUES(&#x27;A&#x27;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM tab_char;</span><br><span class="line"></span><br><span class="line">CREATE TABLE tab_set (s1 SET (&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;)) ;</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_set VALUES(&#x27;a&#x27;);</span><br><span class="line">INSERT INTO tab_set VALUES(&#x27;A,B&#x27;);</span><br><span class="line">INSERT INTO tab_set VALUES(&#x27;a,c,d&#x27;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM tab_set;</span><br></pre></td></tr></table></figure><h4 id="4-3-5-日期型"><a href="#4-3-5-日期型" class="headerlink" title="4.3.5 日期型"></a>4.3.5 日期型</h4><p><strong>1）分类</strong></p><p>① date：只保存日期</p><p>② time：只保存时间</p><p>③ year：只保存年</p><p>④ datetime：保存日期 + 时间</p><p>⑤ timestamp：保存日期 + 时间</p><p><strong>2）特点</strong></p><table><thead><tr><th align="center"></th><th align="center">字节</th><th align="center">范围</th><th align="center">时区等的影响</th></tr></thead><tbody><tr><td align="center">datetime</td><td align="center">8</td><td align="center">1000——9999</td><td align="center">不受</td></tr><tr><td align="center">timestamp</td><td align="center">4</td><td align="center">1970-2038</td><td align="center">受</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE tab_date (t1 DATETIME, t2 TIMESTAMP) ;</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_date VALUES(NOW(),NOW());</span><br><span class="line"></span><br><span class="line">SELECT * FROM tab_date;</span><br><span class="line"></span><br><span class="line">SHOW VARIABLES LIKE &#x27;time_zone&#x27;;</span><br><span class="line"></span><br><span class="line">SET time_zone=&#x27;+9:00&#x27;;</span><br></pre></td></tr></table></figure><h3 id="4-4-约束"><a href="#4-4-约束" class="headerlink" title="4.4 约束"></a>4.4 约束</h3><h4 id="4-4-1-含义"><a href="#4-4-1-含义" class="headerlink" title="4.4.1 含义"></a>4.4.1 含义</h4><p>一种限制，用于限制表中的数据，为了保证表中的数据的准确和可靠性</p><h4 id="4-4-2-分类"><a href="#4-4-2-分类" class="headerlink" title="4.4.2 分类"></a>4.4.2 分类</h4><p>六大约束：</p><p><strong>1）NOT NULL</strong></p><p>非空，用于保证该字段的值不能为空；比如：姓名、学号等</p><p><strong>2）DEFAULT</strong></p><p>默认，用于保证该字段有默认值；比如：性别</p><p><strong>3）PRIMARY KEY</strong></p><p>主键，用于保证该字段的值具有唯一性，并且非空；比如：学号、员工编号等</p><p><strong>4）UNIQUE</strong></p><p>唯一，用于保证该字段的值具有唯一性，可以为空；比如：座位号</p><p><strong>5）CHECK</strong></p><p>检查约束【mysql中不支持】；比如：年龄、性别</p><p><strong>6）FOREIGN KEY</strong></p><p>外键，用于限制两个表的关系，用于保证该字段的值必须来自于主表的关联列的值；在从表添加外键约束，用于引用主表中某列的值；比如：学生表的专业编号，员工表的部门编号，员工表的工种编号</p><h4 id="4-4-3-约束的添加分类"><a href="#4-4-3-约束的添加分类" class="headerlink" title="4.4.3 约束的添加分类"></a>4.4.3 约束的添加分类</h4><p><strong>1）列级约束</strong></p><p>六大约束语法上都支持，但外键约束没有效果    </p><p><strong>2）表级约束</strong></p><p>除了非空、默认，其他的都支持    </p><p><strong>添加约束的时机</strong>：① 创建表时；② 修改表时</p><p>主键和唯一的大对比：</p><table><thead><tr><th align="center"></th><th align="center">保证唯一性</th><th align="center">是否允许为空</th><th align="center">一个表中可以有多少个</th><th align="center">是否允许组合</th></tr></thead><tbody><tr><td align="center">主键</td><td align="center">√</td><td align="center">×</td><td align="center">至多有1个</td><td align="center">√，但不推荐</td></tr><tr><td align="center">唯一</td><td align="center">√</td><td align="center">√</td><td align="center">可以有多个</td><td align="center">√，但不推荐</td></tr></tbody></table><p><strong>外键</strong></p><p>① 从表设置外键关系</p><p>② 外键列的类型和主表的关联列的类型要求一致或兼容，名称无要求</p><p>③ 关联列必须是一个key（一般是主键或唯一）</p><p>④ 插入数据时，先插入主表，再插入从表；删除数据时，先删除从表，再删除主表</p><h4 id="4-4-4-语法"><a href="#4-4-4-语法" class="headerlink" title="4.4.4 语法"></a>4.4.4 语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE 表名(</span><br><span class="line">字段名 字段类型 列级约束,</span><br><span class="line">字段名 字段类型,</span><br><span class="line">表级约束</span><br><span class="line"></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><strong>1）创建表时添加约束</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE students ;</span><br><span class="line"></span><br><span class="line"># 一、创建表时添加约束</span><br><span class="line"># 1.添加列级约束</span><br><span class="line">/*</span><br><span class="line">语法：</span><br><span class="line"></span><br><span class="line">直接在字段名和类型后面追加 约束类型 即可。</span><br><span class="line"></span><br><span class="line">只支持：默认、非空、主键、唯一</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">USE students ;</span><br><span class="line"></span><br><span class="line">CREATE TABLE stuinfo (</span><br><span class="line">  id INT PRIMARY KEY,</span><br><span class="line">  # 主键</span><br><span class="line">  stuName VARCHAR (20) NOT NULL,</span><br><span class="line">  # 非空</span><br><span class="line">  gender CHAR(1) CHECK (gender = &#x27;男&#x27; </span><br><span class="line">    OR gender = &#x27;女&#x27;),</span><br><span class="line">  # 检查</span><br><span class="line">  seat INT UNIQUE,</span><br><span class="line">  # 唯一</span><br><span class="line">  age INT DEFAULT 18,</span><br><span class="line">  # 默认约束</span><br><span class="line">  majorId INT REFERENCES major (id) # 外键</span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line">CREATE TABLE major (</span><br><span class="line">  id INT PRIMARY KEY,</span><br><span class="line">  majorName VARCHAR (20)</span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line">DESC stuinfo ;</span><br><span class="line"># 查看stuinfo表中所有的索引，包括主键、外键、唯一</span><br><span class="line">SHOW INDEX FROM stuinfo ;</span><br><span class="line"></span><br><span class="line"># 2.添加表级约束</span><br><span class="line">/*</span><br><span class="line">语法：在各个字段的最下面</span><br><span class="line"> 【constraint 约束名】 约束类型(字段名) </span><br><span class="line"> </span><br><span class="line">*/</span><br><span class="line">DROP TABLE IF EXISTS stuinfo ;</span><br><span class="line"></span><br><span class="line">CREATE TABLE stuinfo (</span><br><span class="line">  id INT,</span><br><span class="line">  stuname VARCHAR (20),</span><br><span class="line">  gender CHAR(1),</span><br><span class="line">  seat INT,</span><br><span class="line">  age INT,</span><br><span class="line">  majorid INT,</span><br><span class="line">  CONSTRAINT pk PRIMARY KEY (id),</span><br><span class="line">  #主键</span><br><span class="line">  CONSTRAINT uq UNIQUE (seat),</span><br><span class="line">  #唯一键</span><br><span class="line">  CONSTRAINT ck CHECK (gender = &#x27;男&#x27; </span><br><span class="line">    OR gender = &#x27;女&#x27;),</span><br><span class="line">  #检查</span><br><span class="line">  CONSTRAINT fk_stuinfo_major FOREIGN KEY (majorid) REFERENCES major (id) #外键</span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line">SHOW INDEX FROM stuinfo ;</span><br><span class="line"></span><br><span class="line"># 通用的写法：★</span><br><span class="line">CREATE TABLE IF NOT EXISTS stuinfo (</span><br><span class="line">  id INT PRIMARY KEY,</span><br><span class="line">  stuname VARCHAR (20),</span><br><span class="line">  sex CHAR(1),</span><br><span class="line">  age INT DEFAULT 18,</span><br><span class="line">  seat INT UNIQUE,</span><br><span class="line">  majorid INT,</span><br><span class="line">  CONSTRAINT fk_stuinfo_major FOREIGN KEY (majorid) REFERENCES major (id)</span><br><span class="line">) ;</span><br></pre></td></tr></table></figure><p><strong>2）修改表时添加约束</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"># 二、修改表时添加约束</span><br><span class="line">/*</span><br><span class="line">1、添加列级约束</span><br><span class="line">alter table 表名 modify column 字段名 字段类型 新约束;</span><br><span class="line"></span><br><span class="line">2、添加表级约束</span><br><span class="line">alter table 表名 add 【constraint 约束名】 约束类型(字段名) 【外键的引用】;</span><br><span class="line"></span><br><span class="line">*/</span><br><span class="line">DROP TABLE IF EXISTS stuinfo ;</span><br><span class="line"></span><br><span class="line">CREATE TABLE stuinfo (</span><br><span class="line">  id INT,</span><br><span class="line">  stuname VARCHAR (20),</span><br><span class="line">  gender CHAR(1),</span><br><span class="line">  seat INT,</span><br><span class="line">  age INT,</span><br><span class="line">  majorid INT</span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line">DESC stuinfo ;</span><br><span class="line"></span><br><span class="line"># 1.添加非空约束</span><br><span class="line">ALTER TABLE stuinfo </span><br><span class="line">  MODIFY COLUMN stuname VARCHAR (20) NOT NULL ;</span><br><span class="line"></span><br><span class="line">#2.添加默认约束</span><br><span class="line">ALTER TABLE stuinfo </span><br><span class="line">  MODIFY COLUMN age INT DEFAULT 18 ;</span><br><span class="line"></span><br><span class="line"># 3.添加主键</span><br><span class="line"># ①列级约束</span><br><span class="line">ALTER TABLE stuinfo </span><br><span class="line">  MODIFY COLUMN id INT PRIMARY KEY ;</span><br><span class="line"></span><br><span class="line"># ②表级约束</span><br><span class="line">ALTER TABLE stuinfo </span><br><span class="line">  ADD PRIMARY KEY (id) ;</span><br><span class="line"></span><br><span class="line"># 4.添加唯一</span><br><span class="line"># ①列级约束</span><br><span class="line">ALTER TABLE stuinfo </span><br><span class="line">  MODIFY COLUMN seat INT UNIQUE ;</span><br><span class="line"></span><br><span class="line"># ②表级约束</span><br><span class="line">ALTER TABLE stuinfo </span><br><span class="line">  ADD UNIQUE (seat) ;</span><br><span class="line"></span><br><span class="line"># 5.添加外键</span><br><span class="line">ALTER TABLE stuinfo </span><br><span class="line">  ADD CONSTRAINT fk_stuinfo_major FOREIGN KEY (majorid) REFERENCES major (id) ;</span><br></pre></td></tr></table></figure><p><strong>3）修改表时删除约束</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 三、修改表时删除约束</span><br><span class="line"># 1.删除非空约束</span><br><span class="line">ALTER TABLE stuinfo </span><br><span class="line">  MODIFY COLUMN stuname VARCHAR (20) NULL ;</span><br><span class="line"></span><br><span class="line"># 2.删除默认约束</span><br><span class="line">ALTER TABLE stuinfo </span><br><span class="line">  MODIFY COLUMN age INT ;</span><br><span class="line"></span><br><span class="line"># 3.删除主键</span><br><span class="line">ALTER TABLE stuinfo </span><br><span class="line">  DROP PRIMARY KEY ;</span><br><span class="line"></span><br><span class="line"># 4.删除唯一</span><br><span class="line">ALTER TABLE stuinfo </span><br><span class="line">  DROP INDEX seat ;</span><br><span class="line"></span><br><span class="line"># 5.删除外键</span><br><span class="line">ALTER TABLE stuinfo </span><br><span class="line">  DROP FOREIGN KEY fk_stuinfo_major ;</span><br><span class="line"></span><br><span class="line">SHOW INDEX FROM stuinfo ;</span><br></pre></td></tr></table></figure><h3 id="4-5-标识列"><a href="#4-5-标识列" class="headerlink" title="4.5 标识列"></a>4.5 标识列</h3><h4 id="4-5-1-含义"><a href="#4-5-1-含义" class="headerlink" title="4.5.1 含义"></a>4.5.1 含义</h4><p>又称为自增长列，可以不用手动的插入值，系统提供默认的序列值</p><p>含义：可以不用手动的插入值，系统提供默认的序列值</p><h4 id="4-5-2-特点"><a href="#4-5-2-特点" class="headerlink" title="4.5.2 特点"></a>4.5.2 特点</h4><p>1）标识列必须和主键搭配吗？不一定，但要求是一个key</p><p>2）一个表可以有几个标识列？至多一个！</p><p>3）标识列的类型只能是数值型</p><p>4）标识列可以通过 <code>SET auto_increment_increment=3;设置步长</code>;可以通过手动插入值，设置起始值</p><h4 id="4-5-3-创建表时设置标识列"><a href="#4-5-3-创建表时设置标识列" class="headerlink" title="4.5.3 创建表时设置标识列"></a>4.5.3 创建表时设置标识列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># 一、创建表时设置标识列</span><br><span class="line">DROP TABLE IF EXISTS tab_identity ;</span><br><span class="line"></span><br><span class="line">CREATE TABLE tab_identity (</span><br><span class="line">  id INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">  NAME VARCHAR(20) </span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line">TRUNCATE TABLE tab_identity ;</span><br><span class="line"></span><br><span class="line">INSERT INTO tab_identity(id,NAME) VALUES(NULL,&#x27;john&#x27;);</span><br><span class="line">INSERT INTO tab_identity(NAME) VALUES(&#x27;lucy&#x27;);</span><br><span class="line"></span><br><span class="line">SELECT * FROM tab_identity;</span><br><span class="line"></span><br><span class="line">SHOW VARIABLES LIKE &#x27;%auto_increment%&#x27; ;</span><br><span class="line"></span><br><span class="line">SET auto_increment_increment = 3 ;</span><br></pre></td></tr></table></figure><h4 id="4-5-4-修改表时设置标识列"><a href="#4-5-4-修改表时设置标识列" class="headerlink" title="4.5.4 修改表时设置标识列"></a>4.5.4 修改表时设置标识列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 二、修改表时设置标识列</span><br><span class="line">ALTER TABLE tab_identity </span><br><span class="line">  MODIFY COLUMN id INT PRIMARY KEY AUTO_INCREMENT ;</span><br></pre></td></tr></table></figure><h4 id="4-5-5-修改表时删除标识列"><a href="#4-5-5-修改表时删除标识列" class="headerlink" title="4.5.5 修改表时删除标识列"></a>4.5.5 修改表时删除标识列</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 三、修改表时删除标识列</span><br><span class="line">ALTER TABLE tab_identity </span><br><span class="line">  MODIFY COLUMN id INT ;</span><br></pre></td></tr></table></figure><hr><h2 id="第五章-TCL语言"><a href="#第五章-TCL语言" class="headerlink" title="第五章 TCL语言"></a>第五章 TCL语言</h2><p>TCL（Transmission Control Language）：事务控制语言</p><h3 id="5-1-事务"><a href="#5-1-事务" class="headerlink" title="5.1 事务"></a>5.1 事务</h3><h4 id="5-1-1-概念"><a href="#5-1-1-概念" class="headerlink" title="5.1.1 概念"></a>5.1.1 概念</h4><p>一个或一组sql语句组成一个执行单元，这个执行单元要么全部执行，要么全部不执行。</p><h4 id="5-1-2特性"><a href="#5-1-2特性" class="headerlink" title="5.1.2特性"></a>5.1.2特性</h4><p><code>ACID</code><br>原子性（Atomicity）：一个事务不可再分割，要么都执行要么都不执行<br>一致性（Consistency）：一个事务执行会使数据从一个一致状态切换到另外一个一致状态<br>隔离性（Isolation）：一个事务的执行不受其他事务的干扰<br>持久性（Durability）：一个事务一旦提交，则会永久的改变数据库的数据.</p><h4 id="5-1-3-分类"><a href="#5-1-3-分类" class="headerlink" title="5.1.3 分类"></a>5.1.3 分类</h4><p><strong>隐式事务</strong>：事务没有明显的开启和结束的标记<br>比如：insert、update、delete语句</p><p><strong>显式事务</strong>：事务具有明显的开启和结束的标记<br>前提：必须先设置自动提交功能为禁用</p><h3 id="5-2-事务的创建"><a href="#5-2-事务的创建" class="headerlink" title="5.2 事务的创建"></a>5.2 事务的创建</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 步骤1：开启事务</span><br><span class="line">SET autocommit = 0;</span><br><span class="line">START TRANSACTION; # 可选的</span><br><span class="line"># 步骤2：编写事务中的sql语句（select insert update delete）</span><br><span class="line">语句1;</span><br><span class="line">语句2;</span><br><span class="line">...</span><br><span class="line"># 步骤3：结束事务</span><br><span class="line">COMMIT; # 提交事务</span><br><span class="line">ROLLBACK; # 回滚事务</span><br><span class="line">SAVEPOINT 节点名; # 设置保存点</span><br></pre></td></tr></table></figure><h3 id="5-3-并发事务"><a href="#5-3-并发事务" class="headerlink" title="5.3 并发事务"></a>5.3 并发事务</h3><p>1 事务的并发问题是如何发生的？</p><p>多个事务<strong>同时</strong>操作<strong>同一个</strong>数据库的相同数据时</p><p>2 并发问题都有哪些？</p><p><strong>脏读</strong>：一个事务读取了其他事务还没有提交的数据，读到的是其他事务“更新”的数据</p><p><strong>不可重复读</strong>：一个事务多次读取，结果不一样</p><p><strong>幻读</strong>：一个事务读取了其他事务还没有提交的数据，只是读到的是 其他事务“插入”的数据</p><p>3 如何解决并发问题？</p><p>通过设置<strong>隔离级别</strong>来解决</p><table><thead><tr><th align="center">事务的隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">read uncommitted</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">read committed</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">repeatable read</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">serializable</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><blockquote><p><strong>mysql</strong>中默认第三个隔离级别 repeatable read<br><strong>oracle</strong>中默认第二个隔离级别 read committed</p></blockquote><p><strong>查看隔离级别</strong>：<code>select @@tx_isolation;</code></p><p><strong>设置隔离级别</strong>：<code>set session|global transaction isolation level 隔离级别;</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">SHOW ENGINES ; # 查看数据库引擎</span><br><span class="line"></span><br><span class="line">SHOW VARIABLES LIKE &#x27;autocommit&#x27; ;</span><br><span class="line"></span><br><span class="line">USE test;</span><br><span class="line">CREATE TABLE account (</span><br><span class="line">  id INT PRIMARY KEY,</span><br><span class="line">  username VARCHAR (20),</span><br><span class="line">  balance DOUBLE</span><br><span class="line">) ;</span><br><span class="line"></span><br><span class="line">INSERT INTO account VALUE (1, &#x27;张无忌&#x27;, 1000),</span><br><span class="line">(2, &#x27;赵敏&#x27;, 1000) ;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 演示事务的使用步骤</span><br><span class="line"># 1 开启事务</span><br><span class="line">SET autocommit=0;</span><br><span class="line">START TRANSACTION;</span><br><span class="line"></span><br><span class="line"># 2 编写一组事务的语句</span><br><span class="line">UPDATE account SET balance = 1000 WHERE username=&#x27;张无忌&#x27;;</span><br><span class="line">UPDATE account SET balance = 1000 WHERE username=&#x27;赵敏&#x27;;</span><br><span class="line"></span><br><span class="line"># 3 结束事务</span><br><span class="line">ROLLBACK;</span><br><span class="line"># commit;</span><br><span class="line"></span><br><span class="line">SELECT * FROM account;</span><br></pre></td></tr></table></figure><p><strong>演示事务对于<code>delete</code>和<code>truncate</code>的处理的区别</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 演示delete--还原，和原来一样</span><br><span class="line">SET autocommit=0;</span><br><span class="line">START TRANSACTION ;</span><br><span class="line">DELETE FROM account;</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 演示truncate--数据删除，只剩表格</span><br><span class="line">SET autocommit=0;</span><br><span class="line">START TRANSACTION ;</span><br><span class="line">TRUNCATE TABLE account;</span><br><span class="line">ROLLBACK;</span><br></pre></td></tr></table></figure><p><strong>演示<code>savepoint</code>的使用</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 演示savepoint 的使用</span><br><span class="line">SET autocommit=0;</span><br><span class="line">START TRANSACTION;</span><br><span class="line">DELETE FROM account WHERE id=25;</span><br><span class="line">SAVEPOINT a;# 设置保存点</span><br><span class="line">DELETE FROM account WHERE id=28;</span><br><span class="line">ROLLBACK TO a;# 回滚到保存点</span><br><span class="line"></span><br><span class="line">SELECT * FROM account</span><br></pre></td></tr></table></figure><hr><h2 id="第六章-其他"><a href="#第六章-其他" class="headerlink" title="第六章 其他"></a>第六章 其他</h2><p>视图、变量、存储过程、函数、流程控制过程</p><h3 id="6-1-视图"><a href="#6-1-视图" class="headerlink" title="6.1 视图"></a>6.1 视图</h3><p><strong>含义</strong>：虚拟表，和普通表一样使用</p><blockquote><p>mysql5.1版本出现的新特性，是通过表动态生成的数据</p></blockquote><table><thead><tr><th></th><th>创建语法的关键字</th><th>是否实际占用物理空间</th><th>使用</th></tr></thead><tbody><tr><td>视图</td><td>create view</td><td>只是保存了sql逻辑</td><td>增删改查，只是一般不能增删改</td></tr><tr><td>表</td><td>create table</td><td>保存了数据</td><td>增删改查</td></tr></tbody></table><h4 id="6-1-1-创建视图"><a href="#6-1-1-创建视图" class="headerlink" title="6.1.1 创建视图"></a>6.1.1 创建视图</h4><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW 视图名 AS</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">USE myemployees;</span><br><span class="line"></span><br><span class="line"># 1.查询姓名中包含a字符的员工名、部门名和工种信息</span><br><span class="line"># ① 创建</span><br><span class="line">CREATE VIEW myv1 AS </span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  department_name,</span><br><span class="line">  job_title </span><br><span class="line">FROM</span><br><span class="line">  employees e </span><br><span class="line">  JOIN departments d </span><br><span class="line">    ON e.department_id = d.department_id </span><br><span class="line">  JOIN jobs j </span><br><span class="line">    ON j.job_id = e.job_id ;</span><br><span class="line"></span><br><span class="line"># ② 使用</span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  myv1 </span><br><span class="line">WHERE last_name LIKE &#x27;%a%&#x27; ;</span><br><span class="line"></span><br><span class="line"># 2.查询各部门的平均工资级别</span><br><span class="line"># ① 创建视图查看每个部门的平均工资</span><br><span class="line">CREATE VIEW myv2 AS </span><br><span class="line">SELECT </span><br><span class="line">  AVG(salary) ag,</span><br><span class="line">  department_id </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">GROUP BY department_id ;</span><br><span class="line"></span><br><span class="line"># ② 使用</span><br><span class="line">SELECT </span><br><span class="line">  myv2.`ag`,</span><br><span class="line">  g.grade_level </span><br><span class="line">FROM</span><br><span class="line">  myv2 </span><br><span class="line">  JOIN job_grades g </span><br><span class="line">    ON myv2.`ag` BETWEEN g.`lowest_sal` </span><br><span class="line">    AND g.`highest_sal` ;</span><br><span class="line"></span><br><span class="line"># 3.查询平均工资最低的部门信息</span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  myv2 </span><br><span class="line">ORDER BY ag </span><br><span class="line">LIMIT 1 ;</span><br><span class="line"></span><br><span class="line">#4.查询平均工资最低的部门名和工资</span><br><span class="line">CREATE VIEW myv3 AS </span><br><span class="line">SELECT </span><br><span class="line">  * </span><br><span class="line">FROM</span><br><span class="line">  myv2 </span><br><span class="line">ORDER BY ag </span><br><span class="line">LIMIT 1 ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  d.*,</span><br><span class="line">  m.ag </span><br><span class="line">FROM</span><br><span class="line">  myv3 m </span><br><span class="line">  JOIN departments d </span><br><span class="line">    ON m.`department_id` = d.`department_id` ;</span><br></pre></td></tr></table></figure><h4 id="6-1-2-视图的修改"><a href="#6-1-2-视图的修改" class="headerlink" title="6.1.2 视图的修改"></a>6.1.2 视图的修改</h4><p><strong>1）方式一</strong></p><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW  视图名 AS</span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv3 AS </span><br><span class="line">SELECT </span><br><span class="line">  AVG(salary),</span><br><span class="line">  job_id </span><br><span class="line">FROM</span><br><span class="line">  employees </span><br><span class="line">GROUP BY job_id ;</span><br></pre></td></tr></table></figure><p><strong>2）方式二</strong></p><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ALTER VIEW 视图名 AS </span><br><span class="line">查询语句;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ALTER VIEW myv3 </span><br><span class="line">  AS </span><br><span class="line">  SELECT </span><br><span class="line">    * </span><br><span class="line">  FROM</span><br><span class="line">    employees ;</span><br></pre></td></tr></table></figure><h4 id="6-1-3-删除视图"><a href="#6-1-3-删除视图" class="headerlink" title="6.1.3 删除视图"></a>6.1.3 删除视图</h4><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW 视图名,视图名,...;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW emp_v1,</span><br><span class="line">emp_v2,</span><br><span class="line">myv3 ;</span><br></pre></td></tr></table></figure><h4 id="6-1-4-查看视图"><a href="#6-1-4-查看视图" class="headerlink" title="6.1.4 查看视图"></a>6.1.4 查看视图</h4><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DESC 视图名 ;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE VIEW myv3 ;</span><br></pre></td></tr></table></figure><h4 id="6-1-5-视图的更新"><a href="#6-1-5-视图的更新" class="headerlink" title="6.1.5 视图的更新"></a>6.1.5 视图的更新</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">CREATE OR REPLACE VIEW myv1 AS </span><br><span class="line">SELECT </span><br><span class="line">  last_name,</span><br><span class="line">  email </span><br><span class="line">FROM</span><br><span class="line">  employees ;</span><br><span class="line"></span><br><span class="line"># 1.插入</span><br><span class="line">INSERT INTO myv1 </span><br><span class="line">VALUES</span><br><span class="line">  (&#x27;张飞&#x27;, &#x27;zf@qq.com&#x27;) ;</span><br><span class="line"></span><br><span class="line"># 2.修改</span><br><span class="line">UPDATE </span><br><span class="line">  myv1 </span><br><span class="line">SET</span><br><span class="line">  last_name = &#x27;张无忌&#x27; </span><br><span class="line">WHERE last_name = &#x27;张飞&#x27; ;</span><br><span class="line"></span><br><span class="line"># 3.删除</span><br><span class="line">DELETE </span><br><span class="line">FROM</span><br><span class="line">  myv1 </span><br><span class="line">WHERE last_name = &#x27;张无忌&#x27; ;</span><br></pre></td></tr></table></figure><blockquote><p>具备以下特点的视图不允许更新</p><p>① 包含以下关键字的sql语句：分组函数、distinct、group  by、having、union或者union all</p><p>② 常量视图</p><p>③ select中包含子查询</p><p>④ join（不能插入）</p><p>⑤ from一个不能更新的视图</p><p>⑥ where子句的子查询引用了from子句中的表</p></blockquote><h3 id="6-2-变量"><a href="#6-2-变量" class="headerlink" title="6.2 变量"></a>6.2 变量</h3><h4 id="6-2-1-分类"><a href="#6-2-1-分类" class="headerlink" title="6.2.1 分类"></a>6.2.1 分类</h4><table><thead><tr><th align="center">系统变量</th><th align="center">自定义变量</th></tr></thead><tbody><tr><td align="center">全局变量</td><td align="center">用户变量</td></tr><tr><td align="center">会话变量</td><td align="center">局部变量</td></tr></tbody></table><h4 id="6-2-2-系统变量"><a href="#6-2-2-系统变量" class="headerlink" title="6.2.2 系统变量"></a>6.2.2 系统变量</h4><p><strong>说明</strong></p><p>变量有系统提供，不是用户定义，属于服务器层面</p><p><strong>语法</strong></p><p><strong>1）查看所有的系统变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global|【session】 variables;</span><br></pre></td></tr></table></figure><p><strong>2）查看满足条件的部分系统变量</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">show global|【session】 variables like &#x27;%char%&#x27;;</span><br></pre></td></tr></table></figure><p><strong>3）查看指定的系统变量的值</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select @@global|【session】.系统变量名;</span><br></pre></td></tr></table></figure><p><strong>4）为某个系统变量赋值</strong><br><strong>方式一</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set global|【session】系统变量名 = 值;</span><br></pre></td></tr></table></figure><p><strong>方式二</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set @@global|【session】系统变量名 = 值;</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意</strong></p><p>如果是全局级别，则需要加global，如果是会话级别，则需要加session，如果不写，则默认session</p></blockquote><p><strong>1）全局变量</strong></p><p><strong>作用域</strong>：服务器每次启动将为所有的全局变量赋初始值，针对于所有会话（连接）有效，但不能跨重启</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># ① 查看所有全局变量</span><br><span class="line">SHOW GLOBAL VARIABLES ;</span><br><span class="line"></span><br><span class="line"># ② 查看满足条件的部分系统变量</span><br><span class="line">SHOW GLOBAL VARIABLES LIKE &#x27;%char%&#x27; ;</span><br><span class="line"></span><br><span class="line"># ③ 查看指定的系统变量的值</span><br><span class="line">SELECT </span><br><span class="line">  @@global.autocommit ;</span><br><span class="line"></span><br><span class="line"># ④ 为某个系统变量赋值</span><br><span class="line">SET @@global.autocommit = 0 ;</span><br><span class="line"></span><br><span class="line">SET GLOBAL autocommit = 0 ;</span><br></pre></td></tr></table></figure><p><strong>2）会话变量</strong></p><p><strong>作用域</strong>：针对于当前会话（连接）有效</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># ① 查看所有会话变量</span><br><span class="line">SHOW SESSION VARIABLES ;</span><br><span class="line"></span><br><span class="line"># ② 查看满足条件的部分会话变量</span><br><span class="line">SHOW SESSION VARIABLES LIKE &#x27;%char%&#x27; ;</span><br><span class="line"></span><br><span class="line"># ③ 查看指定的会话变量的值</span><br><span class="line">SELECT </span><br><span class="line">  @@autocommit ;</span><br><span class="line"></span><br><span class="line">SELECT </span><br><span class="line">  @@session.tx_isolation ;</span><br><span class="line"></span><br><span class="line"># ④ 为某个会话变量赋值</span><br><span class="line"># 方式一：</span><br><span class="line">SET @@session.tx_isolation = &#x27;read-uncommitted&#x27; ;</span><br><span class="line"></span><br><span class="line"># 方式二：</span><br><span class="line">SET SESSION tx_isolation = &#x27;read-committed&#x27; ;</span><br></pre></td></tr></table></figure><h4 id="6-2-3-自定义变量"><a href="#6-2-3-自定义变量" class="headerlink" title="6.2.3 自定义变量"></a>6.2.3 自定义变量</h4><p><strong>说明</strong></p><p>变量由用户自定义，而不是系统提供的</p><p><strong>使用步骤</strong></p><p>声明 → 赋值 → 使用（查看、比较、运算等）</p><p><strong>1）用户变量</strong></p><p><strong>作用域</strong>：针对于当前会话（连接）有效，作用域同于<strong>会话变量</strong>，应用在任何地方，begin end中 或 begin end的外面</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 赋值操作符：=或:=</span><br><span class="line"># ① 声明并初始化</span><br><span class="line">SET @用户变量名 = 值;</span><br><span class="line">SET @用户变量名 := 值;</span><br><span class="line">SELECT @用户变量名 := 值;</span><br><span class="line"></span><br><span class="line"># ② 赋值（更新变量的值）</span><br><span class="line"># 方式一：</span><br><span class="line">SET @用户变量名 = 值;</span><br><span class="line">SET @用户变量名 := 值;</span><br><span class="line">SELECT @用户变量名 := 值;</span><br><span class="line"># 方式二：</span><br><span class="line">SELECT 字段 INTO @变量名</span><br><span class="line">FROM 表;</span><br><span class="line"># ③ 使用（查看变量的值）</span><br><span class="line">SELECT @变量名;</span><br><span class="line"></span><br><span class="line"># 案例</span><br><span class="line"># 1、声明并初始化</span><br><span class="line">SET @name = &#x27;john&#x27;;</span><br><span class="line">SET @name = 100;</span><br><span class="line">SET @account = 1;</span><br><span class="line"></span><br><span class="line"># 2、赋值</span><br><span class="line">SELECT COUNT(*) INTO @count</span><br><span class="line">FROM employees;</span><br><span class="line"></span><br><span class="line"># 3、查看</span><br><span class="line">SELECT @count;</span><br></pre></td></tr></table></figure><p><strong>2）局部变量</strong></p><p><strong>作用域</strong>：仅仅在定义它的begin end块中有效，应用在 begin end中的第一句话</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># ① 声明</span><br><span class="line">DECLARE 变量名 类型;</span><br><span class="line">DECLARE 变量名 类型 DEFAULT 值 ;</span><br><span class="line"></span><br><span class="line"># ② 赋值（更新变量的值）</span><br><span class="line"># 方式一：通过set或select</span><br><span class="line">SET 局部变量名=值;</span><br><span class="line">SET 局部变量名:=值;</span><br><span class="line">SELECT @局部变量名:=值;</span><br><span class="line"># 方式二：通过select into</span><br><span class="line">SELECT 字段 INTO 具备变量名</span><br><span class="line">FROM 表;</span><br><span class="line"># ③ 使用（查看变量的值）</span><br><span class="line">SELECT 局部变量名;</span><br></pre></td></tr></table></figure><p><strong>3）用户变量和局部变量的对比</strong></p><table><thead><tr><th align="center"></th><th align="center">作用域</th><th align="center">定义位置</th><th align="center">语法</th></tr></thead><tbody><tr><td align="center"><strong>用户变量</strong></td><td align="center">当前会话</td><td align="center">会话的任何地方</td><td align="center">加@符号，不用限定类型</td></tr><tr><td align="center"><strong>局部变量</strong></td><td align="center">BEGIN END中</td><td align="center">BEGIN END的第一句话</td><td align="center">一般不用加@,需要限定类型</td></tr></tbody></table><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 案例：声明两个变量，求和并打印</span><br><span class="line"></span><br><span class="line"># 用户变量</span><br><span class="line">SET @m = 1;</span><br><span class="line">SET @n = 2;</span><br><span class="line">SET @sum = @m + @n;</span><br><span class="line">SELECT @sum;</span><br><span class="line"></span><br><span class="line"># 局部变量</span><br><span class="line">DECLARE m INT DEFAULT 1;</span><br><span class="line">DECLARE n INT DEFAULT 2;</span><br><span class="line">DECLARE SUM INT;</span><br><span class="line">SET SUM = m + n;</span><br><span class="line">SELECT SUM;</span><br></pre></td></tr></table></figure><h3 id="6-3-存储过程"><a href="#6-3-存储过程" class="headerlink" title="6.3 存储过程"></a>6.3 存储过程</h3><p><strong>含义</strong></p><p>一组预先编译好的SQL语句的集合，理解成批处理语句</p><p><strong>优点</strong></p><p>1）提高代码的重用性</p><p>2）简化操作</p><p>3）减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p><h4 id="6-3-1-创建语法"><a href="#6-3-1-创建语法" class="headerlink" title="6.3.1 创建语法"></a>6.3.1 创建语法</h4><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名(参数列表)</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">存储过程体（一组合法的SQL语句）</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>1）参数列表包含三部分</p><p><code>参数模式  参数名  参数类型</code></p><p>举例：<code>in stuname varchar(20)</code></p><p><strong>参数模式</strong></p><p><code>in</code>：该参数可以作为输入，也就是该参数需要调用方传入值</p><p><code>out</code>：该参数可以作为输出，也就是该参数可以作为返回值</p><p><code>inout</code>：该参数既可以作为输入又可以作为输出，也就是该参数既需要传入值，又可以返回值</p><p>2）如果存储过程体仅仅只有一句话，begin end可以省略</p><p>存储过程体中的每条sql语句的结尾要求必须加分号</p><p>存储过程的结尾可以使用 <code>delimiter</code> 重新设置</p><p>语法：<code>delimiter 结束标记</code></p><p>举例：<code>delimiter $</code></p><h4 id="6-3-2-调用语法"><a href="#6-3-2-调用语法" class="headerlink" title="6.3.2 调用语法"></a>6.3.2 调用语法</h4><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CALL 存储过程名(实参列表);</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"># 1.空参列表</span><br><span class="line"># 案例：插入到admin表中五条记录</span><br><span class="line">SELECT * FROM admin;</span><br><span class="line"></span><br><span class="line">DELIMITER $</span><br><span class="line">CREATE PROCEDURE myp1 () </span><br><span class="line">BEGIN</span><br><span class="line">  INSERT INTO admin (username, `password`) </span><br><span class="line">  VALUES</span><br><span class="line">    (&#x27;john1&#x27;, &#x27;0000&#x27;),</span><br><span class="line">    (&#x27;lily&#x27;, &#x27;0000&#x27;),</span><br><span class="line">    (&#x27;rose&#x27;, &#x27;0000&#x27;),</span><br><span class="line">    (&#x27;jack&#x27;, &#x27;0000&#x27;),</span><br><span class="line">    (&#x27;tom&#x27;, &#x27;0000&#x27;) ;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line">CALL myp1()$</span><br><span class="line"></span><br><span class="line"># 2.创建带in模式参数的存储过程</span><br><span class="line"># 案例1：创建存储过程实现 根据女神名，查询对应的男神信息</span><br><span class="line">CREATE PROCEDURE myp2 (IN beautyName VARCHAR (20)) </span><br><span class="line">BEGIN</span><br><span class="line">  SELECT </span><br><span class="line">    bo.* </span><br><span class="line">  FROM</span><br><span class="line">    boys bo </span><br><span class="line">    RIGHT JOIN beauty b </span><br><span class="line">      ON bo.id = b.boyfriend_id </span><br><span class="line">  WHERE b.name = beautyName ;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line">CALL myp2(&#x27;王语嫣&#x27;)$</span><br><span class="line">  </span><br><span class="line"># 案例2 ：创建存储过程实现，用户是否登录成功</span><br><span class="line">CREATE PROCEDURE myp3 (</span><br><span class="line">  IN username VARCHAR (20),</span><br><span class="line">  IN PASSWORD VARCHAR (20)</span><br><span class="line">) </span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE result INT DEFAULT 0 ;#声明并初始化</span><br><span class="line">  SELECT </span><br><span class="line">    COUNT(*) INTO result #赋值</span><br><span class="line">  FROM</span><br><span class="line">    admin </span><br><span class="line">  WHERE admin.username = username </span><br><span class="line">    AND admin.password = PASSWORD ;</span><br><span class="line">  SELECT </span><br><span class="line">    IF(result &gt; 0, &#x27;成功&#x27;, &#x27;失败&#x27;) ;#使用</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line">CALL myp3(&#x27;张飞&#x27;,&#x27;8888&#x27;)$</span><br><span class="line"></span><br><span class="line"># 3.创建out 模式参数的存储过程</span><br><span class="line"># 案例1：根据输入的女神名，返回对应的男神名</span><br><span class="line">CREATE PROCEDURE myp4 (</span><br><span class="line">  IN beautyName VARCHAR (20),</span><br><span class="line">  OUT boyName VARCHAR (20)</span><br><span class="line">) </span><br><span class="line">BEGIN</span><br><span class="line">  SELECT </span><br><span class="line">    bo.boyname INTO boyname </span><br><span class="line">  FROM</span><br><span class="line">    boys bo </span><br><span class="line">    RIGHT JOIN beauty b </span><br><span class="line">      ON b.boyfriend_id = bo.id </span><br><span class="line">  WHERE b.name = beautyName ;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line">CALL myp4(&#x27;小昭&#x27;,@name)$</span><br><span class="line">SELECT @name$    </span><br><span class="line">    </span><br><span class="line"># 案例2：根据输入的女神名，返回对应的男神名和魅力值</span><br><span class="line">CREATE PROCEDURE myp5 (</span><br><span class="line">  IN beautyName VARCHAR (20),</span><br><span class="line">  OUT boyName VARCHAR (20),</span><br><span class="line">  OUT usercp INT</span><br><span class="line">) </span><br><span class="line">BEGIN</span><br><span class="line">  SELECT </span><br><span class="line">    boys.boyname,</span><br><span class="line">    boys.usercp INTO boyname,</span><br><span class="line">    usercp </span><br><span class="line">  FROM</span><br><span class="line">    boys </span><br><span class="line">    RIGHT JOIN beauty b </span><br><span class="line">      ON b.boyfriend_id = boys.id </span><br><span class="line">  WHERE b.name = beautyName ;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line">CALL myp5(&#x27;小昭&#x27;,@name,@cp)$</span><br><span class="line">SELECT @name,@cp$    </span><br><span class="line"></span><br><span class="line"># 4.创建带inout模式参数的存储过程</span><br><span class="line"># 案例1：传入a和b两个值，最终a和b都翻倍并返回</span><br><span class="line">CREATE PROCEDURE myp6 (INOUT a INT, INOUT b INT) </span><br><span class="line">BEGIN</span><br><span class="line">  SET a = a * 2 ;</span><br><span class="line">  SET b = b * 2 ;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line"># 调用</span><br><span class="line">SET @m=10$</span><br><span class="line">SET @n=20$</span><br><span class="line">CALL myp6(@m,@n)$</span><br><span class="line">SELECT @m,@n$</span><br></pre></td></tr></table></figure><h4 id="6-3-3-删除语法"><a href="#6-3-3-删除语法" class="headerlink" title="6.3.3 删除语法"></a>6.3.3 删除语法</h4><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">drop procedure 存储过程名</span><br></pre></td></tr></table></figure><blockquote><p>一次只能删除一个</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP PROCEDURE p1 ;</span><br><span class="line">DROP PROCEDURE p2,p3 ; # 错误</span><br></pre></td></tr></table></figure><h4 id="6-3-4-查看存储过程的信息"><a href="#6-3-4-查看存储过程的信息" class="headerlink" title="6.3.4 查看存储过程的信息"></a>6.3.4 查看存储过程的信息</h4><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE 存储过程名 ;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE myp2 ;</span><br><span class="line">DESC myp2 ; # 错误</span><br></pre></td></tr></table></figure><h3 id="6-4-函数"><a href="#6-4-函数" class="headerlink" title="6.4 函数"></a>6.4 函数</h3><p><strong>含义</strong></p><p>一组预先编译好的SQL语句的集合，理解成批处理语句</p><p><strong>优点</strong></p><p>1）提高代码的重用性</p><p>2）简化操作</p><p>3）减少了编译次数并且减少了和数据库服务器的连接次数，提高了效率</p><h4 id="6-4-1-创建语法"><a href="#6-4-1-创建语法" class="headerlink" title="6.4.1 创建语法"></a>6.4.1 创建语法</h4><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE FUNCTION 函数名 (参数列表) RETURNS 返回类型 </span><br><span class="line">BEGIN</span><br><span class="line">  函数体 </span><br><span class="line">END </span><br></pre></td></tr></table></figure><p>注意：<br>1）参数列表包含两部分：<code>参数名 参数类型</code></p><p>2）函数体：肯定会有return语句，如果没有会报错<br>如果return语句没有放在函数体的最后也不报错，但不建议</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return 值;</span><br></pre></td></tr></table></figure><p>3）函数体中仅有一句话，则可以省略begin end</p><p>4）使用 <code>delimiter</code> 语句设置结束标记</p><h4 id="6-4-2-调用语法"><a href="#6-4-2-调用语法" class="headerlink" title="6.4.2 调用语法"></a>6.4.2 调用语法</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT </span><br><span class="line">  函数名 (参数列表) 结束标记`</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"># 1.无参有返回</span><br><span class="line"># 案例：返回公司的员工个数</span><br><span class="line">  CREATE FUNCTION myf1 () RETURNS INT </span><br><span class="line">  BEGIN</span><br><span class="line">    DECLARE c INT DEFAULT 0 ;</span><br><span class="line"></span><br><span class="line"> # 定义局部变量</span><br><span class="line">SELECT COUNT(*) INTO c # 赋值</span><br><span class="line">FROM employees;</span><br><span class="line">RETURN c;</span><br><span class="line"></span><br><span class="line">END $ </span><br><span class="line">SELECT </span><br><span class="line">myf1 () $ </span><br><span class="line"></span><br><span class="line"># 2.有参有返回</span><br><span class="line"># 案例1：根据员工名，返回它的工资</span><br><span class="line"> CREATE FUNCTION myf2 (empName VARCHAR (20)) RETURNS DOUBLE </span><br><span class="line">BEGIN</span><br><span class="line">  SET @sal = 0 ;</span><br><span class="line">  </span><br><span class="line">  #定义用户变量 </span><br><span class="line">SELECT salary INTO @sal   #赋值</span><br><span class="line">FROM employees</span><br><span class="line">WHERE last_name = empName;</span><br><span class="line"></span><br><span class="line">RETURN @sal;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">SELECT myf2(&#x27;k_ing&#x27;) $</span><br><span class="line"></span><br><span class="line"># 案例2：根据部门名，返回该部门的平均工资</span><br><span class="line"></span><br><span class="line">CREATE FUNCTION myf3(deptName VARCHAR(20)) RETURNS DOUBLE</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE sal DOUBLE ;</span><br><span class="line">SELECT </span><br><span class="line">  AVG(salary) INTO sal </span><br><span class="line">FROM</span><br><span class="line">  employees e </span><br><span class="line">  JOIN departments d </span><br><span class="line">    ON e.department_id = d.department_id </span><br><span class="line">WHERE d.department_name = deptName ;</span><br><span class="line"></span><br><span class="line">RETURN sal;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">SELECT myf3(&#x27;IT&#x27;)$</span><br></pre></td></tr></table></figure><h4 id="6-4-3-查看函数"><a href="#6-4-3-查看函数" class="headerlink" title="6.4.3 查看函数"></a>6.4.3 查看函数</h4><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE FUNCTION 函数名</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SHOW CREATE FUNCTION myf3;</span><br></pre></td></tr></table></figure><h4 id="6-4-4-删除函数"><a href="#6-4-4-删除函数" class="headerlink" title="6.4.4 删除函数"></a>6.4.4 删除函数</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP FUNCTION 函数名;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DROP FUNCTION myf3;</span><br></pre></td></tr></table></figure><h4 id="6-4-5-存储过程和函数的区别"><a href="#6-4-5-存储过程和函数的区别" class="headerlink" title="6.4.5 存储过程和函数的区别"></a>6.4.5 存储过程和函数的区别</h4><p><strong>存储过程</strong>：可以有0个返回，也可以有多个返回，适合做<strong>批量插入</strong>、<strong>批量更新</strong><br><strong>函数</strong>：有且仅有1个返回，适合做<strong>处理数据后返回一个结果</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 案例</span><br><span class="line"># 一、创建函数，实现传入两个float，返回二者之和</span><br><span class="line">CREATE FUNCTION test_fun1 (num1 FLOAT, num2 FLOAT) RETURNS FLOAT </span><br><span class="line">BEGIN</span><br><span class="line">  DECLARE SUMFLOAT DEFAULT 0 ;  </span><br><span class="line">  SET SUM = num1 + num2;</span><br><span class="line">RETURN SUM;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">SELECT test_fun1(1,2)$</span><br></pre></td></tr></table></figure><h3 id="6-5-流程控制过程"><a href="#6-5-流程控制过程" class="headerlink" title="6.5 流程控制过程"></a>6.5 流程控制过程</h3><p><strong>分类</strong></p><p><strong>顺序结构</strong>：程序从上往下依次执行</p><p><strong>分支结构</strong>：程序从两条或多条路径中选择一条去执行</p><p><strong>循环结构</strong>：程序在满足一定条件的基础上，重复执行一段代码</p><h4 id="6-5-1-分支结构"><a href="#6-5-1-分支结构" class="headerlink" title="6.5.1 分支结构"></a>6.5.1 分支结构</h4><p><strong>1）if函数</strong></p><p><strong>功能</strong>：实现简单的双分支</p><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if(表达式1,表达式2,表达式3)</span><br></pre></td></tr></table></figure><p><strong>执行顺序</strong>：如果表达式1成立，则if函数返回表达式2的值，否则返回表达式3的值</p><p><strong>应用</strong>：任何地方</p><p><strong>2）if结构</strong></p><p><strong>功能</strong>：实现多重分支</p><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if 条件1 then 语句1;</span><br><span class="line">ifelse 条件2 then 语句2;</span><br><span class="line">...</span><br><span class="line">【else 语句n;】</span><br></pre></td></tr></table></figure><p><strong>应用</strong>：在begin end中</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 案例1：创建函数，实现传入成绩，如果成绩&gt;90,返回A，如果成绩&gt;80,返回B，如果成绩&gt;60,返回C，否则返回D</span><br><span class="line">CREATE FUNCTION test_if (score INT) RETURNS CHAR </span><br><span class="line">BEGIN</span><br><span class="line">DECLARE ch CHAR DEFAULT &#x27;A&#x27; ;</span><br><span class="line"></span><br><span class="line">IF score&gt;90 THEN SET ch=&#x27;A&#x27;;</span><br><span class="line">ELSEIF score&gt;80 THEN SET ch=&#x27;B&#x27;;</span><br><span class="line">ELSEIF score &gt; 60 </span><br><span class="line">THEN SET ch = &#x27;C&#x27; ;</span><br><span class="line">ELSE SET ch=&#x27;D&#x27;;</span><br><span class="line">END IF;</span><br><span class="line">RETURN ch;</span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">SELECT test_if(87)$</span><br></pre></td></tr></table></figure><p><strong>3）case结构</strong></p><p><strong>情况1</strong>：类似于java中的switch语句，一般用于实现等值判断</p><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CASE 变量|表达式|字段</span><br><span class="line">WHEN 要判断的值 THEN 返回的值1 或 语句1;</span><br><span class="line">WHEN 要判断的值 THEN 返回的值2 或 语句2;</span><br><span class="line">...</span><br><span class="line">ELSE 要返回的值n 或 语句n;</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure><p><strong>情况2</strong>：类似于java中的多重if语句，一般用于实现区间判断<br>语法</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CASE </span><br><span class="line">WHEN 要判断的条件1 THEN 返回的值1 或 语句1;</span><br><span class="line">WHEN 要判断的条件2 THEN 返回的值2 或 语句2;</span><br><span class="line">...</span><br><span class="line">ELSE 要返回的值n 或 语句n;</span><br><span class="line">END case;</span><br></pre></td></tr></table></figure><p><strong>特点</strong><br>① 可以作为表达式，嵌套在其他语句中使用，可以放在任何地方，begin end中 或 begin end的外面<br>可以作为独立的语句去使用，只能放在begin end中<br>② 如果when中的值满足 或 条件成立，则执行对应的then后面的语句，并且结束case<br>如果不满足，则执行else中的语句或值<br>③ else可以省略，如果else省略了，并且所有when条件都不满足，则返回null</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 案例： 创建存储过程，根据传入的成绩，来显示等级，比如传入的成绩90-100，显示A，80-90，显示B，60-80，显示C，否则，显示D</span><br><span class="line"></span><br><span class="line">CREATE PROCEDURE test_case(IN score INT)</span><br><span class="line">BEGIN</span><br><span class="line">CASE </span><br><span class="line">WHEN score &gt;= 90 AND score &lt;= 100 THEN SELECT &#x27;A&#x27;;</span><br><span class="line">WHEN score &gt;= 80 THEN SELECT &#x27;B&#x27;;</span><br><span class="line">WHEN score &gt;= 60 THEN SELECT &#x27;C&#x27;;</span><br><span class="line">ELSE SELECT &#x27;D&#x27;;</span><br><span class="line">END CASE</span><br><span class="line">END $ </span><br><span class="line"></span><br><span class="line">CALL test_case (95) $ </span><br></pre></td></tr></table></figure><h4 id="6-5-2-循环结构"><a href="#6-5-2-循环结构" class="headerlink" title="6.5.2 循环结构"></a>6.5.2 循环结构</h4><p><strong>分类</strong>：while、loop、repeat</p><p><strong>循环控制</strong>：<br><code>iterate</code>： 类似于 continue，继续，结束本次循环，继续下一次<br><code>leave</code>：类似于 break，跳出，结束当前所在的循环</p><p><strong>1）while</strong></p><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【标签:】WHILE 循环条件 DO</span><br><span class="line">循环体;</span><br><span class="line">END WHILE【 标签】;</span><br></pre></td></tr></table></figure><p><strong>2）loop</strong></p><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">【标签:】LOOP</span><br><span class="line">循环体;</span><br><span class="line">END LOOP 【标签】;</span><br></pre></td></tr></table></figure><blockquote><p>可以用来模拟简单的死循环</p></blockquote><p><strong>3）repeat</strong></p><p><strong>语法</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">【标签：】REPEAT</span><br><span class="line">循环体;</span><br><span class="line">UNTIL 结束循环的条件</span><br><span class="line">END REPEAT 【标签】;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"># 没有添加循环控制语句</span><br><span class="line"># 案例：批量插入，根据次数到admin表中多条记录</span><br><span class="line">CREATE PROCEDURE pro_while1(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line"></span><br><span class="line">DECLARE i INT DEFAULT 1;</span><br><span class="line">WHILE i &lt;= insertCount DO</span><br><span class="line">INSERT INTO admin(username, `password`) VALUES(CONCAT(&#x27;Rose&#x27;,i), &#x27;666&#x27;);</span><br><span class="line">SET i = i + 1;</span><br><span class="line">END WHILE;</span><br><span class="line"></span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">CALL pro_while1(100) $</span><br><span class="line"></span><br><span class="line"># 2、添加leave语句</span><br><span class="line"># 案例：批量插入，根据次数插入到admin表中多条记录，如果次数 &gt; 20则停止</span><br><span class="line">TRUNCATE TABLE admin$</span><br><span class="line">DROP PROCEDURE test_while2 $</span><br><span class="line">CREATE PROCEDURE test_while2(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 1;</span><br><span class="line">a:WHILE i &lt;= insertCount DO</span><br><span class="line">INSERT INTO admin(username, `password`) VALUES(CONCAT(&#x27;xiaonhau&#x27;,i), &#x27;0000&#x27;);</span><br><span class="line">IF i &gt; 20 THEN LEAVE a;</span><br><span class="line">END IF;</span><br><span class="line">SET i = i + 1;</span><br><span class="line">END WHILE a;</span><br><span class="line"></span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">CALL test_while2(100)$</span><br><span class="line"></span><br><span class="line"># 3、添加iterate语句</span><br><span class="line"># 案例：批量插入，根据次数插入到admin表中多条记录，直插入偶数次</span><br><span class="line">TRUNCATE TABLE admin$</span><br><span class="line">DROP PROCEDURE test_while2 $</span><br><span class="line">CREATE PROCEDURE test_while3(IN insertCount INT)</span><br><span class="line">BEGIN</span><br><span class="line">DECLARE i INT DEFAULT 0;</span><br><span class="line">a:WHILE i &lt;= insertCount DO</span><br><span class="line">SET i = i + 1;</span><br><span class="line">IF MOD(i, 2) != 0 THEN ITERATE a;</span><br><span class="line">END IF;</span><br><span class="line">INSERT INTO admin(username, `password`) VALUES(CONCAT(&#x27;xiaohua&#x27;,i), &#x27;0000&#x27;);</span><br><span class="line">END WHILE a;</span><br><span class="line"></span><br><span class="line">END $</span><br><span class="line"></span><br><span class="line">CALL test_while3(100)$</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一章-MySQL概述&quot;&gt;&lt;a href=&quot;#第一章-MySQL概述&quot; class=&quot;headerlink&quot; title=&quot;第一章 MySQL概述&quot;&gt;&lt;/a&gt;第一章 MySQL概述&lt;/h2&gt;&lt;p&gt;MySQL是一个&lt;strong&gt;关系型数据库管理系统&lt;/strong</summary>
      
    
    
    
    <category term="笔记" scheme="https://actionding.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="数据库" scheme="https://actionding.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Java 笔记</title>
    <link href="https://actionding.github.io/2020/08/Java%20%E7%AC%94%E8%AE%B0/"/>
    <id>https://actionding.github.io/2020/08/Java%20%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-04T19:02:00.000Z</published>
    <updated>2021-02-18T02:59:28.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/.io//image%5CJava%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.png" alt="image-20210202171943966"></p><ul><li><p>编程语言核心结构：变量、基本语法、分支、循环、数组等</p></li><li><p>Java 面向对象的核心逻辑：OOP、封装、继承、多态、接口等</p></li><li><p>开发Java SE 高级应用程序：异常、集合、I&#x2F;O、多线程、反射机制、网络编程等</p></li><li><p>实训项目</p><blockquote><p>项目一：讲完流程控制时，可以做。</p><p>项目二：讲完面向对象（上），可以做</p><p>项目三：讲完异常处理以后，可以做</p><p>附加项目一：讲完异常处理以后，可以做</p><p>附加项目二：讲完IO流以后，可以做</p></blockquote></li></ul><span id="more"></span><h2 id="第一部分-Java-基础编程"><a href="#第一部分-Java-基础编程" class="headerlink" title="第一部分 Java 基础编程"></a>第一部分 Java 基础编程</h2><h3 id="第1章-Java-语言概述"><a href="#第1章-Java-语言概述" class="headerlink" title="第1章 Java 语言概述"></a>第1章 Java 语言概述</h3><p>Java 是 SUN (Stanford University Network, 斯坦福大学网络公司) 1995 年推出的一门高级编程语言</p><p><a href="https://www.tiobe.com/tiobe-index/"><strong>TIOBE 指数</strong></a></p><h4 id="1-1-Java-简史"><a href="#1-1-Java-简史" class="headerlink" title="1.1 Java 简史"></a>1.1 Java 简史</h4><ul><li>1991 年，Green 项目，开发语言最初命名为 Oak ( 橡树 )</li><li>1994 年，开发组意识到 Oak 非常适合于互联网</li><li>1996 年，发布 JDK 1.0，约 8.3 万个网页应用 Java 技术来制作</li><li>1997 年，发布 JDK 1.1 JavaOne 会议召开，创当时全球同类会议规模之最</li><li>1998 年，发布 JDK 1.2 ，同年发布企业平台 J2EE</li><li>1999 年， Java 分成 J2SE 、 J2EE 和 J2ME JSP&#x2F;Servlet 技术诞生</li><li><strong>2004 年，发布里程碑式版本： JDK 1.5 为突出此版本的重要性，更名为 JDK 5.0</strong></li><li>2005 年， <code>J2SE --&gt; JavaSE</code>；<code>J2EE --&gt; JavaEE</code>；<code>J2ME --&gt; JavaME</code></li><li>2009 年， Oracle 公司收购 SUN，交易价格 74 亿美元</li><li>2011 年，发布 JDK 7.0</li><li><strong>2014 年，发布 JDK 8.0 ，是继 JDK 5.0 以来变化最大的版本</strong></li><li>2017 年，发布 JDK 9.0 ，最大限度实现模块化</li><li>2018 年 3 月，发布 JDK 10.0 ，版本号也称为 18.3</li><li>2018 年 9 月，发布 JDK 11.0 ，版本号也称为 18.9</li><li>2019 年 3 月，发布 JDK 12.0 ，版本号也称为 19.3</li><li>2019 年 9 月，发布 JDK 13.0 ，版本号也称为 19.9</li><li>2020 年 3 月，发布 JDK 14.0 ，版本号也称为 20.3</li></ul><h4 id="1-2-Java-技术体系平台"><a href="#1-2-Java-技术体系平台" class="headerlink" title="1.2 Java 技术体系平台"></a>1.2 Java 技术体系平台</h4><ol><li><strong>Java SE</strong> (Java Standard Edition): 标准版，支持面向桌面级应用（如Windows 下的应用程序）的 Java 平台，提供了完整的 Java 核心 API ，此版本以前称为 J2SE</li><li><strong>Java EE</strong> (Java Enterprise Edition): 企业版，为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如Servlet 、 Jsp 等，主要针对于 Web 应用程序开发。版本以前称为 J2EE</li><li><strong>Java ME</strong>  (Java Micro Edition): 小型版，支持Java 程序运行在移动终端（手机、 PDA ）上的平台，对 Java API 有所精简，并加入了针对移动终端的支持，此版本以前称为 J2ME</li><li><strong>Java Card</strong>：支持一些Java 小程序（ Applets ）运行在小内存设备（如智能卡）上的平台</li></ol><h4 id="1-3-应用领域"><a href="#1-3-应用领域" class="headerlink" title="1.3 应用领域"></a>1.3 应用领域</h4><ol><li><strong>企业级应用</strong>：主要指复杂的大企业的软件系统、各种类型的网站。Java 的安全机制以及它的跨平台的优势，使它在分布式系统领域开发中有广泛应用。应用领域包括金融、电信、交通、电子商务等。</li><li><strong>Android 平台应用</strong>：Android 应用程序使用 Java 语言编写。Android 开发水平的高低很大程度上取决于 Java 语言核心能力是否扎实。</li><li><strong>大数据平台开发</strong>：各类框架有 Hadoop、spark、storm、flink 等，就这类技术生态圈来讲，还有各种中间件如 flume、kafka、sqoop 等等 ，这些框架以及工具大多数是用 Java 编写而成，但提供诸如 Java、scala、Python、R 等各种语言 API 供编程。</li><li><strong>移动领域应用</strong>：主要表现在消费和嵌入式领域，是指在各种小型设备上的应用，包括手机、 PDA 、机顶盒、汽车通信设备等。</li></ol><h4 id="1-4-Java语言运行机制"><a href="#1-4-Java语言运行机制" class="headerlink" title="1.4 Java语言运行机制"></a>1.4 Java语言运行机制</h4><p><strong>1）Java语言的特点</strong></p><ol><li><p>面向对象</p><ul><li>两个基本概念：类、对象</li><li>三大特性：封装、继承、多态</li></ul></li><li><p>健壮性</p></li><li><p>跨平台性</p></li></ol><p><strong>2）Java两种核心机制</strong></p><ol><li>① <strong>Java虚拟机</strong>（Java Virtual Machine）<ul><li>对于不同的平台，有不同的虚拟机。</li><li>Java 虚拟机机制屏蔽了底层运行平台的差别，实现了<strong>“ 一次编译，到处运行“</strong></li></ul></li><li>② <strong>垃圾回收机制</strong>（Garbage Collection）<ul><li>不再使用的内存空间应回收–垃圾回收。</li><li>垃圾回收在 Java 程序运行过程中自动进行，程序员无法精确控制和干预</li></ul></li></ol><p><strong>3） Java语言的环境搭建</strong></p><ol><li><strong>JDK</strong>（Java Development Kit Java，开发工具包）</li><li><strong>JRE</strong>（Java R untime Environment Java，运行环境 ）</li><li><strong>JDK、 JRE 、JVM之间的关系</strong><ul><li>JDK &#x3D; JRE + 开发工具集（例如 Javac 编译工具 等）</li><li>JRE &#x3D; JVM + Java SE 标准类库</li></ul></li></ol><h3 id="第2章-第一个Java程序"><a href="#第2章-第一个Java程序" class="headerlink" title="第2章 第一个Java程序"></a>第2章 第一个Java程序</h3><p><strong>知识点</strong>：编译运行过程、三种注释</p><h4 id="2-1-打印-Hello-World"><a href="#2-1-打印-Hello-World" class="headerlink" title="2.1 打印 Hello World"></a>2.1 打印 Hello World</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印 Hello World</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1）编译运行过程</strong></p><ol><li><p>将 Java 代码编写到扩展名为 <code>.java 的文件</code>（<strong>源文件</strong>）中。</p></li><li><p>通过 javac 命令对该 java 文件进行<strong>编译</strong> 。</p></li><li><p>通过 java 命令对生成的 class 文件（<strong>字节码文件</strong>）进行<strong>运行</strong> 。</p></li></ol><p><strong>2）具体步骤</strong></p><ol><li><p>打开记事本，输入以上代码，保存为 <code>HelloWorld.java</code></p></li><li><p>在保存文件的位置打开命令行，输入<code>javac HelloWorld.java</code>，会生成一个<code>HelloWorld.class</code>文件</p></li><li><p>命令行继续输入<code>java HelloWorld</code></p></li></ol><h4 id="2-2-注释"><a href="#2-2-注释" class="headerlink" title="2.2 注释"></a>2.2 注释</h4><p><strong>1）单行注释</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注释文字</span></span><br></pre></td></tr></table></figure><p><strong>2）多行注释</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">注释文字 </span></span><br><span class="line"><span class="comment">注释文字 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><strong>3）文档注释</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> 指定 java 程序的作者</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 指定源文件的版本</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>注释内容可以被 JDK 提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。</p></blockquote><p><strong>操作方式</strong>：<code>javadoc -d [文件夹名] -author -version [源文件名]</code></p><h4 id="2-3-良好的编程风格"><a href="#2-3-良好的编程风格" class="headerlink" title="2.3 良好的编程风格"></a>2.3 良好的编程风格</h4><p><strong>1）正确的注释和注释风格</strong></p><ul><li><p>使用文档注释来注释整个类或整个方法</p></li><li><p>如果注释方法中的某一个步骤，使用单行或多行注释</p></li></ul><p><strong>2）正确的缩进和空白</strong></p><ul><li><p>使用一次 <kbd>Tab</kbd> 操作，实现缩进</p></li><li><p>运算符两边习惯性各加一个空格</p></li></ul><p><strong>3）块的风格</strong></p><ul><li><a href="https://docs.oracle.com/javase/8/docs/api/index.html">Java API</a> 源代码选择了行尾风格</li></ul><blockquote><p>API：Application Programming Interface。习惯上：将语言提供的类库，都称为API</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Java注释的三种方式：</span></span><br><span class="line"><span class="comment">①单行注释</span></span><br><span class="line"><span class="comment">②多行注释</span></span><br><span class="line"><span class="comment">③文档注释（Java特有）</span></span><br><span class="line"><span class="comment">生成文档：javadoc -d mydoc -author -version HelloJava.java</span></span><br><span class="line"><span class="comment">mydoc为文档目录</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*****这属于多行注释*****</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> Ding</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*****这属于文档注释*****</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJava</span> &#123;</span><br><span class="line"><span class="comment">//main方法是程序的入口*****这属于单行注释*****</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="comment">//打印HelloJava</span></span><br><span class="line">System.out.println(<span class="string">&quot;HelloJava&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="附：Tips"><a href="#附：Tips" class="headerlink" title="附：Tips"></a>附：Tips</h4><p><strong>1）常用的 DOS 命令</strong></p><ul><li><p><code>dir</code>：列出当前目录下的文件以及文件夹</p></li><li><p><code>md</code>：创建目录</p></li><li><p><code>rd</code>：删除目录</p></li><li><p><code>cd [path]</code>：进入指定目录</p></li><li><p><code>cd..</code>：退回到上级目录</p></li><li><p><code>cd\</code>：退回到根目录</p></li><li><p><code>del</code>：删除文件</p></li><li><p><code>exit</code>：退出dos命令行</p></li><li><p><code>echo javase&gt;test.txt</code>：新建 test.txt 文件并将 “javase” 写入</p><ul><li>上下键可以查看历史操作</li></ul></li></ul><p><strong>2）文件资源管理器</strong></p><ol><li><kbd>win</kbd> + <kbd>E</kbd> 打开文件资源管理器</li><li>在地址栏输入 <code>cmd</code> 回车即可打开<strong>命令行</strong></li><li>在查看工具栏中，打开<code>隐藏/显示</code>中的 <code>文件扩展名</code></li></ol><h3 id="第3章-变量"><a href="#第3章-变量" class="headerlink" title="第3章 变量"></a>第3章 变量</h3><p><strong>知识点</strong>：关键字、标识符、变量、自动类型转换、强制类型转换</p><h4 id="3-1-关键字与保留字"><a href="#3-1-关键字与保留字" class="headerlink" title="3.1 关键字与保留字"></a>3.1 关键字与保留字</h4><p>**1）关键字 (keyword)**：被 Java 语言赋予了特殊含义，用做专门用途的字符串（单词）</p><ul><li><strong>特点</strong>：关键字中所有字母都为<strong>小写</strong></li><li><strong><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html">官方地址</a></strong></li></ul><p>**2）保留字 (reserved word)**：现有 Java 版本尚未使用,但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字</p><ul><li><strong>goto</strong> 、 <strong>const</strong></li><li>命名标识符时要避免使用这些保留字</li></ul><h4 id="3-2-标识符-Identifier"><a href="#3-2-标识符-Identifier" class="headerlink" title="3.2 标识符 (Identifier)"></a>3.2 标识符 (Identifier)</h4><p><strong>1）定义</strong>：Java 对各种变量、方法和类等要素命名时使用的字符序列称为<strong>标识符</strong></p><blockquote><p>凡是自己可以起名字的地方都叫<strong>标识符</strong>，如：包名、类名、接口名、变量名、方法名、常量名</p></blockquote><p><strong>2）规则</strong></p><ul><li>由 26 个英文字母大小写， 0-9 或 $ 组成</li><li>数字不可以开头。</li><li>不可以使用关键字和保留字，但能包含关键字和保留字。</li><li>Java 中严格区分大小写，长度无限制。</li><li>标识符不能包含空格。</li></ul><p><strong>3）命名规范</strong></p><ul><li><p>包名：<code>xxxyyyzzz</code></p></li><li><p>类名、接口名：<code>XxxYyyZzz</code></p></li><li><p>变量名、方法名：<code>xxxYyyZzz</code></p></li><li><p>常量名：<code>XXX_YYY_ZZZ</code></p><p><strong>在起名字时，为了提高阅读性，要尽量意义，“见名知意”。</strong></p></li></ul><h4 id="3-3-变量"><a href="#3-3-变量" class="headerlink" title="3.3 变量"></a>3.3 变量</h4><p><strong>1）定义（声明）变量</strong></p><ul><li><p>方式一：<code>数据类型  变量名 = 变量值;</code></p></li><li><p>方式二：<code>数据类型  变量名;</code><br>                <code>变量名 = 变量值;</code></p></li></ul><blockquote><p>变量必须先声明，后使用</p><p>变量都定义在其<strong>作用域</strong>内，同一个作用域内，不可以声明两个同名的变量</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VariableTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//变量的定义</span></span><br><span class="line"><span class="type">int</span> <span class="variable">myAge</span> <span class="operator">=</span> <span class="number">22</span>;</span><br><span class="line"><span class="comment">//变量的使用</span></span><br><span class="line">System.out.println(myAge);</span><br><span class="line"></span><br><span class="line"><span class="comment">//变量的声明</span></span><br><span class="line"><span class="type">int</span> myNumber;</span><br><span class="line"><span class="comment">//System.out.println(myNnmber);//赋值后才能使用</span></span><br><span class="line"><span class="comment">//变量的赋值</span></span><br><span class="line">myNumber = <span class="number">1001</span>;</span><br><span class="line">System.out.println(myNumber);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span> <span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作用域不同，可以定义同名变量</span></span><br><span class="line"><span class="comment">//变量的定义</span></span><br><span class="line"><span class="type">int</span> <span class="variable">myAge</span> <span class="operator">=</span> <span class="number">22</span>;</span><br><span class="line"><span class="comment">//变量的使用</span></span><br><span class="line">System.out.println(myAge);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）变量的分类</strong></p><p><strong>① 按数据类型分类</strong></p><p>按数据类型分为<strong>基本数据类型（primitive type）</strong>和<strong>引用数据类型（reference type）</strong></p><ol><li><p>基本数据类型又分为数值型、<strong>字符型（char）</strong>、<strong>布尔型（boolean）</strong></p><ul><li>数值型又分为<strong>整数类型（byte、short、int、long）</strong>和<strong>浮点数类型（float、double）</strong></li></ul></li><li><p>引用数据类型又分为<strong>类（class）</strong>、<strong>接口（interface）</strong>和<strong>数组（[]）</strong></p></li></ol><blockquote><p><strong>字符串属于类</strong></p></blockquote><p><strong>② 按声明的位置分类</strong></p><p>按声明的位置分为<strong>成员变量</strong>和<strong>局部变量</strong></p><ol><li>成员变量又分为<strong>实例变量</strong>（不以static修饰）和<strong>类变量</strong>（以static修饰）</li><li>局部变量又分为<strong>形参</strong>（方法、构造器中定义的变量）、<strong>方法局部变量</strong>（在方法内定义）和<strong>代码块局部变量</strong>（在代码块内定义）</li></ol><p><strong>3）基本数据类型</strong></p><p><strong>① 整型</strong></p><table><thead><tr><th align="center">byte</th><th align="center">short</th><th align="center">int</th><th align="center">long</th></tr></thead><tbody><tr><td align="center">1字节</td><td align="center">2字节</td><td align="center">4字节</td><td align="center">8字节</td></tr></tbody></table><p><strong>说明</strong></p><ol><li>byte范围：-128 ~ 127</li><li>声明long型变量，必须以”l”或”L”结尾</li><li>通常，定义整型变量时，使用int型。</li><li>整型的常量，默认类型是：int型</li></ol><p><strong>② 浮点型</strong></p><table><thead><tr><th align="center">float</th><th align="center">double</th></tr></thead><tbody><tr><td align="center">4字节</td><td align="center">8字节</td></tr></tbody></table><p><strong>说明</strong></p><ol><li>浮点型，表示带小数点的数值</li><li>float表示数值的范围比long还大</li><li>定义float类型变量时，变量要以”f”或”F”结尾</li><li>通常，定义浮点型变量时，使用double型。</li><li>浮点型的常量，默认类型为：double</li></ol><p><strong>③ 字符型</strong></p><table><thead><tr><th align="left">char</th></tr></thead><tbody><tr><td align="left">定义char型变量，通常使用一对’’,内部只能写一个字符</td></tr><tr><td align="left">表示方式：1. 声明一个字符 2. 转义字符 3. 直接使用 Unicode 值来表示字符型常量</td></tr></tbody></table><p><strong>④ 布尔型</strong></p><table><thead><tr><th align="left">boolean</th></tr></thead><tbody><tr><td align="left">只能取两个值之一：true 、 false</td></tr><tr><td align="left">常常在条件判断、循环结构中使用</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VariableTest1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基本数据类型</span></span><br><span class="line"><span class="comment">//整型：byte 1字节 -128 ~ 127</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="comment">//byte b2 = 128;</span></span><br><span class="line">System.out.println(b1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//整型：short 2字节</span></span><br><span class="line"><span class="comment">//整型：int 4字节</span></span><br><span class="line"><span class="comment">//整型：long 8字节 以&#x27;l&#x27;或&#x27;L&#x27;结尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通常，定义整型变量时，使用int型</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">123456789098765432L</span>;</span><br><span class="line"><span class="comment">//long l2 = 987654321012345678;</span></span><br><span class="line">System.out.println(l1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//浮点型：float 4字节 以&#x27;f&#x27;或&#x27;F&#x27;结尾</span></span><br><span class="line"><span class="comment">//浮点型：double 8字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通常，定义浮点型变量时，使用double型</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">123.45f</span>;</span><br><span class="line"><span class="comment">//float f2 = 678.90;</span></span><br><span class="line">System.out.println(f1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符型：char 1字符=2字节 用一对单引号&#x27;&#x27;</span></span><br><span class="line"><span class="comment">//表示方式：</span></span><br><span class="line"><span class="comment">//1.声明一个字符 </span></span><br><span class="line"><span class="comment">//2.转义字符 </span></span><br><span class="line"><span class="comment">//3.直接使用 Unicode 值来表示字符型常量</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="comment">//char c2 = &#x27;ab&#x27;;</span></span><br><span class="line">System.out.println(c1);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="string">&#x27;の&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c5</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">System.out.println(c3);</span><br><span class="line">System.out.println(c4);</span><br><span class="line">System.out.println(c5);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="variable">c6</span> <span class="operator">=</span> <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c7</span> <span class="operator">=</span> <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c8</span> <span class="operator">=</span> <span class="string">&#x27;\u1001&#x27;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;***&quot;</span> + c6 + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;***&quot;</span> + c7 + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">System.out.println(c8);</span><br><span class="line"></span><br><span class="line"><span class="comment">//布尔型：boolean true/false </span></span><br><span class="line"><span class="comment">//常常在条件判断、循环结构中使用</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isMale</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">System.out.println(isMale);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isMarried</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (isMarried)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Go home&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Go party&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-自动类型转换"><a href="#3-4-自动类型转换" class="headerlink" title="3.4 自动类型转换"></a>3.4 自动类型转换</h4><ul><li><p>当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型：**<code>byte 、char 、short --&gt; int --&gt; long --&gt; float --&gt; double </code>**（此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量）</p></li><li><p><strong>特别的</strong>：当 byte、char、short 三种类型的变量做运算时，结果为int型</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VariableTest2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">129</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> b1 + i1;</span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> b1 + i1;</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> b1 + i1;</span><br><span class="line">System.out.println(i2);</span><br><span class="line">System.out.println(l);</span><br><span class="line">System.out.println(f);</span><br><span class="line"></span><br><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> s1;</span><br><span class="line">System.out.println(d1);<span class="comment">//123.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//***************特别地*********************</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;<span class="comment">//97</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i4</span> <span class="operator">=</span> c1 + i3;</span><br><span class="line">System.out.println(i4);</span><br><span class="line"></span><br><span class="line"><span class="type">short</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//char c3 = c1 + b2;//编译不通过</span></span><br><span class="line"><span class="comment">//short s3 = b2 + s2;//编译不通过</span></span><br><span class="line"><span class="comment">//short s4 = b1 + b2;//编译不通过</span></span><br><span class="line"><span class="comment">//****************************************</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-强制类型转换"><a href="#3-5-强制类型转换" class="headerlink" title="3.5 强制类型转换"></a>3.5 强制类型转换</h4><ul><li><strong>强转符</strong>：()</li><li><strong>注意</strong>：强制类型转换，可能导致精度损失。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VariableTest3</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">12.9</span>;</span><br><span class="line"><span class="comment">//精度损失举例1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> (<span class="type">int</span>)d1;<span class="comment">//截断操作</span></span><br><span class="line">System.out.println(i1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有精度损失</span></span><br><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s2</span> <span class="operator">=</span> (<span class="type">short</span>)l1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//精度损失举例2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)i2;</span><br><span class="line">System.out.println(b);<span class="comment">//-128</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第4章-运算符"><a href="#第4章-运算符" class="headerlink" title="第4章 运算符"></a>第4章 运算符</h3><p><strong>知识点</strong>：算数运算符、赋值运算符、比较运算符、逻辑运算符、位运算符、三元运算符</p><h4 id="4-1-算术运算符"><a href="#4-1-算术运算符" class="headerlink" title="4.1 算术运算符"></a>4.1 算术运算符</h4><table><thead><tr><th align="center"><code>+</code></th><th align="center"><code>-</code></th><th align="center"><code>+</code></th><th align="center"><code>-</code></th><th align="center"><code>*</code></th><th align="center"><code>/</code></th><th align="center"><code>%</code></th><th align="center"><code>++</code></th><th align="center"><code>--</code></th><th align="center"><code>++</code></th><th align="center"><code>--</code></th><th align="center"><code>+</code></th></tr></thead><tbody><tr><td align="center">正号</td><td align="center">负号</td><td align="center">加</td><td align="center">减</td><td align="center">乘</td><td align="center">除</td><td align="center">取余</td><td align="center">前自增</td><td align="center">前自减</td><td align="center">后自增</td><td align="center">后自减</td><td align="center">字符串连接</td></tr></tbody></table><p><strong>1）自增</strong></p><ul><li>(前)++：先自增1，后运算</li><li>(后)++：先运算，后自增1</li></ul><p><strong>2）自减</strong></p><ul><li>(前)–：先自减1，后运算</li><li>(后)–：先运算，后自减1</li></ul><p><strong>3）连接符</strong>：+（只能使用在String与其他数据类型变量之间使用）</p><h4 id="4-2-赋值运算符"><a href="#4-2-赋值运算符" class="headerlink" title="4.2 赋值运算符"></a>4.2 赋值运算符</h4><ul><li><code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code></li><li><strong>注意</strong>：运算的结果不会改变变量本身的数据类型</li></ul><blockquote><p>开发中，如果希望变量实现+2的操作，有几种方法？(前提：int num &#x3D; 10;)<br>方式一：num &#x3D; num + 2;<br>方式二：num +&#x3D; 2; (推荐)</p></blockquote><blockquote><p>开发中，如果希望变量实现+1的操作，有几种方法？(前提：int num &#x3D; 10;)<br>方式一：num &#x3D; num + 1;<br>方式二：num +&#x3D; 1;<br>方式三：num++; (推荐)</p></blockquote><h4 id="4-3-比较运算符"><a href="#4-3-比较运算符" class="headerlink" title="4.3 比较运算符"></a>4.3 比较运算符</h4><ul><li><p>也叫<strong>关系运算符</strong>，比较运算符运算的结果都是 boolean 型</p></li><li><p><code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>、<code>instanceof</code></p></li></ul><hr><ol><li><p>&lt;、&gt;&#x3D;、&lt;&#x3D; :只能使用在数值类型的数据之间。</p></li><li><p>&#x3D;&#x3D; 和 !&#x3D;: 不仅可以使用在数值类型数据之间，还可以使用在其他引用类型变量之间。</p></li></ol><h4 id="4-4-逻辑运算符"><a href="#4-4-逻辑运算符" class="headerlink" title="4.4 逻辑运算符"></a>4.4 逻辑运算符</h4><table><thead><tr><th align="center"><code>&amp;</code></th><th align="center"><code>&amp;&amp;</code></th><th align="center"><code>|</code></th><th align="center"><code>||</code></th><th align="center"><code>!</code></th><th align="center"><code>^</code></th></tr></thead><tbody><tr><td align="center">逻辑与</td><td align="center">短路与</td><td align="center">逻辑或</td><td align="center">短路或</td><td align="center">逻辑非</td><td align="center">逻辑异或</td></tr></tbody></table><ul><li>逻辑运算符操作的都是 boolean 类型的变量，而且结果也是 boolean 类型</li></ul><h4 id="4-5-位运算符"><a href="#4-5-位运算符" class="headerlink" title="4.5 位运算符"></a>4.5 位运算符</h4><p>| <code>&lt;&lt;</code> | <code>&gt;&gt;</code> |   <code>&gt;&gt;&gt;</code>    |  <code>&amp;</code>   |  <code>|</code>   |   <code>^</code>    |   <code>~</code>    |<br>| :–: | :–: | :——–: | :—-: | :—-: | :——: | :——: |<br>| 左移 | 右移 | 无符号右移 | 与运算 | 或运算 | 异或运算 | 取反运算 |</p><ul><li><p>位运算是直接对整数的二进制进行的运算，操作的都是整型的数据（<strong>注</strong>：无<code>&lt;&lt;&lt;</code>）</p></li><li><p>&lt;&lt;：在一定范围内，每向左移1位，相当于 * 2</p></li><li><p>&gt;&gt;：在一定范围内，每向右移1位，相当于 &#x2F; 2</p></li></ul><h4 id="4-6-三元运算符"><a href="#4-6-三元运算符" class="headerlink" title="4.6 三元运算符"></a>4.6 三元运算符</h4><ul><li><strong>格式</strong>：<code>(条件表达式)?表达式 1 : 表达式 2;</code></li></ul><ol><li><p>条件表达式的结果为 <strong>boolean</strong> 类型 </p></li><li><p>根据条件表达式真或假，决定执行表达式1，还是表达式2</p><ul><li>如果表达式为 true，则执行表达式1。</li><li>如果表达式为 false，则执行表达式2。</li></ul></li><li><p>表达式1 和表达式2 要求是一致的。</p></li><li><p>三元运算符可以嵌套使用</p></li><li><p>凡是可以使用三元运算符的地方，都可以改写为 if-else；反之，不成立。</p></li><li><p>如果程序既可以使用三元运算符，又可以使用 if-else 结构，那么优先选择三元运算符。（原因：简洁、执行效率高。）</p></li></ol><h3 id="第5章-流程控制"><a href="#第5章-流程控制" class="headerlink" title="第5章 流程控制"></a>第5章 流程控制</h3><p><strong>知识点</strong></p><ol><li><p>顺序结构</p></li><li><p>分支结构：if-else 条件判断结构、switch-case 选择结构</p></li><li><p>循环结构：for 循环结构、while 循环结构、do-while 循环结构、嵌套循环</p></li></ol><h4 id="5-1-if-else-条件判断结构"><a href="#5-1-if-else-条件判断结构" class="headerlink" title="5.1 if-else 条件判断结构"></a>5.1 if-else 条件判断结构</h4><p><strong>1）三种形式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种</span></span><br><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">执行表达式</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种：二选一</span></span><br><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">执行表达式<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">执行表达式<span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种：n选一</span></span><br><span class="line"><span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">执行表达式<span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">执行表达式<span class="number">2</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (条件表达式) &#123;</span><br><span class="line">执行表达式<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">执行表达式n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>产生<strong>随机数</strong>：使用 Math.random() → [0.0 - 1.0)</p></li><li><p>公式：[a,b] → (int)(Math.random() * (b - a + 1) ) + a</p></li></ul><p><strong>2）说明</strong></p><ol><li><p>else 结构是可选的。</p></li><li><p>针对于条件表达式：</p><ul><li>如果多个条件表达式之间是“互斥”关系(或没有交集的关系)，哪个判断和执行语句声明顺序无所谓</li><li>如果多个条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将哪个结构先声明</li><li>如果多个条件表达式之间有包含的关系，通常情况下，需要将范围小声明在范围大的前面。否则，范围小的就没机会执行了</li></ul></li><li><p>if-else 结构是可以相互嵌套的。</p></li><li><p>如果 if-else 结构中的执行语句只有一行时，对应的一对{}可以省略的。但是，不建议大家省略。</p></li></ol><h4 id="5-2-switch-case-选择结构"><a href="#5-2-switch-case-选择结构" class="headerlink" title="5.2 switch-case 选择结构"></a>5.2 switch-case 选择结构</h4><p><strong>1）格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span> (表达式) &#123;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">执行语句<span class="number">1</span>;</span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">执行语句<span class="number">2</span>;</span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">执行语句n;</span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）说明</strong></p><ol><li><p>根据 switch 表达式中的值，依次匹配各个 case 中的常量。一旦匹配成功，则进入相应 case 结构中，调用其执行语句。当调用完执行语句以后，则仍然继续向下执行其他 case 结构中的执行语句，直到遇到 break 关键字或此 switch-case 结构末尾结束为止。</p></li><li><p><code>break</code>：可以使用在 switch-case 结构中，表示一旦执行到此关键字，就跳出 switch-case 结构</p></li><li><p><strong>switch 结构中的表达式，只能是如下的6种数据类型之一：<code>byte 、short、char、int、枚举类型(JDK5.0新增)、String 类型(JDK7.0新增)</code></strong></p></li><li><p>case 之后只能声明常量。不能声明范围。</p></li><li><p>break 关键字是可选的。</p></li><li><p><code>default</code>：相当于 if-else 结构中的else；default 结构是可选的，而且位置是灵活的。</p></li></ol><p><strong>注意</strong></p><ul><li><p>凡是可以使用 switch-case 的结构，都可以转换为 if-else。反之，不成立。</p></li><li><p>我们写分支结构时，当发现既可以使用 switch-case,（同时，switch 中表达式的取值情况不太多），又可以使用 if-els e时，我们优先选择使用 switch-case。原因：switch-case 执行效率稍高。</p></li><li><p>如果 switch-case 结构中的多个 case 的执行语句相同，则可以考虑进行合并。</p></li></ul><h4 id="5-3-for-循环结构"><a href="#5-3-for-循环结构" class="headerlink" title="5.3 for  循环结构"></a>5.3 for  循环结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (①; ②; ④) &#123;</span><br><span class="line">③</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行过程</strong>：① - ② - ③ - ④ - ② - ③ - ④ - … - ②</p><h4 id="5-4-while-循环结构"><a href="#5-4-while-循环结构" class="headerlink" title="5.4 while 循环结构"></a>5.4 while 循环结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①</span><br><span class="line"><span class="keyword">while</span> (②) &#123;</span><br><span class="line">③;</span><br><span class="line">④;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行过程</strong>：① - ② - ③ - ④ - ② - ③ - ④ - … - ②</p><ul><li>写while循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环！</li><li>我们写程序，要避免出现死循环。</li><li>for 循环和 while 循环是可以相互转换的！</li></ul><hr><p><strong>for 循环和 while 循环总结：</strong></p><ul><li><p>开发中，基本上我们都会从 for、while 中进行选择，实现循环结构。</p></li><li><p>for 循环和 while 循环是可以相互转换的！ </p></li><li><p>我们写程序，要避免出现死循环。</p></li><li><p><strong>区别</strong>：for 循环和 while 循环的初始化条件部分的作用范围不同。</p></li></ul><h4 id="5-5-do-while"><a href="#5-5-do-while" class="headerlink" title="5.5 do-while"></a>5.5 do-while</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">③;</span><br><span class="line">④;</span><br><span class="line">&#125;<span class="keyword">while</span>(②);</span><br></pre></td></tr></table></figure><p><strong>执行过程</strong>：① - ③ - ④ - ② - ③ - ④ - … - ②</p><ul><li>do-while 循环至少会执行一次循环体！</li><li>开发中，使用 for 和 while 更多一些。较少使用 do-while</li></ul><h4 id="5-6-嵌套循环"><a href="#5-6-嵌套循环" class="headerlink" title="5.6 嵌套循环"></a>5.6 嵌套循环</h4><p><strong>1）嵌套循环</strong>：将一个循环结构 A 声明在另一个循环结构 B 的循环体中,就构成了嵌套循环</p><ul><li><strong>外层循环</strong>：循环结构 B</li><li><strong>内层循环</strong>：循环结构 A</li></ul><p><strong>2）说明</strong></p><ul><li><p>内层循环结构遍历一遍，只相当于外层循环循环体执行了一次</p></li><li><p>假设外层循环需要执行 m 次，内层循环需要执行 n 次。此时内层循环的循环体一共执行了 m×n 次</p></li><li><p>外层循环控制行数，内层循环控制列数</p></li></ul><h4 id="5-7-break-和-continue-关键字"><a href="#5-7-break-和-continue-关键字" class="headerlink" title="5.7 break 和 continue 关键字"></a>5.7 break 和 continue 关键字</h4><table><thead><tr><th align="center"></th><th align="center">使用范围</th><th align="center">循环中的作用</th><th align="center">相同点</th></tr></thead><tbody><tr><td align="center">break</td><td align="center">switch-case、循环结构中</td><td align="center">结束当前循环</td><td align="center">关键字后面不能声明执行语句</td></tr><tr><td align="center">continue</td><td align="center">循环结构中</td><td align="center">结束当次循环</td><td align="center">关键字后面不能声明执行语句</td></tr></tbody></table><ul><li><p><strong>“无限循环”结构</strong>：<code>while(true);</code> 或 <code>for(;;)</code></p></li><li><p>如何结束一个循环结构？</p><ul><li>方式一：当循环条件是false时</li><li>方式二：在循环体中，执行break</li></ul></li><li><p><strong>循环结构的四要素</strong>：① 初始化条件；② 循环条件（boolean类型）；③ 循环体；④ 迭代条件</p></li><li><p><strong>说明</strong>：通常情况下，循环结束都是因为②中循环条件返回 <code>false </code>了。</p></li></ul><h3 id="第6章-数组（Array）"><a href="#第6章-数组（Array）" class="headerlink" title="第6章 数组（Array）"></a>第6章 数组（Array）</h3><p><strong>知识点</strong>：数组、一维数组、二维数组</p><h4 id="6-1-数组的概念"><a href="#6-1-数组的概念" class="headerlink" title="6.1 数组的概念"></a>6.1 数组的概念</h4><p><strong>1）数组的理解</strong>：数组是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。</p><p><strong>2）相关的概念</strong></p><ul><li><p>数组名</p></li><li><p>元素</p></li><li><p>索引：角标、下标、</p></li><li><p>数组的长度：元素的个数</p></li></ul><p><strong>3）数组的特点</strong></p><ul><li><p>数组是有序排列的</p></li><li><p>数组属于<strong>引用数据类型</strong>的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型</p></li><li><p>创建数组对象会在内存中开辟一整块连续的空间</p></li><li><p>数组的长度一旦确定，就不能修改</p></li></ul><p><strong>4）数组的分类</strong></p><ul><li><p>按照维数：一维数组、二维数组……</p></li><li><p>按照数组元素的类型：基本数据类型元素的数组、引用数据类型元素的数组</p></li></ul><h4 id="6-2-一维数组"><a href="#6-2-一维数组" class="headerlink" title="6.2 一维数组"></a>6.2 一维数组</h4><p><strong>1）声明与初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ids;<span class="comment">// 声明</span></span><br><span class="line"><span class="comment">// ① 静态初始化:数组的初始化和数组元素的赋值操作同时进行</span></span><br><span class="line">ids = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>&#125;;</span><br><span class="line"><span class="comment">// ② 动态初始化:数组的初始化和数组元素的赋值操作分开进行</span></span><br><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line"><span class="type">int</span>[] arr4 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">// 类型推断</span></span><br></pre></td></tr></table></figure><p><strong>2）调用数组的指定位置的元素</strong>（通过角标的方式调用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names[<span class="number">0</span>] = <span class="string">&quot;王铭&quot;</span>;</span><br><span class="line">names[<span class="number">1</span>] = <span class="string">&quot;王赫&quot;</span>;</span><br><span class="line">names[<span class="number">2</span>] = <span class="string">&quot;张学良&quot;</span>;</span><br><span class="line">names[<span class="number">3</span>] = <span class="string">&quot;孙居龙&quot;</span>;</span><br><span class="line">names[<span class="number">4</span>] = <span class="string">&quot;王宏志&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>3）数组的长度</strong></p><ul><li>数组一旦初始化，其长度就是确定的，就不可修改。使用<code>.length</code><strong>属性</strong>获取数组的长度。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(names.length);<span class="comment">//5</span></span><br></pre></td></tr></table></figure><p><strong>4）遍历数组</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; names.length; i++) &#123;</span><br><span class="line">System.out.println(names[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5）数组元素的默认初始化值</strong> </p><table><thead><tr><th align="center">数据类型</th><th align="center">整型</th><th align="center">浮点型</th><th align="center">字符型</th><th align="center">布尔型</th><th align="center">引用数据类型</th></tr></thead><tbody><tr><td align="center">默认初始化值</td><td align="center">0</td><td align="center">0.0</td><td align="center">0 或 ‘\u0000’</td><td align="center">false</td><td align="center">null</td></tr></tbody></table><h4 id="6-3-二维数组"><a href="#6-3-二维数组" class="headerlink" title="6.3 二维数组"></a>6.3 二维数组</h4><p><strong>1）理解二维数组</strong>：一个一维数组A的元素如果还是一个一维数组类型的，则，此数组A称为二维数组</p><p><strong>2）声明与初始化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr1;<span class="comment">// 声明</span></span><br><span class="line"><span class="comment">// 静态初始化</span></span><br><span class="line">arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,&#123;<span class="number">4</span>, <span class="number">5</span>&#125;,&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;;</span><br><span class="line"><span class="comment">// 动态初始化1</span></span><br><span class="line">String[][] arr2 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>][<span class="number">2</span>];</span><br><span class="line"><span class="comment">// 动态初始化2</span></span><br><span class="line">String[][] arr3 = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">3</span>][];</span><br><span class="line"><span class="type">int</span>[] arr4[] = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,&#123;<span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">10</span>&#125;,&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;;<span class="comment">// 也是正确的写法</span></span><br><span class="line"><span class="type">int</span>[] arr5[] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;,&#123;<span class="number">4</span>, <span class="number">5</span>&#125;,&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;&#125;;<span class="comment">// 类型推断</span></span><br></pre></td></tr></table></figure><p><strong>3）调用数组的指定位置的元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(arr1[<span class="number">0</span>][<span class="number">1</span>]);<span class="comment">// 2</span></span><br><span class="line">System.out.println(arr2[<span class="number">1</span>][<span class="number">1</span>]);<span class="comment">// null</span></span><br><span class="line"></span><br><span class="line">arr3[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>];</span><br><span class="line">System.out.println(arr3[<span class="number">1</span>][<span class="number">0</span>]);<span class="comment">// null</span></span><br><span class="line">System.out.println(arr3[<span class="number">0</span>]);<span class="comment">// null</span></span><br></pre></td></tr></table></figure><p><strong>4）数组的长度</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(arr4.length);<span class="comment">// 3</span></span><br><span class="line">System.out.println(arr4[<span class="number">0</span>].length);<span class="comment">// 3</span></span><br><span class="line">System.out.println(arr4[<span class="number">1</span>].length);<span class="comment">// 4</span></span><br></pre></td></tr></table></figure><p><strong>5）遍历二维数组元素</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr4.length; i++)&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arr4[i].length;j++) &#123;</span><br><span class="line">        System.out.print(arr4[i][j] + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6）默认初始化值</strong>：二维数组分为外层数组的元素，内层数组的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 外层元素：arr[0],arr[1]等</span></span><br><span class="line"><span class="comment">// 内层元素：arr[0][0],arr[1][2]等</span></span><br></pre></td></tr></table></figure><p><strong>初始化方式一</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure><ul><li><p>外层元素的初始化值为：<strong>地址值</strong></p></li><li><p>内层元素的初始化值为：与一维数组初始化情况相同</p></li></ul><p><strong>初始化方式二</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][];</span><br></pre></td></tr></table></figure><ul><li><p>外层元素的初始化值为：<strong>null</strong></p></li><li><p>内层元素的初始化值为：不能调用，否则报错。</p></li></ul><h4 id="6-4-数组的常见算法"><a href="#6-4-数组的常见算法" class="headerlink" title="6.4 数组的常见算法"></a>6.4 数组的常见算法</h4><p><strong>1）数组的创建与元素赋值</strong></p><ul><li>杨辉三角（二维数组）、回形数（二维数组）、6个数，1-30之间随机生成且不重复。</li></ul><p><strong>2）对于数值型的数组</strong></p><ul><li>最大值、最小值、总和、平均数</li></ul><p><strong>3）数组的赋值与复制</strong></p><ul><li><strong>赋值</strong>：两个变量指向同一个数组的地址，修改一个数组的元素，另一个也跟着修改。</li><li><strong>复制</strong>：两个独立的数组，数组的元素相同。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1,arr2;</span><br><span class="line">arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">arr2 = arr1;</span><br><span class="line"><span class="comment">//复制</span></span><br><span class="line">arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr2.length; i++) &#123;</span><br><span class="line">arr2[i] = arr1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4）反转</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length / <span class="number">2</span>; i++) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">arr[i] = arr[arr.length - i -<span class="number">1</span>];</span><br><span class="line">arr[arr.length - i -<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = arr.length - <span class="number">1</span>; i &lt; j; i++, j--) &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5）查找</strong></p><p><strong>① 线性查找</strong> </p><ul><li><p><strong>实现思路</strong>：通过遍历的方式，一个一个的数据进行比较、查找</p></li><li><p><strong>适用性</strong>：具有普遍适用性。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (dest.equals(arr[i])) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;找到了指定的元素，位置为：&quot;</span> + i);</span><br><span class="line">isFlag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isFlag) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;很遗憾，没有找到的啦！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>② 二分法查找</strong></p><ul><li><strong>实现思路</strong>：每次比较中间值，折半的方式检索</li><li><strong>适用性</strong>：数组必须有序</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 初始的首索引</span></span><br><span class="line"><span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;<span class="comment">// 初始的末索引</span></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span> (head &lt;= end) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (head + end) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (dest == arr[middle]) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;找到了指定的元素，位置为：&quot;</span> + middle);</span><br><span class="line">isFlag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[middle] &gt; dest1) &#123;</span><br><span class="line">end = middle - <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;<span class="comment">//arr[middle] &lt; dest1</span></span><br><span class="line">head = middle + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (isFlag) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;很遗憾，没有找到的啦！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>6）排序</strong></p><table><thead><tr><th align="center">排序算法</th><th align="center">平均时间复杂度</th><th align="center">最好情况</th><th align="center">最坏情况</th><th align="center">空间复杂度</th><th align="center">排序方式</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">冒泡排序</td><td align="center">O(n^2^)</td><td align="center">O(n)</td><td align="center">O(n^2^)</td><td align="center">O(1)</td><td align="center">In-place</td><td align="center">稳定</td></tr><tr><td align="center">选择排序</td><td align="center">O(n^2^)</td><td align="center">O(n^2^)</td><td align="center">O(n^2^)</td><td align="center">O(1)</td><td align="center">In-place</td><td align="center">数组不稳定、链表稳定</td></tr><tr><td align="center">插入排序</td><td align="center">O(n^2^)</td><td align="center">O(n)</td><td align="center">O(n^2^)</td><td align="center">O(1)</td><td align="center">In-place</td><td align="center">稳定</td></tr><tr><td align="center">快速排序</td><td align="center">O(n log n)</td><td align="center">O(n log n)</td><td align="center">O(n^2^)</td><td align="center">O(log n)</td><td align="center">In-place</td><td align="center">不稳定</td></tr><tr><td align="center">堆排序</td><td align="center">O(n log n)</td><td align="center">O(n log n)</td><td align="center">O(n log<del>2</del>n)</td><td align="center">O(1)</td><td align="center">In-place</td><td align="center">不稳定</td></tr><tr><td align="center">归并排序</td><td align="center">O(n log n)</td><td align="center">O(n log n)</td><td align="center">O(n log<del>2</del>n)</td><td align="center">O(n)</td><td align="center">Out-place</td><td align="center">稳定</td></tr><tr><td align="center">希尔排序</td><td align="center">O(n log n)</td><td align="center">O(n log^2^ n)</td><td align="center">O(n log^2^ n)</td><td align="center">O(1)</td><td align="center">In-place</td><td align="center">不稳定</td></tr><tr><td align="center">计数排序</td><td align="center">O(n+k)</td><td align="center">O(n+k)</td><td align="center">O(n+k)</td><td align="center">O(k)</td><td align="center">Out-place</td><td align="center">稳定</td></tr><tr><td align="center">桶排序</td><td align="center">O(n+k)</td><td align="center">O(n+k)</td><td align="center">O(n)</td><td align="center">O(n+k)</td><td align="center">Out-place</td><td align="center">稳定</td></tr><tr><td align="center">基数排序</td><td align="center">O(n×k)</td><td align="center">O(n×k)</td><td align="center">O(n×k)</td><td align="center">O(n+k)</td><td align="center">Out-place</td><td align="center">稳定</td></tr></tbody></table><p><strong>① 冒泡排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length - <span class="number">1</span> - i; j++) &#123;</span><br><span class="line"><span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>② 快速排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span> <span class="params">(<span class="type">int</span>[] data, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> data[i];</span><br><span class="line">data[i] = data[j];</span><br><span class="line">data[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">subSort</span> <span class="params">(<span class="type">int</span>[] data, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> data[start];</span><br><span class="line"><span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> start;</span><br><span class="line"><span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> end + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (low &lt; end &amp;&amp; data[++low] - base &lt;= <span class="number">0</span>)&#123;&#125;</span><br><span class="line"><span class="keyword">while</span> (high &gt; start &amp;&amp; data[--high] - base &gt;= <span class="number">0</span>)&#123;&#125;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">swap(data, low, high);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(data, start, high);</span><br><span class="line">subSort(data, start, high - <span class="number">1</span>);<span class="comment">// 递归调用</span></span><br><span class="line">subSort(data, high + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] data)</span>&#123;</span><br><span class="line">subSort(data,<span class="number">0</span>,data.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-5-Arrays-工具类"><a href="#6-5-Arrays-工具类" class="headerlink" title="6.5 Arrays 工具类"></a>6.5 Arrays 工具类</h4><ul><li><p>Arrays 定义在 <code>java.util</code> 包下，提供了很多操作数组的方法</p></li><li><p>导包：<code>import java.util.Arrays;</code></p></li></ul><p>**1）equals()**：<code>boolean equals(int[] a,int[] b)</code>: 判断两个数组是否相等</p><p>**2）toString()**：<code>String toString(int[] a)</code>: 输出数组信息</p><p>**3）fill()**：<code>void fill(int[] a,int val)</code>: 将指定值填充到数组之中</p><p>**4）sort()**：<code>void sort(int[] a)</code>: 对数组进行排序</p><p>**5）binarySearch()**：<code>int binarySearch(int[] a,int key)</code>: 二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.boolean equals(int[] a,int[] b): 判断两个数组是否相等。</span></span><br><span class="line"><span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEquals</span> <span class="operator">=</span> Arrays.equals(arr1, arr2);</span><br><span class="line">System.out.println(isEquals);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.String toString(int[] a): 输出数组信息。</span></span><br><span class="line">System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.void fill(int[] a,int val): 将指定值填充到数组之中。</span></span><br><span class="line">Arrays.fill(arr1, <span class="number">10</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 4.void sort(int[] a): 对数组进行排序。</span></span><br><span class="line">Arrays.sort(arr2);</span><br><span class="line">System.out.println(Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 5.int binarySearch(int[] a,int key)</span></span><br><span class="line"><span class="type">int</span>[] arr3 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">98</span>, -<span class="number">34</span>, <span class="number">2</span>, <span class="number">34</span>, <span class="number">54</span>, <span class="number">66</span>, <span class="number">79</span>, <span class="number">105</span>, <span class="number">210</span>, <span class="number">333</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr3, <span class="number">210</span>);</span><br><span class="line"><span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    System.out.println(index);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;未找到&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-6-数组的常见异常"><a href="#6-6-数组的常见异常" class="headerlink" title="6.6 数组的常见异常"></a>6.6 数组的常见异常</h4><p><strong>1）数组角标越界异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="comment">//System.out.println(arr[-2]);//ArrayIndexOutOfBoundsException</span></span><br></pre></td></tr></table></figure><p><strong>2）空指针异常</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一：</span></span><br><span class="line"><span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">arr1 = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">// System.out.println(arr1[0]);// NullPointerExceptio</span></span><br><span class="line"><span class="comment">//情况二：</span></span><br><span class="line"><span class="type">int</span>[][] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][];</span><br><span class="line"><span class="comment">// System.out.println(arr2[0][0]);// NullPointerException</span></span><br></pre></td></tr></table></figure><h3 id="第7章-面向对象-（OOP）"><a href="#第7章-面向对象-（OOP）" class="headerlink" title="第7章 面向对象 （OOP）"></a>第7章 面向对象 （OOP）</h3><h4 id="7-1-类和对象"><a href="#7-1-类和对象" class="headerlink" title="7.1 类和对象"></a>7.1 类和对象</h4><p><strong>1）面向对象与面向过程</strong></p><ul><li><p>面向过程编程（Procedure Oriented Programming）：强调的是<strong>功能行为</strong>，以函数为最小单位，考虑<strong>怎么做</strong></p></li><li><p>面向对象编程（Object Oriented Programming）：强调具备了功能的<strong>对象</strong>，以类&#x2F;对象为最小单位，考虑<strong>谁来做</strong></p></li></ul><p><strong>2）面向对象的三大特征</strong>：封装（Encapsulation）、继承（Inheritance）、多态（Polymorphism）</p><p><strong>3）面向对象中两个重要的概念</strong></p><ul><li><p>类（Class）：对一类事物的描述，是抽象的、概念上的定义</p></li><li><p>对象（Object）：是实际存在的该类事物的每个个体，因而也称为实例（instance）</p></li></ul><p><strong>二者的关系</strong>：对象，是由类 new 出来的，派生出来的。</p><p><strong>“万事万物皆对象”</strong></p><ul><li><p>面向对象程序设计的重点是类的设计。设计类，就是设计类的成员</p></li><li><p>创建类的对象 &#x3D; 类的实例化 &#x3D; 实例化类</p></li><li><p><strong>匿名对象</strong>是指创建的对象，没显式的赋给一个变量名。匿名对象只能调用一次</p></li></ul><p><strong>4）类的成员</strong>：属性、方法、构造器；代码块、内部类</p><h4 id="7-2-类的属性（Field）"><a href="#7-2-类的属性（Field）" class="headerlink" title="7.2 类的属性（Field）"></a>7.2 类的属性（Field）</h4><p>对应类中的<strong>成员变量</strong>，属性 &#x3D; 成员变量 &#x3D; field &#x3D; 域、字段</p><p><strong>※ 属性与局部变量的对比</strong></p><p><strong>1）相同点</strong></p><ul><li><pre><code>    定义变量的**格式**：数据类型  变量名 = 变量值</code></pre></li><li><pre><code>    先声明，后使用</code></pre></li><li><pre><code>    变量都其对应的作用域</code></pre></li></ul><p><strong>2）不同点</strong></p><p>① 在类中声明的位置的不同</p><ul><li><pre><code>    属性：直接定义在类的一对 &#123;&#125; 内</code></pre></li><li><pre><code>    局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</code></pre></li></ul><p>② 关于权限修饰符的不同</p><ul><li><pre><code>    属性：可以在声明属性时，指明其权限，使用权限修饰符。</code></pre><ul><li><pre><code>        常用的权限修饰符：private、public、缺省、protected  ---&gt; 封装性</code></pre></li></ul></li><li><pre><code>    局部变量：不可以使用权限修饰符。</code></pre></li></ul><p>③ 默认初始化值的情况：</p><ul><li><pre><code>    属性：类的属性，根据其类型，都默认初始化值。</code></pre><ul><li><pre><code>        整型（byte、short、int、long：0）</code></pre></li><li><pre><code>        浮点型（float、double：0.0）</code></pre></li><li><pre><code>        字符型（char：0  （或&#39;\u0000&#39;））</code></pre></li><li><pre><code>        布尔型（boolean：false）</code></pre></li><li><pre><code>        引用数据类型（类、数组、接口：null）</code></pre></li></ul></li><li><pre><code>    局部变量：没默认初始化值。</code></pre><ul><li><pre><code>     意味着，在调用局部变量之前，一定要显式赋值。</code></pre></li><li><pre><code>     特别地：形参在调用时，我们赋值即可。</code></pre></li></ul></li></ul><p>④ 在内存中加载的位置：</p><ul><li><pre><code>    属性：加载到**堆**空间中（非static）</code></pre></li><li><pre><code>    局部变量：加载到**栈**空间</code></pre></li></ul><h4 id="7-3-类的方法（Method）"><a href="#7-3-类的方法（Method）" class="headerlink" title="7.3 类的方法（Method）"></a>7.3 类的方法（Method）</h4><p>描述类应该具的功能，方法 &#x3D; 成员方法 &#x3D; 函数 &#x3D; method</p><p><strong>方法的声明</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>1）权限修饰符</strong></p><ul><li><p>默认方法的权限修饰符先都使用 public</p></li><li><p>Java 规定的4种权限修饰符：private、public、缺省、protected（封装性再细说）</p></li></ul><p><strong>2）返回值类型</strong></p><ul><li><p>如果方法返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用 return 关键字来返回指定类型的变量或常量：“return 数据”。</p></li><li><p>如果方法没返回值，则方法声明时，使用 void 来表示。通常，没返回值的方法中，就不需要使用return.但是，如果使用的话，只能 “return;” 表示结束此方法的意思。</p></li></ul><p><strong>3）方法名</strong>：属于标识符，遵循标识符的规则和规范。（“见名知意”）</p><p>*<em>4） 形参列表</em>***：方法可以声明0个，1个，或多个形参。</p><ul><li><strong>格式</strong>：数据类型1 形参1, 数据类型2 形参2, …</li></ul><p>*<em>5）方法体</em>***：方法功能的体现。     </p><hr><p><strong>※ 方法的重载</strong></p><ul><li><p>在同一个类中，允许存在一个以上的<strong>同名方法</strong>，只要它们的参数个数或者参数类型不同即可</p></li><li><p><strong>“两同一不同”</strong></p><ol><li>同一个类、相同方法名</li><li>参数列表不同：参数个数不同，参数类型不同</li></ol></li><li><p>严格按照定义判断（两同一不同），跟方法的权限修饰符、返回值类型、形参变量名、方法体都没关系！</p></li></ul><p><strong>※ 可变个数形参的方法</strong></p><ol><li><p>可变个数形参的格式：数据类型 … 变量名</p></li><li><p>当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个，2个…</p></li><li><p>可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</p></li><li><p>可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存</p></li><li><p>可变个数形参在方法的形参中，必须声明在末尾</p></li><li><p>可变个数形参在方法的形参中，最多只能声明一个可变形参</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;show(String)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String ... strs)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;show(String ... strs)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; strs.length;i++)&#123;</span><br><span class="line">System.out.println(strs[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能与上一个方法同时存在</span></span><br><span class="line"><span class="comment">//public void show(String[] strs)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><p><strong>※ Java的值传递机制</strong></p><p>① 值传递规则</p><ul><li><p>如果变量是<strong>基本数据类型</strong>，此时赋值的是变量所保存的<strong>数据值</strong></p></li><li><p>如果变量是<strong>引用数据类型</strong>，此时赋值的是变量所保存的<strong>数据的地址值</strong></p></li></ul><p>② 形参和实参</p><ul><li><p>形参：方法定义时，声明的小括号内的参数</p></li><li><p>实参：方法调用时，实际传递给形参的数据</p></li></ul><p>③ Java 中参数传递机制：值传递</p><ul><li><p>如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值</p></li><li><p>如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值</p></li></ul><p><strong>※ 递归方法</strong>：一个方法体内调用自身</p><ul><li><p>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制</p></li><li><p>递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1：计算1-n之间所自然数的和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span> &#123;<span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n + getSum(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 例2：计算1-n之间所自然数的乘积:n!</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n * getSum1(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例3：已知一个数列：f(0) = 1,f(1) = 4,f(n+2)=2*f(n+1) + f(n),</span></span><br><span class="line"><span class="comment">//其中n是大于0的整数，求f(10)的值。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//return f(n + 2) - 2 * f(n + 1);</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>*f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//例4：斐波那契数列</span></span><br><span class="line"><span class="comment">//例5：汉诺塔问题</span></span><br><span class="line"><span class="comment">//例6：快排</span></span><br></pre></td></tr></table></figure><p><strong>※ 方法的重写</strong>（override 或 overwrite）：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作</p><ul><li>重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法</li><li>子类中的叫重写的方法，父类中的叫被重写的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符  返回值类型  方法名(形参列表) <span class="keyword">throws</span> 异常的类型&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法体</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>① 子类重写的方法的方法名和形参列表与父类被重写的方法的<strong>方法名和形参列表相同</strong></p><p>② 子类重写的方法的权限修饰符<strong>不小于</strong>父类被重写的方法的权限修饰符（特殊情况：子类不能重写父类中声明为 private 权限的方法）</p><p>③ 返回值类型</p><ul><li><p>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</p></li><li><p>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</p></li><li><p>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)</p></li></ul><p>④ 子类重写的方法抛出的异常类型<strong>不大于</strong>父类被重写的方法抛出的异常类型</p><p>⑤ 子类和父类中的同名同参数的方法要么都声明为非 static 的（考虑重写），要么都声明为 static 的（不是重写)。</p><hr><p><strong>面试题</strong></p><p><strong>区分方法的重写和重载？</strong>（① 二者的概念；② 重载和重写的具体规则；③ 重载：不表现为多态性；重写：表现为多态性。）</p><ul><li><strong>重载</strong>，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。所以，对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；而对于<strong>多态</strong>，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。 引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”</li></ul><h4 id="7-4-类的构造器（Constructor）"><a href="#7-4-类的构造器（Constructor）" class="headerlink" title="7.4 类的构造器（Constructor）"></a>7.4 类的构造器（Constructor）</h4><p>构造器（构造方法）的作用：① 创建对象；② 初始化对象的信息</p><ol><li><p>如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器</p></li><li><p>定义构造器的格式：<code>权限修饰符  类名(形参列表)&#123;&#125;</code></p></li><li><p>一个类中定义的多个构造器，彼此构成<strong>重载</strong></p></li><li><p>一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器</p></li><li><p>一个类中，至少会有一个构造器。</p></li></ol><p><strong>属性赋值的先后顺序</strong>：① 默认初始化；② 显式初始化；③ 构造器中初始化；④ 通过”对象.方法” 或 “对象.属性”的方式，赋值</p><p>所谓<strong>JavaBean</strong>，是指符合如下标准的 Java 类：① 类是公共的；② 一个无参的公共的构造器；③ 属性有对应的 get、set 方法</p><h4 id="7-5-封装性（Encapsulation）"><a href="#7-5-封装性（Encapsulation）" class="headerlink" title="7.5 封装性（Encapsulation）"></a>7.5 封装性（Encapsulation）</h4><p><strong>1）为什么要引入封装性？</strong></p><p>① 我们程序设计追求<strong>“高内聚，低耦合”</strong></p><ul><li><p>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉</p></li><li><p>低耦合 ：仅对外暴露少量的方法用于使用</p></li></ul><p>② 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想</p><p><strong>2）封装性思想具体的代码体现</strong></p><ul><li><p>体现一：将类的属性 xxx 私化（private），同时，提供公共的（public）方法来获取（getXxx）和设置（setXxx）此属性的值</p></li><li><p>体现二：不对外暴露的私有的方法</p></li><li><p>体现三：单例模式（将构造器私有化）</p></li><li><p>体现四：如果不希望类在包外被调用，可以将类设置为缺省的</p></li></ul><p><strong>3）Java 规定的四种权限修饰符</strong></p><p>① 权限从小到大顺序为：private &lt;  缺省 &lt; protected &lt; public</p><p>② 具体的修饰范围：</p><table><thead><tr><th align="center">修饰符</th><th align="center">类内部</th><th align="center">同一个包</th><th align="center">不同包的子类</th><th align="center">同一个工程</th></tr></thead><tbody><tr><td align="center">private</td><td align="center">√</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">（缺省）</td><td align="center">√</td><td align="center">√</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">protected</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center"></td></tr><tr><td align="center">public</td><td align="center">√</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr></tbody></table><p>③ 权限修饰符可用来修饰的结构</p><ul><li>4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类</li><li>修饰类的话，只能使用：缺省、public</li></ul><h4 id="7-6-继承性（Inheritance）"><a href="#7-6-继承性（Inheritance）" class="headerlink" title="7.6 继承性（Inheritance）"></a>7.6 继承性（Inheritance）</h4><p><strong>1）为什么要有类的继承性（继承性的好处）</strong></p><ol><li><p>减少了代码的冗余，提高了代码的复用性</p></li><li><p>便于功能的扩展</p></li><li><p>为之后多态性的使用，提供了前提</p></li></ol><p><strong>2）继承性的格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A:子类、派生类、subclass</span></span><br><span class="line"><span class="comment">// B:父类、超类、基类、superclass</span></span><br><span class="line"><span class="comment">// extends 关键字：延展、扩展</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>3）子类继承父类以后有哪些不同？</strong></p><ul><li><p>体现：一旦子类 A 继承父类 B 以后，子类 A 中就获取了父类 B 中声明的<strong>所有的</strong>属性和方法</p></li><li><p>特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已</p></li><li><p>子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。子类和父类的关系，不同于子集和集合的关系。（extends：延展、扩展）</p></li></ul><p><strong>4）Java 中继承性的说明</strong></p><ol><li><p>一个类可以被多个子类继承</p></li><li><p>Java 中类的单继承性，即一个类只能有一个（直接）父类</p></li><li><p>子父类是相对的概念</p></li><li><p>子类直接继承的父类，称为：直接父类；间接继承的父类称为：间接父类</p></li><li><p>子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法</p></li></ol><p><strong>5）java.lang.Object 类的理解</strong></p><ol><li><p>如果我们没显式的声明一个类的父类的话，则此类继承于 java.lang.Object 类</p></li><li><p>所有的 Java 类（除 java.lang.Object 类之外）都直接或间接的继承于 java.lang.Object 类</p></li><li><p>意味着，所有的 Java 类具有 java.lang.Object 类声明的功能</p></li></ol><h4 id="7-7-多态性（Polymorphism）"><a href="#7-7-多态性（Polymorphism）" class="headerlink" title="7.7 多态性（Polymorphism）"></a>7.7 多态性（Polymorphism）</h4><p>多态性可以理解为一个事物的多种形态，对象的<strong>多态性</strong>就是指<strong>父类的引用指向子类的对象</strong>（或子类的对象赋给父类的引用）</p><p><strong>1）多态性的使用 – 虚拟方法调用</strong></p><ul><li><p>有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法</p></li><li><p>总结：编译，看左边；运行，看右边</p></li><li><p><strong>注意点</strong>：对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</p></li><li><p>多态是编译时行为还是运行时行为？答：运行时行为</p></li></ul><p><strong>2）多态性的使用前提</strong>：① 类的继承关系 ；② 方法的重写</p><p><strong>3）向上转型</strong>：多态</p><p><strong>4）向下转型</strong></p><p>① 为什么使用向下转型</p><ul><li>有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。使用向下转型才能调用子类特的属性和方法</li></ul><p>② 如何实现向下转型</p><ul><li>使用强制类型转换符：()</li></ul><p><strong>使用时的注意点：</strong></p><ol><li><p>使用强转时，可能出现 ClassCastException 的异常</p></li><li><p>为了避免在向下转型时出现 ClassCastException 的异常，我们在向下转型之前，先进行 instanceof 的判断，一旦返回 true，就进行向下转型。如果返回false，不进行向下转型</p></li></ol><p><strong>5）instanceof 的使用</strong></p><ul><li><p>a instanceof A：<strong>判断对象 a 是否是类 A 的实例</strong>。如果是，返回 true；如果不是，返回 false</p></li><li><p>如果 a instanceof A 返回 true，则 a instanceof B 也返回 true。其中，类 B 是类 A 的父类</p></li><li><p>要求 a 所属的类与类 A <strong>必须</strong>是子类和父类的关系，否则编译错误</p></li></ul><hr><p><strong>面试题</strong></p><p>谈谈你对多态性的理解？</p><ul><li><p>实现代码的通用性</p></li><li><p>Object 类中定义的<code>public boolean equals(Object obj)&#123;&#125;</code></p></li><li><p>JDBC：使用java程序操作(获取数据库连接、CRUD)数据库(MySQL、Oracle、DB2、SQL Server)</p></li><li><p>抽象类、接口的使用肯定体现了多态性。（抽象类、接口不能实例化）</p></li></ul><h4 id="7-8-Object-类的使用"><a href="#7-8-Object-类的使用" class="headerlink" title="7.8 Object 类的使用"></a>7.8 Object 类的使用</h4><p><strong>1）java.lang.Object 类的说明</strong></p><ol><li><p>Object 类是所有 Java 类的根父类</p></li><li><p>如果在类的声明中未使用 extends 关键字指明其父类，则默认父类为 java.lang.Object 类 </p></li><li><p>Object 类中的功能（属性、方法）就具通用性</p><ul><li><strong>属性</strong>：无</li><li><strong>方法</strong>：equals()、toString() 、getClass()、hashCode() 、clone()、finalize()；wait() 、 notify()、notifyAll()</li></ul></li><li><p>Object类只声明了一个空参的构造器</p></li></ol><p><strong>2）equals() 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Object 类中 equals() 的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 说明：Object类中定义的equals()和==的作用是相同的：比较两个对象的地址值是否相同。即两个引用是否指向同一个对象实体</span></span><br></pre></td></tr></table></figure><ul><li><p>equals() 是一个方法，而非运算符</p></li><li><p>只能适用于引用数据类型</p></li><li><p>像 String、Date、File、包装类等都重写了 Object 类中的 equals() 方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同</p></li><li><p>通常情况下，我们自定义的类如果使用 equals() 的话，也通常是比较两个对象的”实体内容”是否相同。那么，我们就需要对 Object 类中的 equals() 进行重（重写的原则：比较两个对象的实体内容是否相同）</p></li></ul><p>**如何重写equals()**：开发中自动生成的</p><p><strong>回顾 &#x3D;&#x3D; 运算符的使用：</strong></p><ol><li><p>可以使用在基本数据类型变量和引用数据类型变量中</p></li><li><p>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）</p><p>如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</p><p><strong>注意： &#x3D;&#x3D; 符号使用时，必须保证符号左右两边的变量类型一致</strong></p></li></ol><p><strong>3）toString() 方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Object 类中 toString() 的定义</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>当我们输出一个对象的引用时，实际上就是调用当前对象的 toString() </li><li>像 String、Date、File、包装类等都重写了 Object 类中的 toString() 方法， 使得在调用对象的 toString() 时，返回”实体内容”信息</li><li>自定义类也可以重写 toString()方 法，当调用此方法时，返回对象的”实体内容”</li></ul><p>**如何重写toString()**：开发中如何实现：自动生成的</p><h4 id="7-9-代码块和内部类"><a href="#7-9-代码块和内部类" class="headerlink" title="7.9 代码块和内部类"></a>7.9 代码块和内部类</h4><p><strong>1）代码块</strong></p><ul><li><strong>作用</strong>：用来初始化类、对象的信息</li><li><strong>分类</strong>：代码块要是使用修饰符，只能使用 static，所以分为<strong>静态代码块</strong>和<strong>非静态代码块</strong></li></ul><p><strong>静态代码块</strong></p><ul><li><p>内部可以有输出语句</p></li><li><p>随着类的加载而执行,而且只执行一次</p></li><li><p>作用：初始化类的信息</p></li><li><p>如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</p></li><li><p><em>静态代码块的执行要优先于非静态代码块的执行</em></p></li><li><p><em>静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</em></p></li></ul><p><strong>非静态代码块</strong></p><ul><li><p>内部可以有输出语句</p></li><li><p>随着对象的创建而执行</p></li><li><p>每创建一个对象，就执行一次非静态代码块</p></li><li><p>作用：可以在创建对象时，对对象的属性等进行初始化</p></li><li><p>如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</p></li><li><p>非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</p></li></ul><p>实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序：<strong>由父及子，静态先行</strong></p><p>执行的先后顺序：①默认初始化；②显式初始化&#x2F;⑤在代码块中赋值；③构造器中初始化；④有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Root</span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Root的静态初始化块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Root的普通初始化块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Root</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;Root的无参数的构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Mid</span> <span class="keyword">extends</span> <span class="title class_">Root</span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Mid的静态初始化块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Mid的普通初始化块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Mid</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">super</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;Mid的无参数的构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Mid</span><span class="params">(String msg)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>();</span><br><span class="line">System.out.println(<span class="string">&quot;Mid的带参数构造器，其参数值：&quot;</span></span><br><span class="line">+ msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Leaf</span> <span class="keyword">extends</span> <span class="title class_">Mid</span>&#123;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Leaf的静态初始化块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Leaf的普通初始化块&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Leaf</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="built_in">super</span>(<span class="string">&quot;尚硅谷&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Leaf的构造器&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeafTest</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Leaf</span>(); </span><br><span class="line">System.out.println(<span class="string">&quot;================================&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Leaf</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Root的静态初始化块</span><br><span class="line">Mid的静态初始化块</span><br><span class="line">Leaf的静态初始化块</span><br><span class="line">Root的普通初始化块</span><br><span class="line">Root的无参数的构造器</span><br><span class="line">Mid的普通初始化块</span><br><span class="line">Mid的无参数的构造器</span><br><span class="line">Mid的带参数构造器，其参数值：尚硅谷</span><br><span class="line">Leaf的普通初始化块</span><br><span class="line">Leaf的构造器</span><br><span class="line">================================</span><br><span class="line">Root的普通初始化块</span><br><span class="line">Root的无参数的构造器</span><br><span class="line">Mid的普通初始化块</span><br><span class="line">Mid的无参数的构造器</span><br><span class="line">Mid的带参数构造器，其参数值：尚硅谷</span><br><span class="line">Leaf的普通初始化块</span><br><span class="line">Leaf的构造器</span><br></pre></td></tr></table></figure><p><strong>2）内部类</strong></p><ul><li><p><strong>定义</strong>：Java 中允许将一个类 A 声明在另一个类 B 中，则类 A 就是<strong>内部类</strong>，类 B 称为<strong>外部类</strong>。</p></li><li><p><strong>分类</strong>：<strong>成员内部类</strong>（静态、非静态 ）和 <strong>局部内部类</strong>(方法内、代码块内、构造器内)。</p></li><li><p>一方面，作为<strong>外部类的成员</strong>：① 调用外部类的结构；② 可以被 static 修饰；③ 可以被 4 种不同的权限修饰。另一方面，作为<strong>一个类</strong>：① 类内可以定义属性、方法、构造器等；② 可以被 final 修饰，表示此类不能被继承。言外之意，不使用 final，就可以被继承；③ 可以被 abstract 修饰。</p></li></ul><p><strong>成员内部类</strong></p><p>① 如何创建成员内部类的对象？(静态的 &amp; 非静态的)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建静态的 Dog 内部类的实例（静态的成员内部类）</span></span><br><span class="line">Person.<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>.Dog();</span><br><span class="line"><span class="comment">// 创建非静态的 Bird 内部类的实例（非静态的成员内部类）</span></span><br><span class="line"><span class="comment">// Person.Bird bird = new Person.Bird();//错误的</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">Person.<span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> p.<span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br></pre></td></tr></table></figure><p>② 如何在成员内部类中调用外部类的结构？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小明&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"><span class="comment">// 非静态成员内部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;杜鹃&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String name)</span>&#123;</span><br><span class="line">System.out.println(name);<span class="comment">// 方法的形参</span></span><br><span class="line">System.out.println(<span class="built_in">this</span>.name);<span class="comment">// 内部类的属性</span></span><br><span class="line">System.out.println(Person.<span class="built_in">this</span>.name);<span class="comment">// 外部类的属性</span></span><br><span class="line"><span class="comment">// Person.this.eat();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>局部内部类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个实现了Comparable 接口的类的对象</span></span><br><span class="line"><span class="keyword">public</span> Comparable <span class="title function_">getComparable</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建一个实现了Comparable接口的类:局部内部类</span></span><br><span class="line">    <span class="comment">// 方式一：</span></span><br><span class="line">    <span class="comment">//class MyComparable implements Comparable&#123;</span></span><br><span class="line">    <span class="comment">//@Override</span></span><br><span class="line">    <span class="comment">//public int compareTo(Object o) &#123;</span></span><br><span class="line">    <span class="comment">//return 0;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//return new MyComparable();</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//方式二：</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Comparable</span>()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：在局部内部类的<strong>方法</strong>中如果调用局部内部类所声明的<strong>方法</strong>中的<strong>局部变量</strong>的话，要求此局部变量声明为 final 的。</p><ul><li>jdk 7 及之前版本：要求此局部变量显式的声明为 final 的</li><li>jdk 8 及之后的版本：可以省略 final 的声明</li></ul><p><strong>总结</strong>：成员内部类和局部内部类，在编译以后，都会生成字节码文件</p><p><strong>格式</strong></p><ul><li><code>成员内部类：外部类$内部类名.class</code></li><li><code>局部内部类：外部类$数字 内部类名.class</code></li></ul><h4 id="7-9-关键字"><a href="#7-9-关键字" class="headerlink" title="7.9 关键字"></a>7.9 关键字</h4><h5 id="7-9-1-return"><a href="#7-9-1-return" class="headerlink" title="7.9.1 return"></a>7.9.1 return</h5><ul><li><p>使用范围：使用在方法体中</p></li><li><p>作用：</p><ul><li>结束方法</li><li>针对于返回值类型的方法，使用”return 数据”方法返回所要的数据</li></ul></li><li><p><strong>注意</strong>：return 关键字后面不可以声明执行语句</p></li></ul><h5 id="7-9-2-this"><a href="#7-9-2-this" class="headerlink" title="7.9.2 this"></a>7.9.2 this</h5><ul><li><p>this 理解为：<strong>当前对象</strong> 或 <strong>当前正在创建的对象</strong></p></li><li><p>可以调用的结构：属性、方法；构造器</p></li></ul><p><strong>this 调用属性、方法：</strong></p><ul><li>在类的方法中，我们可以使用<code>this.属性</code>或<code>this.方法</code>的方式，调用<strong>当前对象</strong>属性或方法。但是，通常情况下，我们都择省略<code>this.</code>。</li><li>特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用<code>this.变量</code>的方式，表明此变量是属性，而非形参</li></ul><p><strong>this 调用构造器：</strong></p><ul><li>在类的构造器中，我们可以使用<code>this.属性</code>或<code>this.方法</code>的方式，调用当前<strong>正在创建的对象</strong>属性或方法。但是，通常情况下，我们都择省略<code>this.</code>。</li><li>特殊情况下，如果构造器的形参和类的属性同名时，我们必须显式的使用<code>this.变量</code>的方式，表明此变量是属性，而非形参</li></ul><p><strong>※ 注意</strong></p><ul><li><p>我们在类的构造器中，可以显式的使用”this(形参列表)”方式，调用本类中指定的其他构造器</p></li><li><p>构造器中不能通过<code>this(形参列表)</code>方式调用自己</p></li><li><p>如果一个类中有n个构造器，则最多有 n - 1构造器中使用了<code>this(形参列表)</code></p></li><li><p>规定：<code>this(形参列表)</code>必须声明在当前构造器的<strong>首行</strong></p></li><li><p>构造器内部，<strong>最多只能声明一个</strong><code>this(形参列表)</code>，用来调用其他的构造器</p></li></ul><h5 id="7-9-3-package"><a href="#7-9-3-package" class="headerlink" title="7.9.3 package"></a>7.9.3 package</h5><ul><li><p>为了更好的实现项目中类的管理，提供包的概念</p></li><li><p>使用 package 声明类或接口所属的包，声明在源文件的首行</p></li><li><p>包，属于标识符，遵循标识符的命名规则、规范（xxxyyyzzz）、“见名知意”</p></li><li><p>每”.”一次，就代表一层文件目录。</p></li></ul><p><strong>举例：MVC设计模式</strong></p><p><img src="/.io//MVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" alt="MVC设计模式"></p><p><strong>JDK中的主要包介绍</strong></p><ol><li>java.lang：包含一些 Java 语言的核心类，如 String、Math、Integer、System 和 Thread，提供常用功能</li><li>java.net：包含执行与网络相关的操作的类和接口</li><li>java.io：包含能提供多种输入&#x2F;输出功能的类</li><li>java.uti：包含一些实用工具类，如定义系统特性、接口的集合框架类、使用与日期日历相关的函数。</li><li>java.text：包含了一些java格式化相关的类</li><li>java.sql：包含了 Java 进行 JDBC 数据库编程的相关类&#x2F;接口</li><li>java.awt：包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面（GUl）</li></ol><h5 id="7-9-4-import"><a href="#7-9-4-import" class="headerlink" title="7.9.4 import"></a>7.9.4 import</h5><ul><li><p>在源文件中显式的使用 import 结构导入指定包下的类、接口</p></li><li><p>声明在包的声明和类的声明之间</p></li><li><p>如果需要导入多个结构，则并列写出即可</p></li><li><p>可以使用 “xxx.*” 的方式，表示可以导入 xxx 包下的所结构</p></li><li><p>如果使用的类或接口是 java.lang 包下定义的，则可以省略 import 结构</p></li><li><p>如果使用的类或接口是本包下定义的，则可以省略import结构</p></li><li><p>如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示。</p></li><li><p>使用 “xxx.*” 方式表明可以调用 xxx 包下的所有结构。但是如果使用的是 xxx 子包下的结构，则仍需要显式导入</p></li><li><p><code>import static</code>：导入指定类或接口中的静态结构（属性或方法）</p></li></ul><h5 id="7-9-5-super"><a href="#7-9-5-super" class="headerlink" title="7.9.5 super"></a>7.9.5 super</h5><ul><li><p>super 关键字可以理解为：父类的</p></li><li><p><strong>可以用来调用的结构</strong>：属性、方法、构造器</p></li></ul><p><strong>super 调用属性、方法</strong></p><ul><li><p>我们可以在子类的方法或构造器中。通过使用”super.属性”或”super.方法”的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略”super.”</p></li><li><p>特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性</p></li><li><p>特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”super.方法”的方式，表明调用的是父类中被重写的方法</p></li></ul><p><strong>super 调用构造器</strong></p><ul><li><p>我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器</p></li><li><p>“super(形参列表)”的使用，必须声明在子类构造器的首行！</p></li><li><p>我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二选一，不能同时出现</p></li><li><p>在构造器的首行，没显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器：super()</p></li><li><p>在类的多个构造器中，至少一个类的构造器中使用了”super(形参列表)”，调用父类中的构造器</p></li></ul><p><strong>子类对象实例化全过程</strong></p><p>1）从结果上看：继承性</p><ul><li>子类继承父类以后，就获取了父类中声明的属性或方法。创建子类的对象，在堆空间中，就会加载所父类中声明的属性</li></ul><p>2）从过程上看</p><p>当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，……，直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑进行调用</p><blockquote><p>强调说明：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。</p></blockquote><h5 id="7-9-6-static"><a href="#7-9-6-static" class="headerlink" title="7.9.6 static"></a>7.9.6 static</h5><p><strong>可以用来修饰的结构</strong>：主要用来修饰类的内部结构（属性、方法、代码块、内部类）</p><p><strong>※ 属性</strong>按是否使用 static 修饰可分为： <strong>静态属性（类变量）</strong> 和<strong>非静态属性（实例变量）</strong></p><ul><li>类变量：我们创建了类的多个对象，多个对象共享同一个类变量。当通过某一个对象修改类变量时，会导致其他对象调用此类变量时，是修改过了的</li><li>实例变量：我们创建了类的多个对象，每个对象都独立的拥一套类中的实例变量。当修改其中一个对象中的实例变量时，不会导致其他对象中同样的实例变量的修改。</li></ul><hr><ul><li><p>静态属性随着类的加载而加载。可以通过”类.静态属性”的方式进行调用</p></li><li><p>静态属性的加载要早于对象的创建</p></li><li><p>由于类只会加载一次，则静态属性在内存中也只会存在一份：存在方法区的静态域中</p></li><li><p>静态属性举例：System.out; Math.PI;</p></li></ul><table><thead><tr><th align="center"></th><th align="center">类变量</th><th align="center">实例变量</th></tr></thead><tbody><tr><td align="center">类</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">对象</td><td align="center">√</td><td align="center">√</td></tr></tbody></table><p><strong>※ 静态方法（类方法）和非静态方法</strong></p><ul><li><p>静态方法随着类的加载而加载，可以通过”类.静态方法”的方式进行调用</p></li><li><p>静态方法中，只能调用静态的方法或属性</p></li><li><p>非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</p></li></ul><hr><ul><li>在静态的方法内，不能使用 this 关键字、super 关键字</li><li>关于静态属性和静态方法的使用，大家都从生命周期的角度去理解</li></ul><table><thead><tr><th align="center"></th><th align="center">静态方法</th><th align="center">非静态方法</th></tr></thead><tbody><tr><td align="center">类</td><td align="center">√</td><td align="center">×</td></tr><tr><td align="center">对象</td><td align="center">√</td><td align="center">√</td></tr></tbody></table><p><strong>如何判定属性和方法是否应该使用 static 关键字</strong></p><p>① 关于属性</p><ul><li><p>属性是可以被多个对象所共享的，不会随着对象的不同而不同的</p></li><li><p>类中的常量也常常声明为 static</p></li></ul><p>② 关于方法</p><ul><li><p>操作静态属性的方法，通常设置为 static 的</p></li><li><p>工具类中的方法，习惯上声明为 static 的。 比如：Math、Arrays、Collections</p></li></ul><p><strong>使用举例</strong></p><ul><li><p>举例一：Arrays、Math、Collections 等工具类</p></li><li><p>举例二：单例模式</p></li></ul><h5 id="7-9-7-final"><a href="#7-9-7-final" class="headerlink" title="7.9.7 final"></a>7.9.7 final</h5><p><strong>可以用来修饰结构</strong>：类、方法、变量</p><p><strong>final 用来修饰一个类</strong>：此类不能被其他类所继承。</p><ul><li>比如：String类、System类、StringBuffer类</li></ul><p><strong>final 用来修饰方法</strong>：表明此方法不可以被重写</p><ul><li>比如：Object 类中getClass();</li></ul><p><strong>final 用来修饰变量</strong>：此时的”变量”就称为是一个常量</p><ul><li><p>final 修饰属性：必须被赋值，可以考虑赋值的位置有显式初始化、代码块中初始化、构造器中初始化</p></li><li><p>final 修饰局部变量：尤其是使用 final 修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</p></li><li><p>static final 用来修饰属性：全局常量</p></li></ul><h5 id="7-9-8-abstract"><a href="#7-9-8-abstract" class="headerlink" title="7.9.8 abstract"></a>7.9.8 abstract</h5><p><strong>可以用来修饰结构</strong>：类、方法</p><p><strong>abstract修饰类：抽象类</strong></p><ul><li><p>此类<strong>不能实例化</strong></p></li><li><p>抽象类中<strong>一定有构造器</strong>，便于子类实例化时调用（涉及：子类对象实例化的全过程）</p></li><li><p>开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作（抽象类的使用前提：继承性）</p></li></ul><p><strong>abstract修饰方法：抽象方法</strong></p><ul><li><p>抽象方法只有方法的声明，没方法体</p></li><li><p>包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</p></li><li><p>若子类重写了父类中的所的抽象方法后，此子类方可实例化</p></li><li><p>若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</p></li></ul><p><strong>注意点</strong></p><ul><li><p>abstract 不能用来修饰：属性、构造器等结构</p></li><li><p>abstract 不能用来修饰私有方法、静态方法、final 的方法、final 的类</p></li></ul><h5 id="7-9-9-interface"><a href="#7-9-9-interface" class="headerlink" title="7.9.9 interface"></a>7.9.9 interface</h5><ul><li><p>接口使用 <code>interface</code> 来定义</p></li><li><p>Java中，接口和类是<strong>并列</strong>的两个结构</p></li></ul><p>如何<strong>定义接口</strong>：定义接口中的成员</p><ol><li>JDK 7及以前：只能定义全局常量和抽象方法<ul><li>全局常量：public static final 的。但是书写时，可以省略不写</li><li>抽象方法：public abstract 的</li></ul></li><li>JDK 8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略）</li></ol><hr><ol><li><p>接口中不能定义构造器的！意味着接口不可以实例化</p></li><li><p>Java 开发中，接口通过让类去实现（implements）的方式来使用</p><ul><li>如果实现类覆盖了接口中的所抽象方法，则此实现类就可以实例化</li><li>如果实现类没覆盖接口中所的抽象方法，则此实现类仍为一个抽象类</li></ul></li><li><p>Java类可以实现多个接口（弥补了Java单继承性的局限性）</p><ul><li>格式：<code>class AA extends BB implements CC,DD,EE</code></li></ul></li><li><p>接口与接口之间可以继承，而且可以多继承</p></li><li><p>接口的具体使用，体现多态性</p></li><li><p>接口，实际上可以看做是一种规范</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferData</span><span class="params">(USB usb)</span>&#123;<span class="comment">//USB usb = new Flash();</span></span><br><span class="line">usb.start();</span><br><span class="line">System.out.println(<span class="string">&quot;具体传输数据的细节&quot;</span>);</span><br><span class="line">usb.stop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span>&#123;</span><br><span class="line"><span class="comment">//常量：定义了长、宽、最大最小的传输速度等</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flash</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;U盘开启工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;U盘结束工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打印机开启工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打印机结束工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>接口使用上也满足多态性</p></li><li><p>接口，实际上就是定义了一种规范</p></li><li><p>开发中，体会面向接口编程！</p></li></ul><p><img src="/.io//%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B.png" alt="image-20200910163721358"></p><p>​                                                    我们在应用程序中，调用的结构都是 JDBC 中定义的接口，不会出现具体某一个数据库厂商的 API</p><p><strong>Java8 中关于接口的新规范</strong></p><ol><li><p>接口中定义的静态方法，只能通过接口来调用</p></li><li><p>通过实现类的对象，可以调用接口中的默认方法</p><ul><li>如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</li></ul></li><li><p>如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。（<strong>类优先原则</strong>）</p></li><li><p>如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么在实现类没重写此方法的情况下，报错。（ <strong>接口冲突</strong>）这就需要我们必须在实现类中重写此方法</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在子类（或实现类）的方法中调用父类、接口中被重写的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>&#123;</span><br><span class="line">    method3();<span class="comment">//调用自己定义的重写的方法</span></span><br><span class="line">    <span class="built_in">super</span>.method3();<span class="comment">//调用的是父类中声明的</span></span><br><span class="line">    <span class="comment">//调用接口中的默认方法</span></span><br><span class="line">    CompareA.<span class="built_in">super</span>.method3();</span><br><span class="line">    CompareB.<span class="built_in">super</span>.method3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>面试题</strong></p><p>抽象类和接口的异同？</p><ul><li><p>相同点：不能实例化；都可以包含抽象方法的</p></li><li><p>不同点：</p><ul><li>把抽象类和接口（Java7，Java8，Java9）的定义、内部结构解释说明</li><li>类：单继承性    接口：多继承      类与接口：多实现</li></ul></li></ul><h4 id="7-10-其他"><a href="#7-10-其他" class="headerlink" title="7.10 其他"></a>7.10 其他</h4><p><strong>1）Java 中的 JUnit 单元测试</strong></p><ol><li><p>在当前工程 - 右键选择：build path - add libraries - JUnit 4 - 下一步</p></li><li><p>创建 Java 类，进行单元测试。</p><ul><li>此时的 Java 类要求：① 此类是 public 的  ② 此类提供公共的无参的构造器</li></ul></li><li><p>此类中声明单元测试方法</p><ul><li>此时的单元测试方法：方法的权限是 public，没返回值，没形参</li></ul></li><li><p>此单元测试方法上需要声明注解：@Test，并在单元测试类中导入：import org.junit.Test;</p></li><li><p>声明好单元测试方法以后，就可以在方法体内测试相关的代码。</p></li><li><p>写完代码以后，左键双击单元测试方法名，右键：run as - JUnit Test</p></li></ol><hr><ul><li>如果执行结果没任何异常：绿条</li><li>如果执行结果出现异常：红条</li></ul><p><strong>2）包装类的使用</strong></p><ul><li>为了使基本数据类型的变量具有类的特征，引入包装类。</li></ul><table><thead><tr><th align="center">基本数据类型</th><th align="center">包装类</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">Byte</td></tr><tr><td align="center">short</td><td align="center">Short</td></tr><tr><td align="center"><strong>int</strong></td><td align="center"><strong>Integer</strong></td></tr><tr><td align="center">long</td><td align="center">Long</td></tr><tr><td align="center">float</td><td align="center">Float</td></tr><tr><td align="center">double</td><td align="center">Double</td></tr><tr><td align="center">boolean</td><td align="center">Boolean</td></tr><tr><td align="center"><strong>char</strong></td><td align="center"><strong>Character</strong></td></tr></tbody></table><ul><li>Number 类为 Byte、Short、Integer、Long、Float、Double 类的父类</li></ul><p><strong>基本数据类型、包装类、String 类型间的转换</strong></p><p><img src="/.io//%E7%B1%BB%E5%9E%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png" alt="类型间的转换"></p><ul><li><code>基本数据类型&lt;---&gt;包装类</code>：JDK 5.0 新特性：自动装箱 与 自动拆箱</li><li><code>基本数据类型、包装类 --&gt; String</code>：调用 String 重载的 valueOf(Xxx xxx)</li><li><code>String --&gt; 基本数据类型、包装类</code>：调用包装类的 parseXxx(String s)</li><li><strong>注意</strong>：转换时，可能会报 NumberFormatException</li></ul><p><strong>2）设计模式</strong>（这里介绍了单例模式、模板方法模式、代理模式和工厂模式）</p><ul><li><strong>设计模式</strong>是<strong>在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式</strong> 。 设计模免去我们自己再思考和摸索 。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。“套路”</li><li><strong>常用的设计模式</strong><ul><li><strong>创建型模式</strong>，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式</li><li><strong>结构型模式</strong>，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式</li><li><strong>行为型模式</strong>，共11种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</li></ul></li></ul><p><strong>① 单例模式</strong>：所谓<strong>类的单例设计模式</strong>，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line"><span class="comment">//1.私化类的构造器</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.内部创建类的对象</span></span><br><span class="line"><span class="comment">//4.要求此对象也必须声明为静态的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line"><span class="comment">//3.提供公共的静态的方法，返回类的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式2：使用了静态代码块</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line"><span class="comment">//1.私化类的构造器</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Order</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line"><span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Order</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line"><span class="comment">//1.私化类的构造器</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Order</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line"><span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Order</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>两种方式的对比</strong></p><ul><li>饿汉式    <ul><li>坏处：对象加载时间过长。</li><li>好处：饿汉式是线程安全的</li></ul></li><li>懒汉式<ul><li>好处：延迟对象的创建。</li><li>目前的写法坏处：线程不安全。—&gt;到多线程内容时，再修改</li></ul></li></ul><p><strong>② 模板方法模式</strong>：在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span>&#123;</span><br><span class="line"><span class="comment">// 计算某段代码执行所需要花费的时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">spendTime</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="built_in">this</span>.code();<span class="comment">// 不确定的部分、易变的部分</span></span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubTemplate</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= <span class="number">1000</span>;i++)&#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;j &lt;= Math.sqrt(i);j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">isFlag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用场景</strong> – 模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有：</p><ul><li><p>数据库访问的封装</p></li><li><p>Junit 单元测试</p></li><li><p>JavaWeb 的 Servlet 中关于 doGet&#x2F;doPost 方法调用</p></li><li><p>Hibernate 中模板程序</p></li><li><p>Spring 中 JDBCTemlate、Hibernate Template 等</p></li></ul><p><strong>③ 代理模式</strong>是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">NetWork</span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> <span class="keyword">implements</span> <span class="title class_">NetWork</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;真实的服务器访问网络&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyServer</span> <span class="keyword">implements</span> <span class="title class_">NetWork</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> NetWork work;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ProxyServer</span><span class="params">(NetWork work)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.work = work;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;联网之前的检查工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span> &#123;</span><br><span class="line">check();</span><br><span class="line"></span><br><span class="line">work.browse();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>应用场景</strong></p><ul><li><p>安全代理：屏蔽对真实角色的直接访问</p></li><li><p>远程代理：通过代理类处理远程方法调用（RMl）</p></li><li><p>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</p></li><li><p>比如：你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有 100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用 proxy 来进行大图片的打开。</p></li></ul><p><strong>分类</strong></p><ul><li><p>静态代理（静态定义代理类）</p></li><li><p>动态代理（动态生成代理类），JDK 自带的动态代理，需要反射等知识</p></li></ul><p><strong>④ 工厂模式</strong>：实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的</p><ul><li>简单工厂模式：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）</li><li>工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品)</li><li>抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族)</li></ul><h3 id="第8章-异常处理"><a href="#第8章-异常处理" class="headerlink" title="第8章 异常处理"></a>第8章 异常处理</h3><p><strong>知识点</strong>：异常的体系结构、异常处理、手动抛出异常、自定义异常类</p><h4 id="8-1-异常的体系结构"><a href="#8-1-异常的体系结构" class="headerlink" title="8.1 异常的体系结构"></a>8.1 异常的体系结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Throwable</span><br><span class="line"> |-----java.lang.Error: 一般不编写针对性的代码进行处理</span><br><span class="line"> |-----java.lang.Exception: 可以进行异常的处理</span><br><span class="line">|------编译时异常(checked)</span><br><span class="line">|------运行时异常(unchecked, RuntimeException)</span><br></pre></td></tr></table></figure><p><strong>1）分类</strong></p><p>从程序执行过程看分为<strong>编译时异常</strong>和<strong>运行时异常</strong></p><ul><li><p>编译时异常：执行<code>javac.exe</code>命名时，可能出现的异常</p></li><li><p>运行时异常：执行<code>java.exe</code>命名时，出现的异常</p></li></ul><p><strong>2）常见的异常类型</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NullPointerException 空指针异常</span><br><span class="line">ArrayIndexOutOfBoundsException 数组角标越界异常</span><br><span class="line">ClassCastException 类型转换异常</span><br><span class="line">NumberFormatException 数字格式异常</span><br><span class="line">InputMismatchException 输入类型不匹配异常</span><br><span class="line">ArithmeticException 算数异常</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常见的异常类型，请举例说明：</span></span><br><span class="line"><span class="comment">//******************以下是运行时异常***************************</span></span><br><span class="line"><span class="comment">// ArithmeticException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">System.out.println(a / b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// InputMismatchException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">System.out.println(score);</span><br><span class="line"></span><br><span class="line">scanner.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//NumberFormatException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//ClassCastException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)obj;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">//int[] arr = new int[10];</span></span><br><span class="line"><span class="comment">//System.out.println(arr[10]);</span></span><br><span class="line"><span class="comment">//StringIndexOutOfBoundsException</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str.charAt(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//NullPointerException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int[] arr = null;</span></span><br><span class="line"><span class="comment">//System.out.println(arr[3]);</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">str = <span class="literal">null</span>;</span><br><span class="line">System.out.println(str.charAt(<span class="number">0</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//******************以下是编译时异常***************************</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//File file = new File(&quot;hello.txt&quot;);</span></span><br><span class="line"><span class="comment">//FileInputStream fis = new FileInputStream(file);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//int data = fis.read();</span></span><br><span class="line"><span class="comment">//while(data != -1)&#123;</span></span><br><span class="line"><span class="comment">//System.out.print((char)data);</span></span><br><span class="line"><span class="comment">//data = fis.read();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//fis.close();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-2-异常处理"><a href="#8-2-异常处理" class="headerlink" title="8.2 异常处理"></a>8.2 异常处理</h4><p><strong>1）Java异常处理的抓抛模型</strong></p><p><strong>过程一：”抛”</strong></p><ul><li><p>程序在正常执行的过程中，<strong>一旦</strong>出现异常，就会在异常代码处<strong>生成一个对应异常类的对象</strong>，并将此对象抛出。<strong>一旦</strong>抛出对象以后，其后的代码就不再执行</p></li><li><p>关于异常对象的产生：</p><ul><li>系统自动生成的异常对象</li><li>手动的生成一个异常对象，并抛出（throw）</li></ul></li></ul><p><strong>过程二：”抓”</strong></p><ul><li>可以理解为异常的处理方式：<ol><li>try-catch-finally  </li><li>throws</li></ol></li></ul><p><strong>2）异常处理方式一</strong>：try-catch-finally</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 语法格式</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="comment">//可能出现异常的代码</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的方式1</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的方式2</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)&#123;</span><br><span class="line">    <span class="comment">//处理异常的方式3</span></span><br><span class="line">&#125;</span><br><span class="line">....</span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line">    <span class="comment">//一定会执行的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>finally</code> 是可选的。</p></li><li><p>使用 <code>try</code> 将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去 <code>catch</code> 中进行匹配</p></li><li><p>一旦 <code>try</code> 中的异常对象匹配到某一个 <code>catch</code> 时，就进入 <code>catch</code> 中进行异常的处理。一旦处理完成，就跳出当前的 <code>try-catch</code> 结构（在没写 <code>finally</code> 的情况），继续执行其后的代码</p></li><li><p><code>catch</code> 中的异常类型如果没子父类关系，则谁声明在上，谁声明在下无所谓；<code>catch</code> 中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，将会报错</p></li><li><p>常用的异常对象处理的方式：① String  getMessage()；② printStackTrace()</p></li><li><p>在 <code>try</code> 结构中声明的变量，再出了 <code>try</code> 结构以后，就不能再被调用</p></li><li><p><code>try-catch-finally</code> 结构可以嵌套</p></li></ul><p><strong>总结</strong></p><p><strong>如何看待代码中的编译时异常和运行时异常？</strong></p><ul><li><p>使用 <code>try-catch-finally</code> 处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用 <code>try-catch-finally</code> 将一个编译时可能出现的异常，延迟到运行时出现。</p></li><li><p>开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写 <code>try-catch-finally</code> 了。针对于编译时异常，我们一定要考虑异常的处理。</p></li></ul><p><strong>finally 的再说明</strong></p><ul><li><code>finally</code>是可选的</li><li><code>finally</code> 中声明的是一定会被执行的代码。即使 <code>catch</code> 中又出现异常了，<code>try</code> 中 <code>return</code> 语句，<code>catch</code> 中 <code>return</code> 语句等情况</li><li>像数据库连接、输入输出流、网络编程 Socket 等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在 <code>finally</code> 中</li></ul><hr><p><strong>面试题</strong></p><p>结构相似的：</p><ol><li>final、finally、finalize三者的区别？<ul><li>final 是一个修饰符，用于修饰类、方法或者变量。修饰类时，该类不能被继承；修饰方法时，该方法不能被重写；修饰变量时，该变量变为常量，不能二次赋值；修饰静态变量时，必须在声明时同时赋值（显示赋值或者构造器赋值）。不能修饰抽象类和接口。</li><li>finally 只能用于 try-catch-finally 结构。finally 语句块中的语句是一定会被执行的，并且会在 return，continue，break 关键字之前执行。在数据库连接、处理输入输出流时，一般都在 finally 中写释放资源的代码。</li><li>finalize 是一个方法，属于 java.lang.Object 类。这个方法由 System.gc() 启动，该对象被回收的时候被调用。一个对象的 finalize() 方法只会被调用一次，而且 finalize() 被调用不意味着 GC 会立即回收该对象</li></ul></li><li>throw 和 throws<ul><li>throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内</li><li>throws 属于异常处理的一种方式，声明在方法的声明处</li></ul></li><li>Collection 和 Collections</li><li>String 、StringBuffer、StringBuilder</li><li>ArrayList 、 LinkedList</li><li>HashMap 、LinkedHashMap</li><li>重写、重载</li></ol><p>结构不相似的：</p><ol><li>抽象类、接口</li><li>&#x3D;&#x3D; 、 equals()</li><li>sleep()、wait()</li></ol><p><strong>3）异常处理方式二</strong></p><ul><li><p>“throws + 异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型</p></li><li><p>一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足 throws 后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！</p></li></ul><p><strong>对比两种处理方式</strong></p><ul><li><p>try-catch-finally：真正的将异常给处理掉了</p></li><li><p>throws 的方式只是将异常抛给了方法的调用者。并没真正将异常处理掉</p></li></ul><p><strong>体会开发中应该如何选择两种处理方式？</strong></p><ul><li><p>如果父类中被重写的方法没使用 throws 方式处理异常，则子类重写的方法也不能使用 throws，意味着如果子类重写的方法中异常，必须使用 try-catch-finally 方式处理</p></li><li><p>执行的方法 a 中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用 throws 的方式进行处理。而执行的方法 a 可以考虑使用 try-catch-finally 方式进行处理</p></li></ul><blockquote><p>方法重写的规则之一：子类重写的方法抛出的异常类型<strong>不大于</strong>父类被重写的方法抛出的异常类型</p></blockquote><h4 id="8-3-手动抛出异常"><a href="#8-3-手动抛出异常" class="headerlink" title="8.3 手动抛出异常"></a>8.3 手动抛出异常</h4><p>在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的 throw 一个异常类的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">regist</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">this</span>.id = id;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//手动抛出异常对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//throw new RuntimeException(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line"><span class="comment">//throw new Exception(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;不能输入负数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-4-自定义异常类"><a href="#8-4-自定义异常类" class="headerlink" title="8.4 自定义异常类"></a>8.4 自定义异常类</h4><ol><li><p>继承于现的异常结构：RuntimeException 、Exception</p></li><li><p>提供全局常量：serialVersionUID</p></li><li><p>提供重载的构造器</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">7034897193246939L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span>&#123;</span><br><span class="line"><span class="built_in">super</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第二部分-Java-高级编程"><a href="#第二部分-Java-高级编程" class="headerlink" title="第二部分 Java 高级编程"></a>第二部分 Java 高级编程</h2><h3 id="第9章-多线程"><a href="#第9章-多线程" class="headerlink" title="第9章 多线程"></a>第9章 多线程</h3><h4 id="9-1-基本概念"><a href="#9-1-基本概念" class="headerlink" title="9.1 基本概念"></a>9.1 基本概念</h4><ul><li><p><strong>程序（Program）</strong>：为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码。</p></li><li><p><strong>进程（Process）</strong>：程序的一次执行过程，或是正在运行的一个程序。（<strong>进程作为资源分配的单位</strong>，系统在运行时会为每个进程分配不同的内存区域）</p></li><li><p><strong>线程（Thread）</strong>：进程可进一步细化为线程，是一个程序内部的一条执行路径。（线程作为调度和执行的单位，每个线程拥独立的运行栈和程序计数器（PC），线程切换的开销小）</p></li><li><p><strong>并行（Parallelism）</strong>：多个 CPU 同时执行多个任务。比如：多个人同时做不同的事。</p></li><li><p><strong>并发（Concurrency）</strong>：一个 CPU（采用时间片）同时执行多个任务。比如：秒杀、多个人做同一件事。</p></li></ul><h4 id="9-2-创建多线程的四种方式"><a href="#9-2-创建多线程的四种方式" class="headerlink" title="9.2 创建多线程的四种方式"></a>9.2 创建多线程的四种方式</h4><h5 id="9-2-1-继承-Thread-类"><a href="#9-2-1-继承-Thread-类" class="headerlink" title="9.2.1 继承 Thread 类"></a>9.2.1 继承 Thread 类</h5><ol><li>创建一个继承于 Thread 类的子类</li><li>重写 Thread 类的 run()，并将此线程执行的操作声明在 run() 中</li><li>创建 Thread 类的子类的对象</li><li>通过此对象调用 start()：① 启动当前线程 ② 调用当前线程的 run()<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个继承于Thread类的子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 重写Thread类的run() --&gt; 将此线程执行的操作声明在run()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewThread_1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 创建Thread类的子类的对象</span></span><br><span class="line">        <span class="type">MyThread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">// 4. 通过此对象调用start()：①启动当前线程 ② 调用当前线程的run()</span></span><br><span class="line">        myThread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>启动一个线程，必须调用 start()，不能调用 run() 的方式启动线程。</p><p>如果再启动一个线程，必须重新创建一个Thread 子类的对象，调用此对象的 start()。</p></blockquote><h5 id="9-2-2-实现-Runnable-接口"><a href="#9-2-2-实现-Runnable-接口" class="headerlink" title="9.2.2 实现 Runnable 接口"></a>9.2.2 实现 Runnable 接口</h5><ol><li>创建一个实现了 Runnable 接口的类。</li><li>实现类去实现 Runnable 中的抽象方法 run()。</li><li>创建实现类的对象。</li><li>将此对象作为参数传递到 Thread 类的构造器中，创建 Thread 类的对象。</li><li>通过 Thread 类的对象调用 start()。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 创建一个实现了Runnable接口的类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HelloThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="comment">// 2. 实现类去实现Runnable中的抽象方法：run()</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NewThread_2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3. 创建实现类的对象</span></span><br><span class="line">        <span class="type">HelloThread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HelloThread</span>();</span><br><span class="line">        <span class="comment">// 4. 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(thread);</span><br><span class="line">        <span class="comment">// 5. 通过Thread类的对象调用start()</span></span><br><span class="line">        thread1.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>两种方式的对比</strong></p><p>开发中：优先选择<strong>实现 Runnable 接口</strong>的方式</p><p>原因：① 实现的方式没类的单继承性的局限性</p><p>​           ② 实现的方式更适合来处理多个线程共享数据的情况。</p><p>联系：public class Thread implements Runnable</p><p>相同点：两种方式都需要重写 run()，将线程要执行的逻辑声明在 run() 中。</p><p>​              目前两种方式，要想启动线程，都是调用的 Thread 类中的 start()。</p></blockquote><h5 id="9-2-3-实现-Callable-接口-（JDK-5-0-新增）"><a href="#9-2-3-实现-Callable-接口-（JDK-5-0-新增）" class="headerlink" title="9.2.3 实现 Callable 接口 （JDK 5.0 新增）"></a>9.2.3 实现 Callable 接口 （JDK 5.0 新增）</h5><ol><li>创建一个实现 Callable 的实现类。</li><li>实现 call() 方法，将此线程需要执行的操作声明在 call() 中。</li><li>创建 Callable 接口实现类的对象。</li><li>将此 Callable 接口实现类的对象作为传递到 FutureTask 构造器中，创建 FutureTask 的对象。</li><li>将 FutureTask 的对象作为参数传递到 Thread 类的构造器中，创建 Thread 对象，并调用 start()。</li><li>获取 Callable 中 call() 方法的返回值。</li></ol><p>![FutureTask](C:\Dvenotes=&#x3D; Java 学习路线  &#x3D;&#x3D;\image\FutureTask.png)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * FutureTask 类的构造器方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Creates a &#123;<span class="doctag">@code</span> FutureTask&#125; that will, upon running, execute the given &#123;<span class="doctag">@code</span> Callable&#125;.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>  callable the callable task</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> NullPointerException if the callable is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="literal">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NullPointerException</span>();</span><br><span class="line">    <span class="built_in">this</span>.callable = callable;</span><br><span class="line">    <span class="built_in">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建一个实现Callable的实现类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumThread</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&#123;</span><br><span class="line">    <span class="comment">// 2.实现call方法，将此线程需要执行的操作声明在call()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(i);</span><br><span class="line">                sum += i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadNew</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 3.创建Callable接口实现类的对象</span></span><br><span class="line">        <span class="type">NumThread</span> <span class="variable">numThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumThread</span>();</span><br><span class="line">        <span class="comment">// 4.将此Callable接口实现类的对象作为传递到FutureTask构造器中，创建FutureTask的对象</span></span><br><span class="line">        <span class="type">FutureTask</span> <span class="variable">futureTask</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FutureTask</span>(numThread);</span><br><span class="line">        <span class="comment">// 5.将FutureTask的对象作为参数传递到Thread类的构造器中，创建Thread对象，并调用start()</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(futureTask).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 6.获取Callable中call方法的返回值</span></span><br><span class="line">            <span class="comment">// get()返回值即为FutureTask构造器参数Callable实现类重写的call()的返回值。</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">sum</span> <span class="operator">=</span> futureTask.get();</span><br><span class="line">            System.out.println(<span class="string">&quot;总和为：&quot;</span> + sum);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如何理解实现 Callable 接口的方式创建多线程比实现 Runnable 接口创建多线程方式强大？</strong></p><ol><li>call() 可以返回值的。</li><li>call() 可以抛出异常，被外面的操作捕获，获取异常的信息。</li><li>Callable 是支持泛型的。</li></ol><h5 id="9-2-4-使用线程池（JDK-5-0-新增）"><a href="#9-2-4-使用线程池（JDK-5-0-新增）" class="headerlink" title="9.2.4 使用线程池（JDK 5.0 新增）"></a>9.2.4 使用线程池（JDK 5.0 新增）</h5><ol><li>提供指定线程数量的线程池。</li><li>执行指定的线程的操作。需要提供实现 Runnable 接口或 Callable 接口实现类的对象。</li><li>关闭连接池。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> == <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumberThread1</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt;= <span class="number">100</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;: &quot;</span> + i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadPool</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//1. 提供指定线程数量的线程池</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">service</span> <span class="operator">=</span> Executors.newFixedThreadPool(<span class="number">10</span>);</span><br><span class="line">        <span class="type">ThreadPoolExecutor</span> <span class="variable">service1</span> <span class="operator">=</span> (ThreadPoolExecutor) service;</span><br><span class="line">        <span class="comment">//设置线程池的属性</span></span><br><span class="line"><span class="comment">//        System.out.println(service.getClass());</span></span><br><span class="line"><span class="comment">//        service1.setCorePoolSize(15);</span></span><br><span class="line"><span class="comment">//        service1.setKeepAliveTime();</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.执行指定的线程的操作。需要提供实现Runnable接口或Callable接口实现类的对象</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line">        service.execute(<span class="keyword">new</span> <span class="title class_">NumberThread1</span>());<span class="comment">//适合适用于Runnable</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        service.submit(Callable callable);//适合适用于Callable</span></span><br><span class="line">        <span class="comment">//3.关闭连接池</span></span><br><span class="line">        service.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>好处</strong></p><ol><li>提高响应速度（减少了创建新线程的时间）</li><li>降低资源消耗（重复利用线程池中线程，不需要每次都创建）</li><li>便于线程管理<ul><li><code>corePoolSize</code>：核心池的大小</li><li><code>maximumPoolSize</code>：最大线程数</li><li><code>keepAliveTime</code>：线程没任务时最多保持多长时间后会终止</li></ul></li></ol><hr><p><strong>面试题</strong></p><ul><li>Java 中多线程的创建有几种方式？<strong>四种</strong>。</li></ul><h4 id="9-3-Thread-类中的常用方法"><a href="#9-3-Thread-类中的常用方法" class="headerlink" title="9.3 Thread 类中的常用方法"></a>9.3 Thread 类中的常用方法</h4><ul><li><p><code>start()</code>：启动当前线程；调用当前线程的 run()</p></li><li><p><code>run()</code>： 通常需要重写 Thread 类中的此方法，将创建的线程要执行的操作声明在此方法中</p></li><li><p><code>currentThread()</code>：静态方法，返回执行当前代码的线程</p></li><li><p><code>getName()</code>：获取当前线程的名字</p></li><li><p><code>setName()</code>：设置当前线程的名字</p></li><li><p><code>yield()</code>：线程让步，释放当前 CPU 的执行权</p></li><li><p><code>join()</code>：在线程 a 中调用线程 b 的 join()，此时线程 a 就进入阻塞状态，直到线程 b 完全执行完以后，线程 a 才结束阻塞状态。</p></li><li><p><del><code>stop()</code>：已过时。当执行此方法时，强制结束当前线程。</del></p></li><li><p><code>sleep(long millitime)</code>：让当前线程“睡眠”指定的 millitime 毫秒。在指定的 millitime 毫秒时间内，当前线程是阻塞状态。</p></li><li><p><code>isAlive()</code>：判断当前线程是否存活</p></li></ul><hr><ol><li><p><strong>线程的优先级</strong></p><ul><li>MAX_PRIORITY：10</li><li>MIN _PRIORITY：1</li><li>NORM_PRIORITY：5  （默认优先级）</li></ul></li><li><p><strong>如何获取和设置当前线程的优先级</strong></p><ul><li><code>getPriority()</code>：获取线程的优先级</li><li><code>setPriority(int p)</code>：设置线程的优先级</li></ul><p><strong>说明</strong>：高优先级的线程要抢占低优先级线程 CPU 的执行权。但是只是<strong>从概率上</strong>讲，高优先级的线程高概率的情况下被执行。并不意味着只当高优先级的线程执行完以后，低优先级的线程才执行。</p><p>线程通信：<code>wait()</code> &#x2F; <code>notify()</code> &#x2F; <code>notifyAll()</code>：:此三个方法定义在 Object 类中的。</p></li><li><p><strong>线程的分类</strong>：一种是<strong>守护线程</strong>，一种是<strong>用户线程</strong>。</p></li></ol><h4 id="9-4-线程的生命周期"><a href="#9-4-线程的生命周期" class="headerlink" title="9.4 线程的生命周期"></a>9.4 线程的生命周期</h4><p><img src="/.io//image%5C%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png" alt="线程的生命周期"></p><p><strong>说明</strong></p><ol><li><p>生命周期关注两个概念：状态、相应的方法</p></li><li><p>关注：<code>状态 a --&gt; 状态 b</code>哪些方法执行了（回调方法）；某个方法主动调用使<code>状态 a--&gt;状态 b</code></p></li><li><p>阻塞：临时状态，不可以作为最终状态；死亡：最终状态。</p></li></ol><h4 id="9-5-线程的同步机制"><a href="#9-5-线程的同步机制" class="headerlink" title="9.5 线程的同步机制"></a>9.5 线程的同步机制</h4><p>在 Java 中，我们通过<strong>同步机制</strong>，来解决线程的安全问题。</p><h5 id="9-5-1-同步代码块"><a href="#9-5-1-同步代码块" class="headerlink" title="9.5.1 同步代码块"></a>9.5.1 同步代码块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(同步监视器)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要被同步的代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>说明</strong></p><ol><li>操作共享数据的代码，即为需要被同步的代码。不能包含代码多了，也不能包含代码少了。</li><li>共享数据：多个线程共同操作的变量。</li><li>同步监视器，俗称：锁。任何一个类的对象，都可以充当锁。</li></ol><p>要求：多个线程必须要共用同一把锁。</p><ul><li><p>在实现 Runnable 接口创建多线程的方式中，我们可以考虑使用 this 充当同步监视器。</p></li><li><p>在继承 Thread 类创建多线程的方式中，<strong>慎用</strong> this 充当同步监视器，考虑使用当前类充当同步监视器。</p></li></ul><h5 id="9-5-2-同步方法"><a href="#9-5-2-同步方法" class="headerlink" title="9.5.2 同步方法"></a>9.5.2 同步方法</h5><p>如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明同步的。（用 <strong><code>synchronized</code></strong> 修饰方法）</p><ol><li>同步方法仍然涉及到同步监视器，只是不需要我们显式的声明。</li><li>非静态的同步方法，同步监视器是：this</li><li>静态的同步方法，同步监视器是：当前类本身</li></ol><h5 id="9-5-3-Lock-锁（JDK-5-0-新增）"><a href="#9-5-3-Lock-锁（JDK-5-0-新增）" class="headerlink" title="9.5.3 Lock 锁（JDK 5.0 新增）"></a>9.5.3 Lock 锁（JDK 5.0 新增）</h5><ol><li>实例化 ReentrantLock</li><li>调用锁定方法 lock()</li><li>调用解锁方法unlock()</li></ol><p><strong>使用的优先顺序</strong></p><p><code>Lock ---&gt; 同步代码块（已经进入了方法体，分配了相应资源 ) ---&gt; 同步方法（在方法体之外)</code></p><p><strong>死锁问题</strong>：不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁</p><ul><li>出现死锁后，不会出现异常，不会出现提示，只是所的线程都处于阻塞状态，无法继续</li><li>在使用同步时，要避免出现死锁。</li></ul><p><strong>解决方法</strong>：① 专门的算法、原则；② 尽量减少同步资源的定义</p><hr><p><strong>面试题</strong></p><p>Java是如何解决线程安全问题的，有几种方式？并对比几种方式的不同</p><ul><li>使用同步机制来解决线程安全问题</li><li>共有三种方式</li></ul><p>synchronized 和 Lock 方式解决线程安全问题的对比（synchronized 与 Lock 的异同？）</p><ul><li><p>相同：二者都可以解决线程安全问题</p></li><li><p>不同：synchronized 机制在执行完相应的同步代码以后，自动的释放同步监视器</p><p>​           Lock 需要手动的启动同步（lock()，同时结束同步也需要手动的实现（unlock()）</p></li></ul><p><strong>利弊</strong>：同步的方式，<strong>解决了线程的安全问题</strong>。操作同步代码时，只能一个线程参与，其他线程等待。相当于是一个单线程的过程，<strong>效率低</strong>。</p><h4 id="9-6-线程通信"><a href="#9-6-线程通信" class="headerlink" title="9.6 线程通信"></a>9.6 线程通信</h4><p><strong>1）线程通信涉及到的三个方法</strong></p><ul><li><p><code>wait()</code>：一旦执行此方法，当前线程就进入<strong>阻塞状态</strong>，并释放同步监视器。</p></li><li><p><code>notify()</code>：一旦执行此方法，就会唤醒被 wait 的一个线程。如果有多个线程被 wait，就唤醒优先级高的那个。</p></li><li><p><code>notifyAll()</code>：一旦执行此方法，就会唤醒所有被 wait 的线程。</p></li></ul><p><strong>2）说明</strong></p><ul><li><p>这三个方法必须使用在<strong>同步代码块或同步方法</strong>中。</p></li><li><p>这三个方法的调用者必须是同步代码块或同步方法中的<strong>同步监视器</strong>。否则，会出现 <code>IllegalMonitorStateException</code> 异常</p></li><li><p>这三个方法是定义在 java.lang.Object 类中。</p></li></ul><p><strong>3）会释放锁的操作</strong></p><ol><li>当前线程的同步代码块、同步方法<strong>执行结束</strong>。</li><li>当前线程在同步代码块、同步方法中遇到 break、return <strong>终止</strong>了该代码块、该方法的继续执行。</li><li>当前线程在同步代码块、同步方法中出现了未处理的 Error 或 Exception，导致<strong>异常</strong>结束。</li><li>当前线程在同步代码块、同步方法中执行了线程对象的 **wait()**，当前线程暂停，并释放锁</li></ol><p><strong>4）不会释放锁的操作</strong></p><ol><li><p>线程执行同步代码块或同步方法时，程序调用 Thread.sleep()、Thread.yield() 方法暂停当前线程的执行。</p></li><li><p>线程执行同步代码块时，其他线程调用了该线程的 suspend() 方法将该线程挂起，该线程不会释放锁（同步监视器）。（应尽量避免使用 suspend() 和 resume() 来控制线程。）</p></li></ol><hr><p><strong>面试题</strong></p><p>sleep() 和 wait()的异同？</p><ol><li>相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态。</li><li>不同点：<ul><li>两个方法声明的位置不同：Thread类中声明sleep() , Object类中声明wait()</li><li>调用的要求不同：sleep()可以在任何需要的场景下调用。 wait()必须使用在同步代码块或同步方法中</li><li>关于是否释放同步监视器：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放锁，wait()会释放锁。</li></ul></li></ol><h3 id="第10章-Java-常用类"><a href="#第10章-Java-常用类" class="headerlink" title="第10章 Java 常用类"></a>第10章 Java 常用类</h3><h4 id="10-1-String-类"><a href="#10-1-String-类" class="headerlink" title="10.1 String 类"></a>10.1 String 类</h4><p><strong>1）概述</strong></p><ul><li><p>String（字符串）使用一对<code>&quot;&quot;</code>引起来表示。</p></li><li><p>String 内部定义了 private final char value[] 用于存储字符串数据；String 声明为 final 的，不可被继承</p></li><li><p>String 实现了 Serializable 接口：表示字符串是支持序列化的；实现了 Comparable 接口：表示 String 可以比较大小。</p></li><li><p>通过字面量的方式（区别于 new 给一个字符串赋值，此时的字符串值声明在字符串常量池中）。</p></li><li><p>字符串常量池中是不会存储相同内容（使用 String 类的 equals() 比较，返回 true）的字符串的。</p></li></ul><p><strong>2）String 的不可变性</strong></p><ul><li>当对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的 value 进行赋值。</li><li>当对现的字符串进行连接操作时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。</li><li>当调用 String 的 replace() 方法修改指定字符或字符串时，也需要重新指定内存区域赋值，不能使用原有的 value 进行赋值。</li></ul><p><strong>3）String 实例化的不同方式</strong></p><ul><li><p>方式一：通过字面量定义的方式</p></li><li><p>方式二：通过 new + 构造器的方式</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过字面量定义的方式：此时的 str1 和 str2 的数据 JavaEE 声明在方法区中的字符串常量池中。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;JavaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="string">&quot;JavaEE&quot;</span>;</span><br><span class="line"><span class="comment">// 通过 new + 构造器的方式:此时的 str3 和 str4 保存的地址值，是数据在堆空间中开辟空间以后对应的地址值。</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;JavaEE&quot;</span>);</span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;JavaEE&quot;</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(str1 == str2);<span class="comment">// true</span></span><br><span class="line">System.out.println(str1 == str3);<span class="comment">// false</span></span><br><span class="line">System.out.println(str1 == str4);<span class="comment">// false</span></span><br><span class="line">System.out.println(str3 == str4);<span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><strong>面试题</strong></p><p><code>String s = new String(&quot;abc&quot;); </code>方式创建对象，在内存中创建了几个对象？</p><ul><li>两个：一个是堆空间中 new 结构，另一个是 char[] 对应的常量池中的数据：”abc”</li></ul><p><strong>4）字符串拼接方式赋值的对比</strong></p><ol><li><p>常量与常量的拼接结果在<strong>常量池</strong>。且常量池中不会存在相同内容的常量。</p></li><li><p>只要其中一个是变量，结果就在<strong>堆</strong>中。</p></li><li><p>如果拼接的结果调用 <strong>intern()</strong> 方法，返回值就在<strong>常量池</strong>中</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s1 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s6</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span> + s2;</span><br><span class="line"><span class="type">String</span> <span class="variable">s7</span> <span class="operator">=</span> s1 + s2;</span><br><span class="line"></span><br><span class="line">System.out.println(s3 == s4);<span class="comment">// true</span></span><br><span class="line">System.out.println(s3 == s5);<span class="comment">// false</span></span><br><span class="line">System.out.println(s3 == s6);<span class="comment">// false</span></span><br><span class="line">System.out.println(s3 == s7);<span class="comment">// false</span></span><br><span class="line">System.out.println(s5 == s6);<span class="comment">// false</span></span><br><span class="line">System.out.println(s5 == s7);<span class="comment">// false</span></span><br><span class="line">System.out.println(s6 == s7);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">s8</span> <span class="operator">=</span> s6.intern();<span class="comment">// 返回值得到的 s8 使用的常量值中已经存在的 “javaEEhadoop”</span></span><br><span class="line">System.out.println(s3 == s8);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;javaEEhadoop&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">s3</span> <span class="operator">=</span> s2 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">System.out.println(s1 == s3);<span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> <span class="type">String</span> <span class="variable">s4</span> <span class="operator">=</span> <span class="string">&quot;javaEE&quot;</span>;<span class="comment">// s4: 常量</span></span><br><span class="line"><span class="type">String</span> <span class="variable">s5</span> <span class="operator">=</span> s4 + <span class="string">&quot;hadoop&quot;</span>;</span><br><span class="line">System.out.println(s1 == s5);<span class="comment">// true</span></span><br></pre></td></tr></table></figure><p><strong>5）常用方法</strong></p><ul><li><p><code>int length()</code>：返回字符串的长度： return value.length</p></li><li><p><code>char charAt(int index)</code>： 返回某索引处的字符 return value[index]</p></li><li><p><code>boolean isEmpty()</code>：判断<strong>是否为空</strong>字符串：return value.length &#x3D;&#x3D; 0</p></li><li><p><code>String toLowerCase()</code>：使用默认语言环境，将 String 中的所字符<strong>转换为小写</strong></p></li><li><p><code>String toUpperCase()</code>：使用默认语言环境，将 String 中的所字符<strong>转换为大写</strong></p></li><li><p><code>String trim()</code>：返回字符串的副本，忽略前导空白和尾部空白</p></li><li><p><code>boolean equals(Object obj)</code>：比较字符串的<strong>内容</strong>是否相同</p></li><li><p><code>boolean equalsIgnoreCase(String anotherString)</code>：与equals方法类似，忽略大小写</p></li><li><p><code>String concat(String str)</code>：将指定字符串连接到此字符串的结尾。 等价于用 “+”</p></li><li><p><code>int compareTo(String anotherString)</code>：比较两个字符串的大小</p></li><li><p><code>String substring(int beginIndex)</code>：返回一个新的字符串，它是此字符串的从<code>beginIndex</code>开始截取到最后的一个子字符串。</p></li><li><p><code>String substring(int beginIndex, int endIndex) </code>：返回一个新字符串，它是此字符串从<code>beginIndex</code>开始截取到<code>endIndex</code><strong>(不包含)</strong> 的一个子字符串。</p></li><li><p><code>boolean endsWith(String suffix)</code>：测试此字符串是否以指定的<strong>后缀</strong>结束</p></li><li><p><code>boolean startsWith(String prefix)</code>：测试此字符串是否以指定的<strong>前缀</strong>开始</p></li><li><p><code>boolean startsWith(String prefix, int toffset)</code>：测试此字符串从指定索引开始的子字符串是否以指定前缀开始</p></li><li><p><code>boolean contains(CharSequence s)</code>：当且仅当此字符串包含指定的 char 值序列时，返回 true</p></li><li><p><code>int indexOf(String str)</code>：返回指定子字符串在此字符串中第一次出现处的索引</p></li><li><p><code>int indexOf(String str, int fromIndex)</code>：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始</p></li><li><p><code>int lastIndexOf(String str)</code>：返回指定子字符串在此字符串中最右边出现处的索引</p></li><li><p><code>int lastIndexOf(String str, int fromIndex)</code>：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索</p></li><li><p>注：<code>indexOf</code> 和 <code>lastIndexOf</code> 方法如果未找到都是返回 -1</p></li></ul><p><strong>替换：</strong></p><ul><li><p><code>String replace(char oldChar, char newChar)</code>：返回一个新的字符串，它是通过用 newChar 替换此字符串中出现的所 oldChar 得到的。</p></li><li><p><code>String replace(CharSequence target, CharSequence replacement)</code>：使用指定的字面值替换序列替换此字符串所匹配字面值目标序列的子字符串。</p></li><li><p><code>String replaceAll(String regex, String replacement)</code>：使用给定的 replacement 替换此字符串所匹配给定的正则表达式的子字符串。</p></li><li><p><code>String replaceFirst(String regex, String replacement)</code>：使用给定的 replacement 替换此字符串匹配给定的正则表达式的第一个子字符串。</p></li></ul><p><strong>匹配:</strong></p><ul><li><code>boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式。</code></li></ul><p><strong>切片：</strong></p><ul><li><p><code>String[] split(String regex)</code>：根据给定正则表达式的匹配拆分此字符串。</p></li><li><p><code>String[] split(String regex, int limit)</code>：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中。</p></li></ul><p><strong>6）String 与其它结构的转换</strong></p><ul><li><code>String --&gt; 基本数据类型、包装类</code>：调用包装类的<strong>静态方法</strong> parseXxx(str)</li><li><code>基本数据类型、包装类 --&gt; String</code>：调用 String 重载的 valueOf(xxx)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str1);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> String.valueOf(num);</span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> num + <span class="string">&quot;&quot;</span>;</span><br></pre></td></tr></table></figure><ul><li><code>String --&gt; char[]</code>：调用 String 的 toCharArray()</li><li><code>char[] --&gt; String</code>：调用 String 的构造器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc123&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] charArray = str1.toCharArray();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; charArray.length; i++) &#123;</span><br><span class="line">System.out.println(charArray[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span>[] arr = &#123;<span class="string">&#x27;h&#x27;</span>, <span class="string">&#x27;e&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;o&#x27;</span>&#125;;</span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(arr);</span><br><span class="line">System.out.println(str2);</span><br></pre></td></tr></table></figure><ul><li><p>编码：<code>String --&gt; byte[]</code>：调用 String 的 getBytes()</p></li><li><p>解码：<code>byte[] --&gt; String</code>：调用 String 的构造器</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="string">&quot;abc123中国&quot;</span>;</span><br><span class="line"><span class="type">byte</span>[] bytes = str1.getBytes();<span class="comment">// 使用默认的字符集进行编码。</span></span><br><span class="line">System.out.println(Arrays.toString(bytes));</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span>[] gbks = str1.getBytes(<span class="string">&quot;gbk&quot;</span>);<span class="comment">// 使用gbk字符集进行编码。</span></span><br><span class="line">System.out.println(Arrays.toString(gbks));</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(bytes);<span class="comment">// 使用默认的字符集，进行解码。</span></span><br><span class="line">System.out.println(str2);</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks);</span><br><span class="line">System.out.println(str3);<span class="comment">// 出现乱码。原因：编码集和解码集不一致！</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(gbks, <span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">System.out.println(str4);<span class="comment">// 没出现乱码。原因：编码集和解码集一致！</span></span><br></pre></td></tr></table></figure><p>说明：解码时，要求解码使用的字符集必须与编码时使用的<strong>字符集一致</strong>，否则会出现乱码。</p><ul><li><code>String --&gt; StringBuffer、StringBuilder</code>：调用 StringBuffer、StringBuilder 构造器</li><li><code>StringBuffer、StringBuilder --&gt;S tring</code>：① 调用 String 构造器；② StringBuffer、StringBuilder 的 toString()</li></ul><p><strong>7）JVM 中字符串常量池存放位置说明</strong></p><ul><li><p>jdk 1.6：字符串常量池存储在<strong>方法区（永久区）</strong></p></li><li><p>jdk 1.7：字符串常量池存储在<strong>堆空间</strong></p></li><li><p>jdk 1.8：字符串常量池存储在<strong>方法区（元空间）</strong></p></li></ul><p><strong>8）常见算法题目</strong></p><ol><li><p>模拟一个 trim 方法，去除字符串两端的空格。</p></li><li><p>将一个字符串进行反转。将字符串中指定部分进行反转。比如 “abcdefg” 反转为 ”abfedcg”</p></li><li><p>获取一个字符串在另一个字符串中出现的次数。比如：获取 “ab” 在 “abkkcadkabkebfkabkskab” 中出现的次数</p></li><li><p>获取两个字符串中最大相同子串。比如：   str1 &#x3D; “abcwerthelloyuiodef“，str2 &#x3D; “cvhellobnm”</p><ul><li>提示：将短的那个串进行长度依次递减的子串与较长的串比较。</li></ul></li><li><p>对字符串中字符进行自然顺序排序。</p><ul><li>提示：字符串变成字符数组；对数组排序，择，冒泡，Arrays.sort()；将排序后的数组变成字符串。</li></ul></li></ol><h4 id="10-2-StringBuffer、StringBuilder-类"><a href="#10-2-StringBuffer、StringBuilder-类" class="headerlink" title="10.2 StringBuffer、StringBuilder 类"></a>10.2 StringBuffer、StringBuilder 类</h4><p><strong>1）String、StringBuffer、StringBuilder 三者的对比</strong></p><ul><li><p>String：<strong>不可变</strong>的字符序列；底层使用 char[] 存储</p></li><li><p>StringBuffer：<strong>可变</strong>的字符序列；<strong>线程安全</strong>的，效率低；底层使用 char[] 存储</p></li><li><p>StringBuilder：<strong>可变</strong>的字符序列；JDK 5.0 新增的，<strong>线程不安全</strong>的，效率高；底层使用 char[] 存储</p></li></ul><p><strong>2）StringBuffer 与 StringBuilder 的内存解析</strong></p><p>以 StringBuffer 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>();<span class="comment">//char[] value = new char[0];</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char[] value = new char[]&#123;&#x27;a&#x27;,&#x27;b&#x27;,&#x27;c&#x27;&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>();<span class="comment">//char[] value = new char[16]; 底层创建了一个长度是16的数组。</span></span><br><span class="line">System.out.println(sb1.length());<span class="comment">//</span></span><br><span class="line">sb1.append(<span class="string">&#x27;a&#x27;</span>);<span class="comment">//value[0] = &#x27;a&#x27;;</span></span><br><span class="line">sb1.append(<span class="string">&#x27;b&#x27;</span>);<span class="comment">//value[1] = &#x27;b&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="type">StringBuffer</span> <span class="variable">sb2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuffer</span>(<span class="string">&quot;abc&quot;</span>);<span class="comment">//char[] value = new char[&quot;abc&quot;.length() + 16];</span></span><br></pre></td></tr></table></figure><p>问题1：<code> System.out.println(sb2.length());</code>&#x2F;&#x2F; 3</p><p>问题2：扩容问题：如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。</p><ul><li><p>默认情况下，扩容为原来容量的2倍 + 2，同时将原数组中的元素复制到新的数组中。</p></li><li><p>指导意义：开发中建议大家使用：<code>StringBuffer(int capacity)</code> 或 <code>StringBuilder(int capacity)</code></p></li></ul><p><strong>3）对比String、StringBuffer、StringBuilder 三者的执行效率</strong>从高到低排列：<code>StringBuilder &gt; StringBuffer &gt; String</code></p><p><strong>4）StringBuffer、StringBuilder中的常用方法</strong></p><ul><li><p>增：append(xxx)</p></li><li><p>删：delete(int start,int end)</p></li><li><p>改：setCharAt(int n ,char ch) &#x2F; replace(int start, int end, String str)</p></li><li><p>查：charAt(int n )</p></li><li><p>插：insert(int offset, xxx)</p></li><li><p>长度：length();</p></li><li><p>遍历：① for() + charAt()；② toString()</p></li></ul><h4 id="10-3-JDK-8-之前的日期时间-API"><a href="#10-3-JDK-8-之前的日期时间-API" class="headerlink" title="10.3 JDK 8 之前的日期时间 API"></a>10.3 JDK 8 之前的日期时间 API</h4><p><strong>1）获取系统当前时间</strong>：System 类中的 <code>currentTimeMillis()</code></p><p><strong>2）java.util.Date 类 与 java.sql.Date 类</strong></p><ul><li>java.sql.Date 类是 java.util.Date 类</li></ul><p><strong>两个构造器的使用</strong></p><ol><li><code>Date()</code>：创建一个对应当前时间的 Date 对象</li><li>创建指定毫秒数的Date对象</li></ol><p><strong>两个方法的使用</strong></p><ol><li><code>toString()</code>：显示当前的年、月、日、时、分、秒</li><li><code>getTime()</code>：获取当前Date对象对应的毫秒数。（时间戳）</li></ol><p><strong>java.sql.Date 对应着数据库中的日期类型的变量</strong></p><ul><li>如何实例化</li><li>如何将 java.util.Date 对象转换为 java.sql.Date 对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dateTest</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 创建一个 Date 对象</span></span><br><span class="line">    <span class="comment">// 构造器一</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    System.out.println(date1.toString());</span><br><span class="line">    System.out.println(date1.getTime());</span><br><span class="line">    <span class="comment">// 构造器二</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">84739232874L</span>);</span><br><span class="line">    System.out.println(date2.toString());</span><br><span class="line">    <span class="comment">// 创建 java.sql.Date 对象</span></span><br><span class="line">    java.sql.<span class="type">Date</span> <span class="variable">date3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="number">739742938429L</span>);</span><br><span class="line">    System.out.println(date3);</span><br><span class="line">    <span class="comment">// 将java.util.Date对象转换为java.sql.Date对象</span></span><br><span class="line">    <span class="comment">// 方法一</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(<span class="number">342342342L</span>);</span><br><span class="line">    java.sql.<span class="type">Date</span> <span class="variable">date5</span> <span class="operator">=</span> (java.sql.Date)date4;</span><br><span class="line">    <span class="comment">// 方法二</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date6</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    java.sql.<span class="type">Date</span> <span class="variable">date7</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">java</span>.sql.Date(date6.getTime());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3）java.text.SimpleDataFormat类</strong></p><ul><li>对日期 Date 类的格式化和解析</li><li>格式化：<code>日期 --&gt; 字符串</code></li><li>解析：格式化的逆过程，<code>字符串 --&gt; 日期</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">simpleDateFormatTest</span><span class="params">()</span> <span class="keyword">throws</span> ParseException &#123;</span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    System.out.println(date);</span><br><span class="line">    <span class="comment">// 格式化</span></span><br><span class="line">    <span class="type">SimpleDateFormat</span> <span class="variable">simpleDateFormat</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SimpleDateFormat</span>(<span class="string">&quot;yyyy-MM-dd hh:mm:ss&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">format</span> <span class="operator">=</span> simpleDateFormat.format(date);</span><br><span class="line">    System.out.println(format);</span><br><span class="line">    <span class="comment">// 解析：要求字符串必须是符合 SimpleDateFormat 识别的格式（通过构造器参数体现），否则，报 java.text.ParseException</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">parse</span> <span class="operator">=</span> simpleDateFormat.parse(<span class="string">&quot;2021-02-06 04:39:35&quot;</span>);</span><br><span class="line">    System.out.println(parse);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4）Calendar 类（抽象类）</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">calendarTest</span><span class="params">()</span> &#123;</span><br><span class="line">java    <span class="comment">// 1.实例化</span></span><br><span class="line">    <span class="comment">// 方法一：创建其子类 GregorianCalendar 的对象</span></span><br><span class="line"><span class="comment">//        GregorianCalendar gregorianCalendar = new GregorianCalendar();</span></span><br><span class="line">    <span class="comment">// 方法二：调用其静态方法 getInstance()</span></span><br><span class="line">    <span class="type">Calendar</span> <span class="variable">calendar</span> <span class="operator">=</span> Calendar.getInstance();</span><br><span class="line">    <span class="comment">// 2.常用方法</span></span><br><span class="line">    <span class="comment">// get()</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">days</span> <span class="operator">=</span> calendar.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">    System.out.println(days);</span><br><span class="line">    <span class="comment">// set()：Calendar 的可变性</span></span><br><span class="line">    calendar.set(Calendar.DAY_OF_MONTH, <span class="number">23</span>);</span><br><span class="line">    System.out.println(calendar.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">    <span class="comment">// add()</span></span><br><span class="line">    calendar.add(Calendar.DAY_OF_MONTH, -<span class="number">3</span>);</span><br><span class="line">    System.out.println(calendar.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">    <span class="comment">// getTime(): Calendar --&gt; Date</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">date</span> <span class="operator">=</span> calendar.getTime();</span><br><span class="line">    System.out.println(date);</span><br><span class="line">    <span class="comment">// setTime(): Date --&gt; Calender</span></span><br><span class="line">    <span class="type">Date</span> <span class="variable">now</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line">    calendar.setTime(now);</span><br><span class="line">    System.out.println(calendar.get(Calendar.DAY_OF_MONTH));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-4-JDK-8-中新时间日期-API"><a href="#10-4-JDK-8-中新时间日期-API" class="headerlink" title="10.4 JDK 8 中新时间日期 API"></a>10.4 JDK 8 中新时间日期 API</h4><p><strong>1）日期时间 API 的迭代</strong></p><ul><li>第一代：JDK 1.0 Date 类</li><li>第二代：JDK 1.1 Calenda r类，一定程度上替换 Date 类</li><li>第三代：JDK 1.8 提出了新的一套 API</li></ul><p><strong>2）前两代存在的问题</strong></p><ul><li>可变性：像日期和时间这样的类应该是不可变的。</li><li>偏移性：Date 中的年份是从1900开始的，而月份都从 0 开始。</li><li>格式化：格式化只对 Date 用，Calendar 则不行。</li><li>不是线程安全的；不能处理闰秒等。</li></ul><p><strong>3）新的日期时间 API 涉及到的包</strong></p><ul><li><strong>java.time</strong>：包含值对象的基础包</li><li>java.time.chrono：提供对不同的日历系统的访问</li><li><strong>java.time.format</strong>：格式化和解析时间和日期</li><li>java.time.temporal：包括底层框架和扩展特性</li><li>java.time.zone：包含时区支持的类</li></ul><p><strong>4）本地日期（LocalDate ）、本地时间（LocalTime）、本地日期时间（LocalDateTime）的使用</strong></p><h4 id="10-5-Java-比较器"><a href="#10-5-Java-比较器" class="headerlink" title="10.5 Java 比较器"></a>10.5 Java 比较器</h4><p>Java 中的对象，正常情况下，只能进行比较：&#x3D;&#x3D;  或  !&#x3D; 。不能使用 &gt; 或 &lt; 的。但是，在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小。使用两个接口中的任何一个：Comparable 或 Comparator</p><p><strong>1）自然排序：使用 Comparable 接口</strong></p><ol><li>像 String、包装类等实现了 Comparable 接口，重写了 compareTo(obj) 方法，给出了比较两个对象大小的方式，进行了从小到大的排列。</li><li>重写 compareTo(obj) 的<strong>规则</strong>：<ul><li>如果当前对象 this 大于形参对象 obj，则返回正整数；</li><li>如果当前对象 this 小于形参对象 obj，则返回负整数；</li><li>如果当前对象 this 等于形参对象 obj，则返回 0。</li></ul></li><li>对于自定义类来说，如果需要排序，我们可以让自定义类实现 Comparable 接口，重写 compareTo(obj) 方法，在 compareTo(obj) 方法中指明如何排序</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Goods</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> price;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Goods) &#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">goods</span> <span class="operator">=</span> (Goods)o;</span><br><span class="line">            <span class="comment">// 方法一</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.price &gt; goods.price) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">this</span>.price &lt; goods.price) &#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//                return 0;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">this</span>.name.compareTo(goods.name);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 方法二</span></span><br><span class="line"><span class="comment">//            return Double.compare(this.price, goods.price);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;传入数据类型不一致！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getter、setter、toString()、构造器：省略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）定制排序：使用 Comparator 接口</strong></p><ol><li>当元素的类型没实现 java.lang.Comparable 接口而又不方便修改代码，或者实现了 java.lang.Comparable 接口的排序规则不适合当前的操作，那么可以考虑使用 Comparator 的对象来排序</li><li>重写 compare(Object o1, Object o2) 方法，比较 o1 和 o2 的大小：<ul><li>如果方法返回正整数，表示 o1 大于 o2；</li><li>如果方法返回负整数，表示 o1 小于 o2；</li><li>如果方法返回 0，表示相等。</li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Goods&gt; goods = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    goods.add(<span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;rice&quot;</span>, <span class="number">34</span>));</span><br><span class="line">    goods.add(<span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;apple&quot;</span>, <span class="number">5</span>));</span><br><span class="line">    goods.add(<span class="keyword">new</span> <span class="title class_">Goods</span>(<span class="string">&quot;meat&quot;</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//        Comparator comparator = new Comparator() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public int compare(Object o1, Object o2) &#123;</span></span><br><span class="line"><span class="comment">//                if (o1 instanceof Goods &amp;&amp; o2 instanceof Goods) &#123;</span></span><br><span class="line"><span class="comment">//                    Goods g1 = (Goods)o1;</span></span><br><span class="line"><span class="comment">//                    Goods g2 = (Goods)o2;</span></span><br><span class="line"><span class="comment">//                    if (g1.getName().equals(g2.getName())) &#123;</span></span><br><span class="line"><span class="comment">//                        return Double.compare(g1.getPrice(), g2.getPrice());</span></span><br><span class="line"><span class="comment">//                    &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                        return g1.getName().compareTo(g2.getName());</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                throw new RuntimeException(&quot;输入的数据类型不一致！&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Comparator</span> <span class="variable">comparator</span> <span class="operator">=</span> (o1, o2) -&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (o1 <span class="keyword">instanceof</span> Goods &amp;&amp; o2 <span class="keyword">instanceof</span> Goods) &#123;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">g1</span> <span class="operator">=</span> (Goods)o1;</span><br><span class="line">            <span class="type">Goods</span> <span class="variable">g2</span> <span class="operator">=</span> (Goods)o2;</span><br><span class="line">            <span class="keyword">if</span> (g1.getName().equals(g2.getName())) &#123;</span><br><span class="line">                <span class="keyword">return</span> Double.compare(g1.getPrice(), g2.getPrice());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> g1.getName().compareTo(g2.getName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的数据类型不一致！&quot;</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用</span></span><br><span class="line">    Arrays.sort(goods.toArray(), comparator);</span><br><span class="line">    Collections.sort(goods, comparator);</span><br><span class="line">    Set&lt;Goods&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;Goods&gt;(comparator);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-6-其他"><a href="#10-6-其他" class="headerlink" title="10.6 其他"></a>10.6 其他</h4><p><strong>1）System 类</strong></p><ul><li>System 类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于 java.lang 包。</li><li>由于该类的构造器是 private 的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是 static 的，所以也可以很方便的进行调用。</li><li>方法：<ul><li><code>native long currentTimeMillis()</code></li><li><code>void exit(int status)</code></li><li><code>void gc()</code></li><li><code>String getProperty(String key)</code></li></ul></li></ul><p><strong>2）Math类</strong></p><ul><li>java.lang.Math 提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为 double 型。</li></ul><p><strong>3）BigInteger 类、BigDecimal 类</strong></p><ul><li>java.math 包的 BigInteger 可以表示不可变的任意精度的整数。</li><li>要求数字精度比较高，用到 java.math.BigDecimal 类</li></ul><h3 id="第11章-Java-集合"><a href="#第11章-Java-集合" class="headerlink" title="第11章 Java 集合"></a>第11章 Java 集合</h3><h4 id="11-1-数组和集合"><a href="#11-1-数组和集合" class="headerlink" title="11.1 数组和集合"></a>11.1 数组和集合</h4><p><strong>1）集合与数组存储数据概述</strong></p><ul><li><p>集合、数组都是对多个数据进行存储操作的结构，简称 <strong>Java 容器</strong>。</p></li><li><p>说明：此时的存储，主要指的是内存层面的存储，不涉及到持久化的存储（.txt，.jpg，.avi，数据库中)</p></li></ul><p><strong>2）数组存储的特点</strong></p><ul><li>数组一旦初始化以后，其长度就确定了。一旦定义好，其元素的类型也就确定了，只能操作指定类型的数据了。</li></ul><p><strong>3）数组存储的弊端</strong></p><ol><li>一旦初始化以后，其长度就不可修改。</li><li>数组中提供的方法非常有限，对于添加、删除、插入数据等操作，非常不便，同时效率不高。</li><li>获取数组中实际元素的个数的需求，数组没有现成的属性或方法可用。</li><li>数组存储数据的特点：有序、可重复。对于无序、不可重复的需求，不能满足。</li></ol><p><strong>4）集合存储的优点</strong></p><ul><li>解决数组存储数据方面的弊端。</li></ul><h4 id="11-2-Collection-接口"><a href="#11-2-Collection-接口" class="headerlink" title="11.2 Collection 接口"></a>11.2 Collection 接口</h4><p><strong>1）集合框架结构</strong></p><p><img src="/.io//image%5CJava%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6.gif" alt="集合框架"></p><p><strong>2）Collection 接口常用方法</strong></p><ul><li><code>add(Object obj)</code>：添加一个元素</li><li><code>addAll(Collection coll)</code>：添加集合元素</li><li><code>size()</code>：集合元素个数</li><li><code>isEmpty()</code>：是否为空</li><li><code>clear()</code>：清空</li><li><code>contains(Object obj)</code>：是否包含某个元素</li><li><code>containsAll(Collection coll)</code>：是否包含某个集合元素</li><li><code>remove(Object obj)</code>：删除某个元素</li><li><code>removeAll(Collection coll)</code>：删除所有属于某个集合中的元素</li><li><code>retainsAll(Collection coll)</code>：删除所有不属于某集合中的元素</li><li><code>equals(Object obj)</code>：是否相等</li><li><code>toArray()</code>：转换为数组</li><li><code>iterator()</code>：生成迭代器</li></ul><p><strong>3）Collection 集合与数组间的转换</strong></p><ul><li><code>集合 ---&gt; 数组：toArray()</code></li><li><code>数组 ---&gt; 集合：调用 Arrays 类的静态方法 asList(T ... t)</code></li></ul><p><strong>使用 Collection 集合存储对象，要求对象所属的类满足：向 Collection 接口的实现类的对象中添加数据 obj 时，要求 obj 所在类要重写 equals()。</strong></p><p><strong>要求</strong></p><ul><li><p>层次一：选择合适的集合类去实现数据的保存，调用其内部的相关方法。</p></li><li><p>层次二：不同的集合类底层的数据结构为何？如何实现数据的操作的：增删改查等。</p></li></ul><h4 id="11-3-Iterator-接口"><a href="#11-3-Iterator-接口" class="headerlink" title="11.3 Iterator 接口"></a>11.3 Iterator 接口</h4><p><strong>1）遍历 Collection 的两种方式</strong></p><ul><li>使用迭代器 Iterator</li><li>使用 foreach 循环（增强 for 循环）</li></ul><p><strong>2）迭代器接口 Iterator</strong></p><ul><li>java.utils 包下定义的迭代器接口：Iterator</li><li>Iterator 对象称为迭代器（设计模式的一种），主要用于<strong>遍历 Collection 集合中的元素</strong>（作用）</li><li>方法<ul><li><code>hasNext()</code>：判断是否还下一个元素</li><li><code>next()</code>：① 指针下移 ② 将下移以后集合位置上的元素返回</li><li><code>remove()</code>：删除集合中的元素（如果还未调用 next() 或在上一次调用 next() 方法之后已经调用了 remove() 方法，再调用 remove() 就会报IllegalStateException）</li></ul></li></ul><p><strong>3）增强 for 循环（JDK5.0 新特性）</strong></p><ul><li><code>for(集合元素的类型 局部变量 : 集合对象)&#123;&#125;</code></li><li>内部仍然调用了迭代器。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = Arrays.asList(<span class="number">12</span>, <span class="number">34</span>, <span class="number">43</span>, <span class="number">93</span>, <span class="number">32</span>);</span><br><span class="line"><span class="comment">// 使用迭代器遍历</span></span><br><span class="line">Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用增强 for 循环遍历</span></span><br><span class="line"><span class="keyword">for</span> (Integer num : list) &#123;</span><br><span class="line">    System.out.println(num);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-4-List-接口"><a href="#11-4-List-接口" class="headerlink" title="11.4 List 接口"></a>11.4 List 接口</h4><p>存储有序的、可重复的数据</p><p><strong>1）常用方法</strong></p><ul><li>增：<code>add(Object obj)</code></li><li>删：<code>remove(int index)</code> &#x2F; <code>remove(Object obj)</code></li><li>改：<code>set(int index, Object ele)</code></li><li>查：<code>get(int index)</code></li><li>插：<code>add(int index, Object ele)</code></li><li>长度：<code>size()</code></li><li>遍历：① Iterator 迭代器方式；② 增强 for 循环；③ 普通的循环</li></ul><p><strong>2）常用的实现类</strong></p><ul><li>ArrayList：作为 List 接口的主要实现类；线程不安全的，效率高；底层使用 Object[] elementData 存储</li><li>LinkedList：对于频繁的插入、删除操作，使用此类效率比 ArrayList 高；底层使用双向链表存储</li><li>Vector：作为List接口的古老实现类；线程安全的，效率低；底层使用 Object[] elementData 存储</li></ul><p><strong>3）源码分析</strong></p><p><strong>ArrayList</strong></p><ul><li>JDK 7 情况下<ul><li><code>ArrayList list = new ArrayList();</code>&#x2F;&#x2F; 底层创建了<strong>长度为10</strong> 的 Object[] elementData 数组</li><li><code>list.add(123);</code> &#x2F;&#x2F; elementData[0] &#x3D; new Integer(123);</li><li>如果此次的添加导致底层 elementData 数组容量不够，则扩容。</li><li>默认情况下，扩容为<strong>原来的容量的 1.5 倍</strong>，同时需要将原有数组中的数据复制到新的数组中。</li><li>结论：建议开发中使用带参的构造器：<code>ArrayList list = new ArrayList(int capacity)</code></li></ul></li><li>JDK 8 中的变化：<ul><li><code>ArrayList list = new ArrayList();</code>&#x2F;&#x2F; 底层 Object[] elementData 初始化为 {}，并没创建长度为10 的数组</li><li><code>list.add(123);</code>&#x2F;&#x2F; 第一次调用 add() 时，底层才创建了长度 10 的数组，并将数据 123 添加到 elementData[0]</li><li>后续的添加和扩容操作与 JDK 7 无异。</li></ul></li><li><strong>小结</strong>：JDK 7 中的 ArrayList 的对象的创建类似于单例的饿汉式，而 JDK 8 中的 ArrayList 的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存。</li></ul><p><strong>LinkedList</strong></p><ul><li><p><code>LinkedList list = new LinkedList();</code> 内部声明了 Node 类型的 first 和 last 属性，默认值为 null</p></li><li><p><code>list.add(123);</code>&#x2F;&#x2F; 将 123 封装到 Node 中，创建了 Node 对象。</p></li><li><p>其中，Node 定义为：体现了 LinkedList 的双向链表的说法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span>&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        <span class="built_in">this</span>.item = element;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">        <span class="built_in">this</span>.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>Vector</strong></p><ul><li>JDK 7 和 JDK 8 中通过Vector()构造器创建对象时，底层都创建了**长度为 10 **的数组。</li><li>在扩容方面，默认扩容为原来的数组长度的2倍。</li></ul><p><strong>在添加的对象时，所在的类要重写 equals() 方法</strong></p><p>面试题：ArrayList、LinkedList、Vector 者的异同？</p><h4 id="11-5-Set-接口"><a href="#11-5-Set-接口" class="headerlink" title="11.5 Set 接口"></a>11.5 Set 接口</h4><p>无序的、不可重复的元素</p><p><strong>1）常用方法</strong></p><p>Set 接口中没额外定义新的方法，使用的都是 Collection 中声明过的方法。</p><p><strong>2）常用的实现类</strong></p><ul><li>HashSet：作为 Set 接口的主要实现类；线程不安全的；可以存储 null 值<ul><li>LinkedHashSet：作为 HashSet 的子类；遍历其内部数据时，可以按照添加的顺序遍历。在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据。对于频繁的遍历操作，LinkedHashSet 效率高于 HashSet。</li></ul></li><li>TreeSet：可以照添加对象的指定属性，进行排序。</li></ul><p><strong>3）元素添加过程（以 HashSet 为例）</strong></p><p>我们向 HashSet 中添加元素 a，首先调用元素 a 所在类的 hashCode() 方法，计算元素 a 的哈希值，此哈希值接着通过某种算法计算出在 HashSet 底层数组中的存放位置（即索引位置），判断数组此位置上是否已经元素：</p><ul><li>如果此位置上没其他元素，则元素 a 添加成功。（情况1）</li><li>如果此位置上其他元素 b（或以链表形式存在的多个元素），则比较元素 a 与元素 b 的 hash 值：<ul><li>如果 hash 值不相同，则元素 a 添加成功。（情况2）</li><li>如果 hash 值相同，进而需要调用元素 a 所在类的 equals() 方法：<ul><li>equals() 返回 true,元素 a 添加失败</li><li>equals() 返回 false,则元素 a 添加成功。（情况3）</li></ul></li></ul></li></ul><p>对于添加成功的情况 2 和情况 3 而言：元素 a 与已经存在指定索引位置上数据以链表的方式存储。</p><ul><li>JDK 7：元素 a 放到数组中，指向原来的元素。</li><li>JDK 8：原来的元素在数组中，指向元素 a</li><li>总结：七上八下</li></ul><p>HashSet 底层：数组 + 链表的结构。（前提：JDK 7）</p><p><strong>4）存储对象所在类的要求</strong></p><p><strong>HashSet&#x2F;LinkedHashSet</strong></p><ul><li>向 Set（主要指 HashSet、LinkedHashSet）中添加的数据，其所在的类<strong>一定要重写 hashCode() 和 equals()</strong><ul><li>重写的 hashCode() 和 equals() 尽可能保持一致性：相等的对象必须具有相等的散列码</li><li>重写两个方法的小技巧：对象中用作 equals() 方法比较的 Field，都应该用来计算 hashCode 值。</li></ul></li></ul><p><strong>TreeSet</strong></p><ul><li>自然排序中，比较两个对象是否相同的标准为：compareTo() 返回0，不再是equals()。</li><li>定制排序中，比较两个对象是否相同的标准为：compare() 返回0，不再是equals()。</li></ul><p><strong>5）TreeSet的使用</strong></p><ul><li>向 TreeSet 中添加的数据，要求是相同类的对象。</li><li>两种排序方式：自然排序（实现 Comparable 接口）和定制排序（实现 Comparator 接口）</li></ul><p><strong>常用的排序方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">comparableTest</span><span class="params">()</span> &#123;</span><br><span class="line">        Set&lt;User&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        traverseSet(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">comparatorTest</span><span class="params">()</span> &#123;</span><br><span class="line">        Comparator&lt;User&gt; comparator = Comparator.comparingInt(User::getAge);</span><br><span class="line"><span class="comment">//        Comparator&lt;User&gt; comparator = new Comparator&lt;User&gt;() &#123;</span></span><br><span class="line"><span class="comment">//            @Override</span></span><br><span class="line"><span class="comment">//            public int compare(User o1, User o2) &#123;</span></span><br><span class="line"><span class="comment">//                return Integer.compare(o1.getAge(), o2.getAge())</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;;</span></span><br><span class="line"></span><br><span class="line">        TreeSet&lt;User&gt; set = <span class="keyword">new</span> <span class="title class_">TreeSet</span>&lt;&gt;(comparator);</span><br><span class="line"></span><br><span class="line">        traverseSet(set);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">traverseSet</span><span class="params">(Set set)</span> &#123;</span><br><span class="line">        </span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Mary&quot;</span>, <span class="number">24</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">34</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Arthur&quot;</span>, <span class="number">32</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">45</span>));</span><br><span class="line">        set.add(<span class="keyword">new</span> <span class="title class_">User</span>(<span class="string">&quot;Zoom&quot;</span>, <span class="number">28</span>));</span><br><span class="line"></span><br><span class="line">        Iterator&lt;User&gt; iterator = set.iterator();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">User</span> <span class="keyword">implements</span> <span class="title class_">Comparable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">User</span><span class="params">(String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span> == o) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="literal">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) o;</span><br><span class="line">        <span class="type">return</span> <span class="variable">age</span> <span class="operator">=</span>= user.age &amp;&amp;</span><br><span class="line">                Objects.equals(name, user.name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hashCode</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Objects.hash(name, age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;User&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compareTo</span><span class="params">(Object o)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> User) &#123;</span><br><span class="line">            <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> (User) o;</span><br><span class="line">            <span class="type">int</span> <span class="variable">compare</span> <span class="operator">=</span> <span class="built_in">this</span>.name.compareTo(user.name);</span><br><span class="line">            <span class="keyword">if</span> (compare != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> compare;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.compare(<span class="built_in">this</span>.age, user.age);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;输入的类型不匹配&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-6-Map-接口"><a href="#11-6-Map-接口" class="headerlink" title="11.6 Map 接口"></a>11.6 Map 接口</h4><p>双列数据，存储 key-value 对的数据</p><p><strong>1）常用实现类</strong></p><ul><li>HashMap：作为 Map 的主要实现类；线程不安全的，效率高；可以存储 null 的 key 和 value<ul><li>LinkedHashMap：保证在遍历 map 元素时，可以照添加的顺序实现遍历。<ul><li><pre><code>               原因：在原的 HashMap 底层结构基础上，添加了一对指针，指向前一个和后一个元素。</code></pre></li><li><pre><code>               对于频繁的遍历操作，此类执行效率高于 HashMap。</code></pre></li></ul></li></ul></li><li>TreeMap：保证照添加的 key-value 对进行排序，实现排序遍历。此时考虑 key 的自然排序或定制排序</li><li>Hashtable：作为古老的实现类；线程安全的，效率低；不能存储 null 的 key 和 value<ul><li>Properties：常用来处理配置文件。key 和 value 都是 String 类型</li></ul></li></ul><p> <strong>HashMap 的底层</strong></p><ul><li>数组+链表（JDK 7 及之前)</li><li>数组+链表+红黑树（JDK 8)</li></ul><p><strong>2）存储结构的理解</strong></p><ul><li>Map 中的 key：无序的、不可重复的，使用 Set 存储所有的 key  <code>--&gt; </code> key 所在的类要重写 equals() 和 hashCode() （以 HashMap 为例)</li><li>Map 中的 value：无序的、可重复的，使用 Collection 存储所的 value <code>--&gt;</code> value 所在的类要重写 equals()</li><li>一个键值对 key-value 构成了一个 Entry 对象。</li><li>Map 中的 entry：无序的、不可重复的，使用 Set 存储所的 entry</li></ul><p><strong>3）常用方法</strong></p><ul><li>添加：<code>put(Object key, Object value)</code></li><li>删除：<code>remove(Object key)</code></li><li>修改：<code>put(Object key, Object value)</code></li><li>查询：<code>get(Object key)</code></li><li>长度：<code>size()</code></li><li>遍历：<code>keySet()</code> &#x2F; <code>values()</code> &#x2F;<code> entrySet()</code></li></ul><p><strong>4）内存结构说明</strong></p><p><strong>HashMap</strong></p><p><strong>① 在 JDK 7 中实现原理</strong></p><ul><li><pre><code> `HashMap map = new HashMap()`：在实例化以后，底层创建了**长度为16** 的一维数组 Entry[] table。</code></pre></li><li><pre><code> `map.put(key1, value1)`：**首先**，调用 key1 所在类的 hashCode() 计算 key1 哈希值，此哈希值经过某种算法计算以后，得到在 Entry 数组中的存放位置。 *      如果此位置上的数据为空，此时的 key1-value1 添加成功。（情况1） *      如果此位置上的数据不为空（意味着此位置上存在一个或多个数据（以链表形式存在）），比较 key1 和已经存在的一个或多个数据的哈希值：        *              如果 key1 的哈希值与已经存在的数据的哈希值都不相同，此时 key1-value1 添加成功。（情况2）        *              如果 key1 的哈希值和已经存在的某一个数据（key2-value2）的哈希值相同，继续比较：调用 key1.equals(key2) 方法，比较：        *                      如果 equals() 返回 false：此时 key1-value1 添加成功。（情况3）        *      如果 equals() 返回 true：使用 value1 替换 value2。</code></pre></li></ul><p>关于情况2和情况3：此时 key1-value1 和原来的数据以链表的方式存储。</p><p>在不断的添加过程中，会涉及到扩容问题，当超出临界值（且要存放的位置非空）时，扩容。默认的扩容方式：扩容为原来容量的2倍，并将原的数据复制过来。</p><p><strong>② 在 JDK 8 中相较于 JDK 7 在底层实现方面的不同：</strong></p><ol><li>new HashMap()：底层没创建一个长度为 16 的数组</li><li>JDK 8底层的数组是：Node[]，而非 Entry[]</li><li>首次调用 put() 方法时，底层创建长度为 16 的数组</li><li>JDK 7 中底层结构：数组+链表；JDK 8 中底层结构：数组+链表+红黑树。</li><li>形成链表时，七上八下（JDK 7：新的元素指向旧的元素；JDK 8：旧的元素指向新的元素）</li><li>当数组的某一个索引位置上的元素（以链表形式存在的数据个数 &gt; 8）且（当前数组的长度 &gt; 64）时，此时此索引位置上的所数据改为使用红黑树存储</li></ol><p><strong>③ HashMap 底层典型属性的属性的说明</strong></p><ul><li>DEFAULT_INITIAL_CAPACITY : HashMap 的默认容量，16</li><li>DEFAULT_LOAD_FACTOR：HashMap 的默认加载因子，0.75</li><li>threshold：扩容的临界值 &#x3D; 容量 * 填充因子 &#x3D; 16 * 0.75 &#x3D; 12</li><li>TREEIFY_THRESHOLD：Bucket 中链表长度大于该默认值，转化为红黑树，8</li><li>MIN_TREEIFY_CAPACITY：桶中的 Node 被树化时最小的 hash 表容量，64</li></ul><p><strong>LinkedHashMap</strong></p><ul><li>LinkedHashMap 底层使用的结构与 HashMap 相同，因为 LinkedHashMap 继承于 HashMap。区别就在于：LinkedHashMap 内部提供了 Entry，替换 HashMap 中的 Node</li></ul><p><img src="/.io//image%5Cimage-20210206140413853.png" alt="image-20210206140413853"></p><p><strong>TreeMap</strong></p><ul><li>TreeMap 中添加 key-value，要求 key 必须是由同一个类创建的对象</li><li>因为要按照 key 进行排序：自然排序 、定制排序</li></ul><p><strong>Properties</strong></p><ul><li>常用来处理配置文件。key 和 value 都是 String 类型</li></ul><h4 id="11-7-Collections-工具类"><a href="#11-7-Collections-工具类" class="headerlink" title="11.7 Collections 工具类"></a>11.7 Collections 工具类</h4><ul><li>操作 Collection 和 Map 的工具类</li></ul><p><strong>常用方法</strong></p><ul><li><code>reverse(List)</code>：反转 List 中元素的顺序</li><li><code>shuffle(List)</code>：对 List 集合元素进行随机排序</li><li><code>sort(List)</code>：根据元素的自然顺序对指定 List 集合元素升序排序</li><li><code>sort(List，Comparator)</code>：根据指定的 Comparator 产生的顺序对 List 集合元素进行排序</li><li><code>swap(List，int， int)</code>：将指定 list 集合中的 i 处元素和 j 处元素进行交换</li><li><code>Object max(Collection)</code>：根据元素的自然顺序，返回给定集合中的最大元素</li><li><code>Object max(Collection，Comparator)</code>：根据 Comparator 指定的顺序，返回给定集合中的最大元素</li><li><code>Object min(Collection)</code></li><li><code>Object min(Collection，Comparator)</code></li><li><code>int frequency(Collection，Object)</code>：返回指定集合中指定元素的出现次数</li><li><code>void copy(List dest,List src)</code>：将src中的内容复制到dest中</li><li><code>boolean replaceAll(List list，Object oldVal，Object newVal)</code>：使用新值替换 List 对象的所旧值</li></ul><p><strong>ArrayList 和 HashMap 都是线程不安全的，如果程序要求线程安全，我们可以使用 synchronizedList(List list) 和 synchronizedMap(Map map) 将 ArrayList、HashMap 转换为线程安全的。</strong></p><h3 id="第12章-泛型（Generics）"><a href="#第12章-泛型（Generics）" class="headerlink" title="第12章 泛型（Generics）"></a>第12章 泛型（Generics）</h3><h4 id="12-1-概念"><a href="#12-1-概念" class="headerlink" title="12.1 概念"></a>12.1 概念</h4><ul><li>所谓泛型，就是允许在定义类、接口时通过一个<strong>标识</strong>表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参）。</li></ul><p><strong>泛型的引入背景</strong></p><ul><li>集合容器类在设计阶段和声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在 JDK1.5 之前只能把元素类型设计为 Object，JDK1.5 之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做<strong>泛型</strong>。<code>Collection&lt;E&gt;</code>，<code>List&lt;E&gt;</code>，<code>ArrayList&lt;E&gt;</code>   这个 <code>&lt;E&gt;</code> 就是<strong>类型参数</strong>，即<strong>泛型</strong>。</li></ul><h4 id="12-2-泛型在集合中的使用"><a href="#12-2-泛型在集合中的使用" class="headerlink" title="12.2 泛型在集合中的使用"></a>12.2 泛型在集合中的使用</h4><img src="/.io//没有泛型的集合.png" alt="没有泛型的集合" style="zoom:200%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ArrayList</span> <span class="variable">list</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="comment">// 需求：存放学生的成绩</span></span><br><span class="line">    list.add(<span class="number">78</span>);</span><br><span class="line">    list.add(<span class="number">76</span>);</span><br><span class="line">    <span class="comment">// 问题一：类型不安全</span></span><br><span class="line">    <span class="comment">// list.add(&quot;Tom&quot;);</span></span><br><span class="line">    <span class="keyword">for</span>(Object score : list)&#123;</span><br><span class="line">        <span class="comment">// 问题二：强转时，可能出现 ClassCastException</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> (Integer) score;</span><br><span class="line">        System.out.println(stuScore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/.io//有泛型的集合.png" alt="有泛型的集合" style="zoom:200%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    ArrayList&lt;Integer&gt; list =  <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"><span class="comment">// 需求：存放学生的成绩</span></span><br><span class="line">    list.add(<span class="number">78</span>);</span><br><span class="line">    list.add(<span class="number">87</span>);</span><br><span class="line">    <span class="comment">// 编译时，就会进行类型检查，保证数据的安全</span></span><br><span class="line">    <span class="comment">// list.add(&quot;Tom&quot;);</span></span><br><span class="line">    <span class="comment">// 方式一：</span></span><br><span class="line">    <span class="comment">//for(Integer score : list)&#123;</span></span><br><span class="line">    <span class="comment">//        // 避免了强转操作</span></span><br><span class="line">    <span class="comment">//        System.out.println(score);</span></span><br><span class="line">    <span class="comment">//    &#125;</span></span><br><span class="line">    <span class="comment">// 方式二：</span></span><br><span class="line">    Iterator&lt;Integer&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">stuScore</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(stuScore);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();</span></span><br><span class="line">    <span class="comment">// jdk7 新特性：类型推断</span></span><br><span class="line">    Map&lt;String,Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    map.put(<span class="string">&quot;Tom&quot;</span>,<span class="number">87</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Jerry&quot;</span>,<span class="number">87</span>);</span><br><span class="line">    map.put(<span class="string">&quot;Jack&quot;</span>,<span class="number">67</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// map.put(123,&quot;ABC&quot;);</span></span><br><span class="line">    <span class="comment">// 泛型的嵌套</span></span><br><span class="line">    Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entry = map.entrySet();</span><br><span class="line">    Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entry.iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        Map.Entry&lt;String, Integer&gt; e = iterator.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> e.getKey();</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">value</span> <span class="operator">=</span> e.getValue();</span><br><span class="line">        System.out.println(key + <span class="string">&quot;----&quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>集合中使用泛型总结</strong></p><ul><li><p>集合接口或集合类在 JDK 5.0 时都修改为带泛型的结构。</p></li><li><p>在实例化集合类时，可以指明具体的泛型类型</p></li><li><p>指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如：方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。</p><ul><li>比如：<code>add(E e)  --&gt; 实例化以后：add(Integer e)</code></li></ul></li><li><p>注意点：泛型的类型必须是<strong>类</strong>，不能是基本数据类型。需要用到基本数据类型的位置，拿<strong>包装类</strong>替换。</p></li><li><p>如果实例化时，没指明泛型的类型。默认类型为 <code>java.lang.Object</code> 类型。</p></li></ul><h4 id="12-3-自定义泛型类、泛型接口、泛型方法"><a href="#12-3-自定义泛型类、泛型接口、泛型方法" class="headerlink" title="12.3 自定义泛型类、泛型接口、泛型方法"></a>12.3 自定义泛型类、泛型接口、泛型方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GenericsClass</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="comment">// 类的内部结构就可以使用类的泛型</span></span><br><span class="line">    T field;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line"><span class="comment">//        T a = new T(); // Type parameter &#x27;T&#x27; cannot be instantiated directly</span></span><br><span class="line">        <span class="type">T</span> <span class="variable">a</span> <span class="operator">=</span> (T)<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GenericsClass</span><span class="params">(T field)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.field = field;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> T <span class="title function_">getField</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> field;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setField</span><span class="params">(T field)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.field = field;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(T t)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 静态方法中不能使用类的泛型</span></span><br><span class="line">    <span class="comment">// &#x27;com.ding.generics.GenericsClass.this&#x27; cannot be referenced from a static context</span></span><br><span class="line"><span class="comment">//    public static void staticMethod(T field) &#123;</span></span><br><span class="line"><span class="comment">//        System.out.println(field);</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">GenericsInterface</span>&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &#x27;com.ding.generics.GenericsInterface.this&#x27; cannot be referenced from a static context</span></span><br><span class="line"><span class="comment">//    T field;</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// public static final </span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">method</span><span class="params">(T t)</span>; <span class="comment">// public abstract</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">staticMethod</span><span class="params">()</span>&#123;&#125;; <span class="comment">// public</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T <span class="title function_">genericsMethod</span><span class="params">(T t)</span> &#123;</span><br><span class="line"><span class="comment">//   return new T();// Type parameter &#x27;T&#x27; cannot be instantiated directly</span></span><br><span class="line">    <span class="keyword">return</span> (T)<span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>泛型方法：在方法中出现了泛型的结构，泛型参数与类的泛型参数没任何关系。换句话说，泛型方法所属的类是不是泛型类都没关系。</p></li><li><p>泛型方法可以声明为静态的。原因：泛型参数是在调用方法时确定的。并非在实例化类时确定。</p></li></ul><h4 id="12-4-泛型在继承上的体现"><a href="#12-4-泛型在继承上的体现" class="headerlink" title="12.4 泛型在继承上的体现"></a>12.4 泛型在继承上的体现</h4><ul><li>虽然类 A 是类 B 的父类，但是 <code>G&lt;A&gt;</code> 和 <code>G&lt;B&gt;</code> 二者不具备子父类关系，二者是并列关系。类 A 是类 B 的父类，<code>A&lt;G&gt;</code> 是 <code>B&lt;G&gt;</code> 的父类.</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    obj = str;</span><br><span class="line"></span><br><span class="line">    Object[] arr1 = <span class="literal">null</span>;</span><br><span class="line">    String[] arr2 = <span class="literal">null</span>;</span><br><span class="line">    arr1 = arr2;</span><br><span class="line">    <span class="comment">// 编译不通过</span></span><br><span class="line">    <span class="comment">//        Date date = new Date();</span></span><br><span class="line">    <span class="comment">//        str = date;</span></span><br><span class="line">    List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;String&gt;();</span><br><span class="line">    <span class="comment">// 此时的list1和list2的类型不具子父类关系</span></span><br><span class="line">    <span class="comment">// 编译不通过</span></span><br><span class="line">    <span class="comment">//        list1 = list2;</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        反证法：</span></span><br><span class="line"><span class="comment">        假设 list1 = list2;</span></span><br><span class="line"><span class="comment">           list1.add(123);导致混入非 String 的数据。出错。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    show(list1);</span><br><span class="line">    show1(list2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show1</span><span class="params">(List&lt;String&gt; list)</span>&#123;&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(List&lt;Object&gt; list)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    AbstractList&lt;String&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line">    ArrayList&lt;String&gt; list3 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    list1 = list3;</span><br><span class="line">    list2 = list3;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="12-5-通配符"><a href="#12-5-通配符" class="headerlink" title="12.5 通配符 ?"></a>12.5 通配符 ?</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    通配符的使用  </span></span><br><span class="line"><span class="comment">       1. 类 A 是类 B 的父类，G&lt;A&gt; 和 G&lt;B&gt; 是没关系的，二者共同的父类是：G&lt;?&gt;</span></span><br><span class="line"><span class="comment">       2. 涉及通配符的集合的数据的写入和读取</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    List&lt;Object&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;String&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;?&gt; list = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    list = list1;</span><br><span class="line">    list = list2;</span><br><span class="line">    <span class="comment">//编译通过</span></span><br><span class="line">    <span class="comment">//        print(list1);</span></span><br><span class="line">    <span class="comment">//        print(list2);</span></span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    list3.add(<span class="string">&quot;AA&quot;</span>);</span><br><span class="line">    list3.add(<span class="string">&quot;BB&quot;</span>);</span><br><span class="line">    list3.add(<span class="string">&quot;CC&quot;</span>);</span><br><span class="line">    list = list3;</span><br><span class="line">    <span class="comment">// 添加(写入)：对于 List&lt;?&gt; 就不能向其内部添加数据。</span></span><br><span class="line">    <span class="comment">// 除了添加null之外。</span></span><br><span class="line">    <span class="comment">// list.add(&quot;DD&quot;);</span></span><br><span class="line">    <span class="comment">// list.add(&#x27;?&#x27;);</span></span><br><span class="line"></span><br><span class="line">    list.add(<span class="literal">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取(读取)：允许读取数据，读取的数据类型为Object。</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">o</span> <span class="operator">=</span> list.get(<span class="number">0</span>);</span><br><span class="line">    System.out.println(o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(List&lt;?&gt; list)</span>&#123;</span><br><span class="line">    Iterator&lt;?&gt; iterator = list.iterator();</span><br><span class="line">    <span class="keyword">while</span>(iterator.hasNext())&#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> iterator.next();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">限制条件的通配符的使用：</span></span><br><span class="line"><span class="comment">        ? extends A:  G&lt;? extends A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的子类</span></span><br><span class="line"><span class="comment">        ? super A: G&lt;? super A&gt; 可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Person</span>&gt; list1 = <span class="literal">null</span>;</span><br><span class="line">    List&lt;? <span class="built_in">super</span> Person&gt; list2 = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    List&lt;Student&gt; list3 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Student&gt;();</span><br><span class="line">    List&lt;Person&gt; list4 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Person&gt;();</span><br><span class="line">    List&lt;Object&gt; list5 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Object&gt;();</span><br><span class="line"></span><br><span class="line">    list1 = list3;</span><br><span class="line">    list1 = list4;</span><br><span class="line">    <span class="comment">//        list1 = list5;</span></span><br><span class="line">    <span class="comment">//        list2 = list3;</span></span><br><span class="line">    list2 = list4;</span><br><span class="line">    list2 = list5;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 读取数据：</span></span><br><span class="line">    list1 = list3;</span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> list1.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 编译不通过</span></span><br><span class="line">    <span class="comment">// Student s = list1.get(0);</span></span><br><span class="line"></span><br><span class="line">    list2 = list4;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> list2.get(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 编译不通过</span></span><br><span class="line">    <span class="comment">//        Person obj = list2.get(0);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 写入数据：</span></span><br><span class="line">    <span class="comment">// 编译不通过</span></span><br><span class="line">    <span class="comment">//        list1.add(new Student());</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//编译通过</span></span><br><span class="line">    list2.add(<span class="keyword">new</span> <span class="title class_">Person</span>());</span><br><span class="line">    list2.add(<span class="keyword">new</span> <span class="title class_">Student</span>());</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h3 id="第13章-IO-流"><a href="#第13章-IO-流" class="headerlink" title="第13章 IO 流"></a>第13章 IO 流</h3><h4 id="13-1-File-类的使用"><a href="#13-1-File-类的使用" class="headerlink" title="13.1 File 类的使用"></a>13.1 File 类的使用</h4><p><strong>1）File 类的理解</strong></p><ol><li><p>File 类的一个对象，代表一个<strong>文件</strong>或一个<strong>文件目录</strong>（俗称：文件夹）。</p></li><li><p>File 类声明在 java.io 包下。</p></li><li><p>File 类中涉及到关于文件或文件目录的创建、删除、重命名、修改时间和文件大小等方法，并<strong>未涉及到写入或读取文件内容的操作</strong>。如果需要读取或写入文件内容，必须使用IO流来完成。</p></li><li><p>File 类的对象常会作为参数传递到流的构造器中，指明读取或写入的 “终点”。</p></li></ol><p><strong>2）File 的实例化</strong></p><p><strong>常用构造器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File(String filePath)</span><br><span class="line">File(String parentPath, String childPath)</span><br><span class="line">File(File parentFile, String childPath)</span><br></pre></td></tr></table></figure><blockquote><p><strong>路径的分类</strong></p><p><strong>相对路径</strong>：相较于某个路径下，指明的路径。</p><p><strong>绝对路径</strong>：包含盘符在内的文件或文件目录的路径。</p><p><strong>路径分隔符</strong></p><p><strong>windows 和 DOS</strong> 系统默认使用 “\” 来表示</p><p><strong>UNIX 和 URL</strong> 使用 “&#x2F;” 来表示</p></blockquote><p><strong>说明</strong></p><p><strong>IDEA 中</strong>：使用 <strong>JUnit</strong> 中的单元测试方法测试，相对路径即为当前 <strong>Module</strong> 下；使用 <strong>main()</strong> 测试，相对路径即为当前的 <strong>Project</strong> 下。</p><p><strong>Eclipse 中</strong>：不管使用单元测试方法还是使用 main() 测试，相对路径都是当前的 Project 下。</p><p><strong>3）File 类的常用方法</strong></p><p><strong>获取功能</strong><br><strong><code>public String getAbsolutePath()</code>：获取绝对路径。</strong></p><p><code>public String getPath()</code>：获取路径。</p><p><code>public String getName()</code>：获取名称。</p><p><strong><code>public String getParent()</code>：获取上层文件目录路径。若无，返回 null。</strong></p><p><code>public long length()</code>：获取文件长度（即，字节数）。不能获取目录的长度。</p><p><code>public long lastModified()</code>：获取最后一次修改的时间（毫秒值）。</p><p><code>public String list[]</code>：获取指定目录下的所有文件或者文件目录的名称数组。</p><p><code>public File[] listFiles()</code>：获取指定目录下的所有文件或者文件目录的 File 数组。</p><p><strong>重命名功能</strong><br><code>public boolean renameTo(File dest)</code>：把文件重命名为指定的文件路径。</p><p><strong>判断功能</strong></p><p><strong><code>public boolean isDirectory()</code>：判断是否为文件目录。</strong></p><p><strong><code>public boolean isFile()</code>：判断是否为文件。</strong></p><p><strong><code>public boolean existst()</code>：判断是否存在。</strong></p><p><code>public boolean canRead()</code>：判断是否可读。</p><p><code>public boolean canWrite()</code>：判断是否可写。</p><p><code>public boolean isHidden()</code>：判断是否隐藏。</p><p><strong>创建功能</strong></p><p><strong><code>public boolean createNewFile()</code>：创建文件。若文件存在，则不创建，返回 false。</strong></p><p><code>public boolean mkdir()</code>：创建文件目录。如果此文件存在，就不创建了。如果此文件目录的上层目录不存在，也不创建。</p><p><strong><code>public boolean mkdirs()</code>：创建文件目录。如果上层文件目录不存在，一并创建。</strong></p><p><strong>删除功能</strong><br><strong><code>public boolean delete()</code>：删除文件或文件夹。一经删除，不可恢复。不能删除包含文件或者文件目录的文件目录。</strong></p><h4 id="13-2-IO-流概述"><a href="#13-2-IO-流概述" class="headerlink" title="13.2 IO 流概述"></a>13.2 IO 流概述</h4><p><strong>1）流的分类</strong></p><p>按操作数据单位：字节流、字符流。</p><p>按数据的流向：输入流、输出流。</p><p>按流的角色：节点流、处理流。</p><img src="/.io//流的分类.png" alt="流的分类" style="zoom:200%;"><p><strong>2）流的体系结构</strong></p><img src="/.io//流的体系结构.png" alt="流的体系结构" style="zoom:200%;"><p><strong>重点流结构</strong></p><img src="/.io//重点流结构.png" alt="重点流结构" style="zoom:200%;"><p><strong>3）输入输出的标准化过程</strong></p><p><strong>输入过程</strong></p><p>① 创建 File 类的对象，指明读取的数据的来源。（要求此文件一定要存在）</p><p>② 创建<strong>相应的</strong>输入流，将 File 类的对象作为参数，传入流的构造器中。</p><p>③ 具体的读入过程：    创建相应的 <strong>byte[]</strong> 或 **char[]**。</p><p>④ <strong>关闭流资源</strong></p><p><strong>说明</strong>：程序中出现的异常需要使用 try-catch-finally 处理。</p><p><strong>输出过程</strong></p><p>① 创建File类的对象，指明写出的数据的位置。（不要求此文件一定要存在）。</p><p>② 创建相应的输出流，将File类的对象作为参数，传入流的构造器中。</p><p>③ 具体的写出过程：    write(char[] &#x2F; byte[] buffer, 0, len)。</p><p>④ <strong>关闭流资源</strong></p><p><strong>说明</strong>：程序中出现的异常需要使用 try-catch-finally 处理。</p><h4 id="13-3-节点流（文件流）"><a href="#13-3-节点流（文件流）" class="headerlink" title="13.3 节点流（文件流）"></a>13.3 节点流（文件流）</h4><p><strong>1）FileReader &#x2F; FileWriter 的使用</strong></p><p><strong>FileReader 的使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">将 hello.txt 文件内容读入程序中，并输出到控制台</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">说明点：</span></span><br><span class="line"><span class="comment">1. read()的理解：返回读入的一个字符。如果达到文件末尾，返回-1</span></span><br><span class="line"><span class="comment">2. 异常的处理：为了保证流资源一定可以执行关闭操作。需要使用 try-catch-finally 处理</span></span><br><span class="line"><span class="comment">3. 读入的文件一定要存在，否则就会报FileNotFoundException。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReader1</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.File类的实例化</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//2.FileReader流的实例化</span></span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(file);</span><br><span class="line">        <span class="comment">//3.读入的操作</span></span><br><span class="line">        <span class="comment">//read(char[] cbuf):返回每次读入cbuf数组中的字符的个数。如果达到文件末尾，返回-1</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//方式一：</span></span><br><span class="line">            <span class="comment">//错误的写法</span></span><br><span class="line">            <span class="comment">//                for(int i = 0;i &lt; cbuf.length;i++)&#123;</span></span><br><span class="line">            <span class="comment">//                    System.out.print(cbuf[i]);</span></span><br><span class="line">            <span class="comment">//                &#125;</span></span><br><span class="line">            <span class="comment">//正确的写法</span></span><br><span class="line">            <span class="comment">//                for(int i = 0;i &lt; len;i++)&#123;</span></span><br><span class="line">            <span class="comment">//                    System.out.print(cbuf[i]);</span></span><br><span class="line">            <span class="comment">//                &#125;</span></span><br><span class="line">            <span class="comment">//方式二：</span></span><br><span class="line">            <span class="comment">//错误的写法,对应着方式一的错误的写法</span></span><br><span class="line">            <span class="comment">//                String str = new String(cbuf);</span></span><br><span class="line">            <span class="comment">//                System.out.print(str);</span></span><br><span class="line">            <span class="comment">//正确的写法</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len);</span><br><span class="line">            System.out.print(str);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fr != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//4.资源的关闭</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fr.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>FileWriter 的使用</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">从内存中写出数据到硬盘的文件里。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">说明：</span></span><br><span class="line"><span class="comment">1. 输出操作，对应的File可以不存在的。并不会报异常</span></span><br><span class="line"><span class="comment">2.</span></span><br><span class="line"><span class="comment">     File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件。</span></span><br><span class="line"><span class="comment">     File对应的硬盘中的文件如果存在：</span></span><br><span class="line"><span class="comment">           如果流使用的构造器是：FileWriter(file,false) / FileWriter(file):对原文件的覆盖</span></span><br><span class="line"><span class="comment">           如果流使用的构造器是：FileWriter(file,true):不会对原文件覆盖，而是在原文件基础上追加内容</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.提供File类的对象，指明写出到的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">file</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello1.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//2.提供FileWriter的对象，用于数据的写出</span></span><br><span class="line">        fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(file,<span class="literal">false</span>);</span><br><span class="line">        <span class="comment">//3.写出的操作</span></span><br><span class="line">        fw.write(<span class="string">&quot;I have a dream!\n&quot;</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;you need to have a dream!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.流资源的关闭</span></span><br><span class="line">        <span class="keyword">if</span>(fw != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>文本文件的复制</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileReaderFileWriter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">FileReader</span> <span class="variable">fr</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileWriter</span> <span class="variable">fw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建File类的对象，指明读入和写出的文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello2.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//不能使用字符流来处理图片等字节数据</span></span><br><span class="line">        <span class="comment">//            File srcFile = new File(&quot;爱情与友情.jpg&quot;);</span></span><br><span class="line">        <span class="comment">//            File destFile = new File(&quot;爱情与友情1.jpg&quot;);</span></span><br><span class="line">        <span class="comment">//2.创建输入流和输出流的对象</span></span><br><span class="line">        fr = <span class="keyword">new</span> <span class="title class_">FileReader</span>(srcFile);</span><br><span class="line">        fw = <span class="keyword">new</span> <span class="title class_">FileWriter</span>(destFile);</span><br><span class="line">        <span class="comment">//3.数据的读入和写出操作</span></span><br><span class="line">        <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;<span class="comment">//记录每次读入到cbuf数组中的字符的个数</span></span><br><span class="line">        <span class="keyword">while</span>((len = fr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//每次写出len个字符</span></span><br><span class="line">            fw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.关闭流资源</span></span><br><span class="line">        <span class="comment">//方式一：</span></span><br><span class="line">        <span class="comment">//            try &#123;</span></span><br><span class="line">        <span class="comment">//                if(fw != null)</span></span><br><span class="line">        <span class="comment">//                    fw.close();</span></span><br><span class="line">        <span class="comment">//            &#125; catch (IOException e) &#123;</span></span><br><span class="line">        <span class="comment">//                e.printStackTrace();</span></span><br><span class="line">        <span class="comment">//            &#125;finally&#123;</span></span><br><span class="line">        <span class="comment">//                try &#123;</span></span><br><span class="line">        <span class="comment">//                    if(fr != null)</span></span><br><span class="line">        <span class="comment">//                        fr.close();</span></span><br><span class="line">        <span class="comment">//                &#125; catch (IOException e) &#123;</span></span><br><span class="line">        <span class="comment">//                    e.printStackTrace();</span></span><br><span class="line">        <span class="comment">//                &#125;</span></span><br><span class="line">        <span class="comment">//            &#125;</span></span><br><span class="line">        <span class="comment">//方式二：</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fw != <span class="literal">null</span>)</span><br><span class="line">                fw.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(fr != <span class="literal">null</span>)</span><br><span class="line">                fr.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）FileInputStream &#x2F; FileOutputStream 的使用</strong></p><p>对于<strong>文本文件</strong>（.txt,.java,.c,.cpp），使用<strong>字符流处理</strong>。</p><p>对于<strong>非文本文件</strong>（.jpg,.mp3,.mp4,.avi,.doc,.ppt,…），使用<strong>字节流处理</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">实现对图片的复制操作</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testFileInputOutputStream</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情.jpg&quot;</span>);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情1.jpg&quot;</span>);</span><br><span class="line">        <span class="comment">//2.造流</span></span><br><span class="line">        fis = <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(srcFile);</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">        <span class="comment">//3.复制的过程</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//4.关闭流</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>注意：相对路径在IDEA和Eclipse中使用的区别？</p><p>IDEA:</p><p>如果使用单元测试方法，相对路径基于当前的 Module 的。</p><p>如果使用 main() 测试，相对路径基于当前 Project 的。</p><p>Eclipse:</p><p>单元测试方法还是 main()，相对路径都是基于当前 Project 的。</p></blockquote><h4 id="13-4-缓冲流"><a href="#13-4-缓冲流" class="headerlink" title="13.4 缓冲流"></a>13.4 缓冲流</h4><p><strong>1）缓冲流介绍</strong></p><p>涉及到的类：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter。</p><p>作用：提供流的读取、写入的速度。</p><p>提高读写速度的原因：内部提供了一个<strong>缓冲区</strong>。默认情况下是 8kb。</p><p><strong>2）典型代码</strong></p><p><strong>使用 BufferedInputStream 和 BufferedOutputStream 处理非文本文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现文件复制的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">copyFileWithBuffered</span><span class="params">(String srcPath,String destPath)</span>&#123;</span><br><span class="line">    <span class="type">BufferedInputStream</span> <span class="variable">bis</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedOutputStream</span> <span class="variable">bos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.造文件</span></span><br><span class="line">        <span class="type">File</span> <span class="variable">srcFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(srcPath);</span><br><span class="line">        <span class="type">File</span> <span class="variable">destFile</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(destPath);</span><br><span class="line">        <span class="comment">//2.造流</span></span><br><span class="line">        <span class="comment">//2.1 造节点流</span></span><br><span class="line">        <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>((srcFile));</span><br><span class="line">        <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(destFile);</span><br><span class="line">        <span class="comment">//2.2 造缓冲流</span></span><br><span class="line">        bis = <span class="keyword">new</span> <span class="title class_">BufferedInputStream</span>(fis);</span><br><span class="line">        bos = <span class="keyword">new</span> <span class="title class_">BufferedOutputStream</span>(fos);</span><br><span class="line">        <span class="comment">//3.复制的细节：读取、写入</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = bis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            bos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.资源关闭</span></span><br><span class="line">        <span class="comment">//要求：先关闭外层的流，再关闭内层的流</span></span><br><span class="line">        <span class="keyword">if</span>(bos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bis != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略.</span></span><br><span class="line">        <span class="comment">//        fos.close();</span></span><br><span class="line">        <span class="comment">//        fis.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>使用 BufferedReader 和 BufferedWriter 处理文本文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testBufferedReaderBufferedWriter</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">BufferedWriter</span> <span class="variable">bw</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建文件和相应的流</span></span><br><span class="line">        br = <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">FileReader</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp.txt&quot;</span>)));</span><br><span class="line">        bw = <span class="keyword">new</span> <span class="title class_">BufferedWriter</span>(<span class="keyword">new</span> <span class="title class_">FileWriter</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp1.txt&quot;</span>)));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//2.读写操作</span></span><br><span class="line">        <span class="comment">//方式一：使用char[]数组</span></span><br><span class="line">        <span class="comment">//            char[] cbuf = new char[1024];</span></span><br><span class="line">        <span class="comment">//            int len;</span></span><br><span class="line">        <span class="comment">//            while((len = br.read(cbuf)) != -1)&#123;</span></span><br><span class="line">        <span class="comment">//                bw.write(cbuf,0,len);</span></span><br><span class="line">        <span class="comment">//    //            bw.flush();</span></span><br><span class="line">        <span class="comment">//            &#125;</span></span><br><span class="line">        <span class="comment">//方式二：使用String</span></span><br><span class="line">        String data;</span><br><span class="line">        <span class="keyword">while</span>((data = br.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//方法一：</span></span><br><span class="line">            <span class="comment">//                bw.write(data + &quot;\n&quot;);//data中不包含换行符</span></span><br><span class="line">            <span class="comment">//方法二：</span></span><br><span class="line">            bw.write(data);<span class="comment">//data中不包含换行符</span></span><br><span class="line">            bw.newLine();<span class="comment">//提供换行的操作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3.关闭资源</span></span><br><span class="line">        <span class="keyword">if</span>(bw != <span class="literal">null</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bw.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(br != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                br.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-5-转换流"><a href="#13-5-转换流" class="headerlink" title="13.5 转换流"></a>13.5 转换流</h4><p><strong>1）转换流介绍</strong></p><p>转换流属于字符流。</p><p>涉及到的类：</p><p>InputStreamReader（将一个字节的输入流转换为字符的输入流）。</p><p>解码：<code>字节、字节数组  ---&gt; 字符数组、字符串</code>。</p><p>OutputStreamWriter（将一个字符的输出流转换为字节的输出流）。</p><p>编码：<code>字符数组、字符串 ---&gt; 字节、字节数组。</code></p><p>说明：编码决定了解码的方式。</p><p><strong>作用</strong>：提供字节流与字符流之间的转换。</p><img src="/.io//转换流.png" alt="转换流" style="zoom:200%;"><p><strong>2）典型实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line">    <span class="comment">//        InputStreamReader isr = new InputStreamReader(fis);//使用系统默认的字符集</span></span><br><span class="line">    <span class="comment">//参数2指明了字符集，具体使用哪个字符集，取决于文件dbcp.txt保存时使用的字符集</span></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis,<span class="string">&quot;UTF-8&quot;</span>);<span class="comment">//使用系统默认的字符集</span></span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(cbuf,<span class="number">0</span>,len);</span><br><span class="line">        System.out.print(str);</span><br><span class="line">    &#125;</span><br><span class="line">    isr.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">此时处理异常的话，仍然应该使用try-catch-finally</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">综合使用InputStreamReader和OutputStreamWriter</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="comment">//1.造文件、造流</span></span><br><span class="line">    <span class="type">File</span> <span class="variable">file1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp.txt&quot;</span>);</span><br><span class="line">    <span class="type">File</span> <span class="variable">file2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;dbcp_gbk.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(file1);</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(file2);</span><br><span class="line"></span><br><span class="line">    <span class="type">InputStreamReader</span> <span class="variable">isr</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(fis,<span class="string">&quot;utf-8&quot;</span>);</span><br><span class="line">    <span class="type">OutputStreamWriter</span> <span class="variable">osw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(fos,<span class="string">&quot;gbk&quot;</span>);</span><br><span class="line">    <span class="comment">//2.读写过程</span></span><br><span class="line">    <span class="type">char</span>[] cbuf = <span class="keyword">new</span> <span class="title class_">char</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = isr.read(cbuf)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        osw.write(cbuf,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3.关闭资源</span></span><br><span class="line">    isr.close();</span><br><span class="line">    osw.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p><strong>常见的编码表</strong></p><p>ASCII：美国标准信息交换码。用一个字节的 7 位可以表示。</p><p>ISO8859-1：拉丁码表。欧洲码表，用一个字节的 8 位表示。</p><p>GB2312：中国的中文编码表。<strong>最多两个字节</strong>编码所有字符。</p><p>GBK：中国的中文编码表升级，融合了更多的中文文字符号。<strong>最多两个字节</strong>编码。</p><p>Unicode：国际标准码，融合了目前人类使用的所字符。为每个字符分配唯一的字符码。所有的文字都用<strong>两个字节</strong>来表示。</p><p>UTF-8：<strong>变长</strong>的编码方式，可用 1-4 个字节来表示一个字符。</p></blockquote><h4 id="13-6-对象流"><a href="#13-6-对象流" class="headerlink" title="13.6 对象流"></a>13.6 对象流</h4><p><strong>1）对象流介绍</strong></p><p><strong>ObjectInputStream 和 ObjectOutputStream</strong></p><ul><li><p>ObjectOutputStream：<code>内存中的对象 --&gt; 存储中的文件、通过网络传输出去</code>（序列化过程）。</p></li><li><p>ObjectInputStream：<code>存储中的文件、通过网络接收过来 --&gt; 内存中的对象</code>（反序列化过程）。</p></li></ul><p><strong>对象的序列化机制</strong></p><p>对象序列化机制允许把内存中的 <strong>Java 对象</strong>转换成平台无关的<strong>二进制流</strong>，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的 Java 对象。</p><p><strong>2）序列化代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectOutputStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        oos = <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;我爱北京天安门&quot;</span>));</span><br><span class="line">        oos.flush();<span class="comment">//刷新操作</span></span><br><span class="line"></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;王铭&quot;</span>,<span class="number">23</span>));</span><br><span class="line">        oos.flush();</span><br><span class="line"></span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;张学良&quot;</span>,<span class="number">23</span>,<span class="number">1001</span>,<span class="keyword">new</span> <span class="title class_">Account</span>(<span class="number">5000</span>)));</span><br><span class="line">        oos.flush();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(oos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//3.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                oos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3）反序列化代码实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testObjectInputStream</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ois = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;object.dat&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> ois.readObject();</span><br><span class="line">        <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String) obj;</span><br><span class="line"></span><br><span class="line">        <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line">        <span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> (Person) ois.readObject();</span><br><span class="line"></span><br><span class="line">        System.out.println(str);</span><br><span class="line">        System.out.println(p);</span><br><span class="line">        System.out.println(p1);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(ois != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ois.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>实现序列化的对象所属的类需要满足：</p><ol><li>需要实现接口：Serializable</li><li>当前类提供一个全局常量：serialVersionUID</li><li>除了当前Person类需要实现 Serializable 接口之外，还必须保证其内部所属性也必须是可序列化的。（默认情况下，基本数据类型可序列化）</li></ol><p><strong>ObjectOutputStream 和 ObjectInputStream 不能序列化 static 和 transient 修饰的成员变量。</strong></p></blockquote><h4 id="13-7-其他流"><a href="#13-7-其他流" class="headerlink" title="13.7 其他流"></a>13.7 其他流</h4><p><strong>1）标准的输入输出流</strong></p><p><code>System.in</code>：标准的输入流，默认从键盘输入。</p><p><code>System.out</code>：标准的输出流，默认从控制台输出。</p><p><strong>修改默认的输入和输出行为</strong>：System 类的 setIn(InputStream is) &#x2F; setOut(PrintStream ps) 方式重新指定输入和输出的流。</p><p><strong>2）打印流</strong></p><p><strong>PrintStream 和 PrintWriter</strong></p><p>提供了一系列重载的 print() 和 println() 方法，用于多种数据类型的输出。</p><p>System.out 返回的是 PrintStream 的实例。</p><p><strong>3）数据流</strong></p><p><strong>DataInputStream 和 DataOutputStream</strong></p><p>用于读取或写出基本数据类型的变量或字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">练习：将内存中的字符串、基本数据类型的变量写出到文件中。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">注意：处理异常的话，仍然应该使用try-catch-finally.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">// 1.</span></span><br><span class="line">    <span class="type">DataOutputStream</span> <span class="variable">dos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">    <span class="comment">// 2.</span></span><br><span class="line">    dos.writeUTF(<span class="string">&quot;刘建辰&quot;</span>);</span><br><span class="line">    dos.flush();<span class="comment">//刷新操作，将内存中的数据写入文件</span></span><br><span class="line">    dos.writeInt(<span class="number">23</span>);</span><br><span class="line">    dos.flush();</span><br><span class="line">    dos.writeBoolean(<span class="literal">true</span>);</span><br><span class="line">    dos.flush();</span><br><span class="line">    <span class="comment">// 3.</span></span><br><span class="line">    dos.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    将文件中存储的基本数据类型变量和字符串读取到内存中，保存在变量中。</span></span><br><span class="line"><span class="comment">    注意点：读取不同类型的数据的顺序要与当初写入文件时，保存的数据的顺序一致！</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">DataInputStream</span> <span class="variable">dis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;data.txt&quot;</span>));</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> dis.readUTF();</span><br><span class="line">    <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span> dis.readInt();</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">isMale</span> <span class="operator">=</span> dis.readBoolean();</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;name = &quot;</span> + name);</span><br><span class="line">    System.out.println(<span class="string">&quot;age = &quot;</span> + age);</span><br><span class="line">    System.out.println(<span class="string">&quot;isMale = &quot;</span> + isMale);</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    dis.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4）随机存储流</strong></p><p><strong>RandomAccessFile</strong></p><ol><li><p>RandomAccessFile直接继承于 java.lang.Object 类，实现了 DataInput 和 DataOutput 接口</p></li><li><p>RandomAccessFile 既可以作为一个输入流，又可以作为一个输出流</p></li><li><p>如果 RandomAccessFile 作为输出流时，写出到的文件。如果不存在，则在执行过程中自动创建。如果写出到的文件存在，则会对原文件内容进行覆盖。（默认情况下，从头覆盖）</p></li><li><p>可以通过相关的操作，实现 RandomAccessFile “插入”数据的效果。seek(int pos)</p></li></ol><p><strong>典型代码1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.</span></span><br><span class="line">        raf1 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情.jpg&quot;</span>),<span class="string">&quot;r&quot;</span>);</span><br><span class="line">        raf2 = <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;爱情与友情1.jpg&quot;</span>),<span class="string">&quot;rw&quot;</span>);</span><br><span class="line">        <span class="comment">//2.</span></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            raf2.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//3.</span></span><br><span class="line">        <span class="keyword">if</span>(raf1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf1.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(raf2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                raf2.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>典型代码2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用RandomAccessFile实现数据的插入效果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">RandomAccessFile</span> <span class="variable">raf1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomAccessFile</span>(<span class="string">&quot;hello.txt&quot;</span>,<span class="string">&quot;rw&quot;</span>);</span><br><span class="line"></span><br><span class="line">    raf1.seek(<span class="number">3</span>);<span class="comment">//将指针调到角标为3的位置</span></span><br><span class="line">    <span class="comment">//保存指针3后面的所数据到StringBuilder中</span></span><br><span class="line">    <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>((<span class="type">int</span>) <span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;hello.txt&quot;</span>).length());</span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = raf1.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        builder.append(<span class="keyword">new</span> <span class="title class_">String</span>(buffer,<span class="number">0</span>,len)) ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//调回指针，写入“xyz”</span></span><br><span class="line">    raf1.seek(<span class="number">3</span>);</span><br><span class="line">    raf1.write(<span class="string">&quot;xyz&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将StringBuilder中的数据写入到文件中</span></span><br><span class="line">    raf1.write(builder.toString().getBytes());</span><br><span class="line"></span><br><span class="line">    raf1.close();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//思考：将StringBuilder替换为ByteArrayOutputStream</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-8-Path、Paths、Files-的使用"><a href="#13-8-Path、Paths、Files-的使用" class="headerlink" title="13.8 Path、Paths、Files 的使用"></a>13.8 Path、Paths、Files 的使用</h4><p><strong>1）Path的使用（jdk7 提供）</strong></p><p>Path 替换原有的 File 类。</p><p><strong>实例化</strong></p><p>Paths 类提供的静态 get() 方法用来获取 Path 对象。</p><p><code>static Path get(String first, String ... more)</code>：用于将多个字符串串连成路径。</p><p><code>static Path get(URI uri)</code>：返回指定 uri 对应的 Path 路径。</p><p><strong>常用方法</strong></p><p><code>String toString()</code>：返回调用 Path 对象的字符串表示形式。</p><p><code>boolean startsWith(String path)</code>：判断是否以 path 路径开始。</p><p><code>boolean endsWith(String path)</code>：判断是否以 path 路径结束。</p><p><code>boolean isAbsolute()</code>：判断是否为绝对路径。</p><p><code>Path getParent()</code>：返回 Path 对象包含整个路径，不包含 Path 对象指定的文件路径。</p><p><code>Path getRoot()</code>：返回调用 Path 对象的根路径。</p><p><code>Path getFileName()</code>：返回与调用 Path 对象关联的文件名。</p><p><code>int getNameCount()</code>：返回 Path 根目录后面元素的数量。</p><p><code>Path getName(int idx)</code>：返回指定所有位置 idx 的路径名称。</p><p><code>Path toAbsolutePath()</code>：作为绝对路径返回调用 Path 对象。</p><p><code>Path resolve(Path p)</code>：合并两个路径，返回合并后的路径对应的 Path 对象。</p><p><code>File toFile()</code>：将 Path 转化为 File 类的对象。</p><p><strong>2）Files 工具类（jdk7提供）</strong></p><p>操作文件或文件目录的工具类。</p><p><strong>常用方法</strong></p><p><code>Path copy(Path src, Path dest, CopyOption … how) </code>：文件的复制。</p><p><code>Path createDirectory(Path path, FileAttribute&lt;?&gt; … attr) </code>：创建一个目录。</p><p><code>Path createFile(Path path, FileAttribute&lt;?&gt; … arr) </code>：创建一个文件。</p><p><code>void delete(Path path)</code> ：删除一个文件 目录，如果不存在，执行报错。</p><p><code>void deleteIfExists(Path path) </code>：Path 对应的文件 目录如果存在，执行删除。</p><p><code>Path move(Path src, Path dest, CopyOption…how)</code>·： 将 src 移动到 dest 位置。</p><p><code>long size(Path path) </code>： 返回 path 指定文件的大小。</p><p><strong>用于判断</strong></p><p><code>boolean exists(Path path, LinkOption … opts)</code> ：判断文件是否存在。</p><p><code>boolean isDirectory(Path path, LinkOption … opts)</code> ：判断是否是目录。</p><p><code>boolean isRegularFile(Path path, LinkOption … opts) </code>：判断是否是文件。</p><p><code>boolean isHidden(Path path) </code>：判断是否是隐藏文件。</p><p><code>boolean isReadable(Path path) </code>：判断文件是否可读。</p><p><code>boolean isWritable(Path path) </code>：判断文件是否可写。</p><p><code>boolean notExists(Path path, LinkOption … opts) </code>：判断文件是否不存在。</p><p><strong>用于操作内容</strong></p><p><code>SeekableByteChannel newByteChannel(Path path, OpenOption…how) </code>：获取与指定文件的连接，how 指定打开方式。</p><p><code>DirectoryStream&lt;Path&gt; newDirectoryStream(Path path)</code>：打开 path 指定的目录。</p><p><code>InputStream newInputStream(Path path, OpenOption…how)</code>：获取 InputStream 对象。</p><p><code>OutputStream newOutputStream(Path path, OpenOption…how) </code>：获取 OutputStream 对象。</p><h3 id="第14章-反射（Reflection）"><a href="#第14章-反射（Reflection）" class="headerlink" title="第14章 反射（Reflection）"></a>第14章 反射（Reflection）</h3><h4 id="14-1-反射的概念"><a href="#14-1-反射的概念" class="headerlink" title="14.1 反射的概念"></a>14.1 反射的概念</h4><p>反射是被视为动态语言的关键，反射机制允许程序在执行期借助于 Reflection API 取得任何类的内部信息，并能直接操作任意对象的内部属性及方法。</p><p><strong>框架 &#x3D; 反射 + 注解 + 设计模式。</strong></p><p><strong>1）反射机制的“动态性”</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//体会反射的动态性</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; <span class="number">100</span>;i++)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Random</span>().nextInt(<span class="number">3</span>);<span class="comment">//0,1,2</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">classPath</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">switch</span>(num)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                classPath = <span class="string">&quot;java.util.Date&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                classPath = <span class="string">&quot;java.lang.Object&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                classPath = <span class="string">&quot;com.atguigu.java.Person&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> getInstance(classPath);</span><br><span class="line">            System.out.println(obj);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">创建一个指定类的对象。</span></span><br><span class="line"><span class="comment">classPath: 指定类的全类名</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getInstance</span><span class="params">(String classPath)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">   <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span>  Class.forName(classPath);</span><br><span class="line">   <span class="keyword">return</span> clazz.newInstance();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）功能</strong></p><ol><li>在运行时判断任意一个对象所属的类。</li><li>在运行时构造任意一个类的对象。</li><li>在运行时判断任意一个类所具有的成员变量和方法。</li><li>在运行时获取泛型信息。</li><li>在运行时调用任意一个对象的成员变量和方法。</li><li>在运行时处理注解。</li><li>生成动态代理。</li></ol><p><strong>3）相关API</strong></p><p>java.lang.Class: 反射的源头</p><p>java.lang.reflect.Method</p><p>java.lang.reflect.Field</p><p>java.lang.reflect.Constructor</p><p>….</p><h4 id="14-2-Class-类"><a href="#14-2-Class-类" class="headerlink" title="14.2 Class 类"></a>14.2 Class 类</h4><p><strong>1）Class 类的理解</strong></p><p><strong>类的加载过程</strong></p><p>程序经过 javac.ex e命令以后，会生成一个或多个字节码文件(.class结尾);接着我们使用 java.exe 命令对某个字节码文件进行解释运行。相当于将某个字节码文件<br>加载到内存中。此过程就称为<strong>类的加载</strong>。加载到内存中的类，我们就称为<strong>运行时类</strong>，此运行时类，就作为 Class 的一个实例。换句话说，<strong>Class 的实例就对应着一个运行时类。</strong>加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类。</p><p><strong>2）获取 Class 实例的方式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方式一：调用运行时类的属性：.class</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz1</span> <span class="operator">=</span> Person.class;</span><br><span class="line">System.out.println(clazz1);</span><br><span class="line"><span class="comment">//方式二：通过运行时类的对象,调用getClass()</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz2</span> <span class="operator">=</span> p1.getClass();</span><br><span class="line">System.out.println(clazz2);</span><br><span class="line"><span class="comment">//方式三：调用Class的静态方法：forName(String classPath)</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz3</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.atguigu.java.Person&quot;</span>);</span><br><span class="line"><span class="comment">// clazz3 = Class.forName(&quot;java.lang.String&quot;);</span></span><br><span class="line">System.out.println(clazz3);</span><br><span class="line"></span><br><span class="line">System.out.println(clazz1 == clazz2);</span><br><span class="line">System.out.println(clazz1 == clazz3);</span><br><span class="line"></span><br><span class="line"><span class="comment">//方式四：使用类的加载器：ClassLoader  (了解)</span></span><br><span class="line"><span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ReflectionTest.class.getClassLoader();</span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz4</span> <span class="operator">=</span> classLoader.loadClass(<span class="string">&quot;com.atguigu.java.Person&quot;</span>);</span><br><span class="line">System.out.println(clazz4);</span><br><span class="line"></span><br><span class="line">System.out.println(clazz1 == clazz4);</span><br></pre></td></tr></table></figure><p><strong>Class 实例可以是：</strong></p><ol><li>class：内部类，成员（成员内部类，静态内部类），局部内部类，匿名内部类。</li><li>interface：接口。</li><li>[]：数组。</li><li>enum：枚举。</li><li>annotation：注解。</li><li>primitive type：基本数据类型。</li><li>void</li></ol><blockquote><p><strong>创建类的对象的方式</strong></p><p>方式一：new + 构造器</p><p>方式二：要创建 Xxx 类的对象，可以考虑：Xxx、Xxxs、XxxFactory、XxxBuilder 类中查看是否有静态方法的存在。可以调用其静态方法，创建 Xxx 对象。</p><p>方式三：通过反射</p></blockquote><h4 id="14-3-类加载器"><a href="#14-3-类加载器" class="headerlink" title="14.3 类加载器"></a>14.3 类加载器</h4><p><strong>1）类的加载过程</strong></p><img src="/.io//类的加载过程.png" alt="类的加载过程" style="zoom:200%;"><p><strong>2）类的加载器的作用</strong></p><p><strong>3）类的加载器的分类</strong></p><img src="/.io//类的加载器的分类.png" alt="类的加载器的分类" style="zoom:200%;"><p><strong>4）Java 类编译、运行的执行的流程</strong></p><img src="/.io//执行的流程.png" alt="执行的流程" style="zoom:200%;"><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用Classloader加载src目录下的配置文件</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Properties</span> <span class="variable">pros</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">    <span class="comment">//此时的文件默认在当前的module下。</span></span><br><span class="line">    <span class="comment">//读取配置文件的方式一：</span></span><br><span class="line">    <span class="comment">//        FileInputStream fis = new FileInputStream(&quot;jdbc.properties&quot;);</span></span><br><span class="line">    <span class="comment">//        FileInputStream fis = new FileInputStream(&quot;src\\jdbc1.properties&quot;);</span></span><br><span class="line">    <span class="comment">//        pros.load(fis);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取配置文件的方式二：使用ClassLoader</span></span><br><span class="line">    <span class="comment">//配置文件默认识别为：当前module的src下</span></span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> ClassLoaderTest.class.getClassLoader();</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> classLoader.getResourceAsStream(<span class="string">&quot;jdbc1.properties&quot;</span>);</span><br><span class="line">    pros.load(is);</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">user</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">    <span class="type">String</span> <span class="variable">password</span> <span class="operator">=</span> pros.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;user = &quot;</span> + user + <span class="string">&quot;,password = &quot;</span> + password);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-4-反射的应用"><a href="#14-4-反射的应用" class="headerlink" title="14.4 反射的应用"></a>14.4 反射的应用</h4><p><strong>1）创建运行时类的对象</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;Person&gt; clazz = Person.class;</span><br><span class="line"></span><br><span class="line"><span class="type">Person</span> <span class="variable">obj</span> <span class="operator">=</span> clazz.newInstance();</span><br><span class="line">System.out.println(obj);</span><br></pre></td></tr></table></figure><p><code>newInstance()</code>：调用此方法，创建对应的运行时类的对象。内部调用了运行时类的空参的构造器。</p><p>要想此方法正常的创建运行时类的对象，要求：</p><ol><li>运行时类必须提供空参的构造器.</li><li>空参的构造器的访问权限得够。通常，设置为public。</li></ol><p>在 JavaBean 中要求提供一个 public 的空参构造器。原因：</p><ol><li>便于通过反射，创建运行时类的对象.</li><li>便于子类继承此运行时类时，默认调用super()时，保证父类此构造器.</li></ol><p><strong>2）获取运行时类的完整结构</strong></p><p>通过反射，获取对应的运行时类中所有的属性、方法、构造器、父类、接口、父类的泛型、包、注解、异常等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取属性结构</span></span><br><span class="line">    <span class="comment">//getFields():获取当前运行时类及其父类中声明为public访问权限的属性</span></span><br><span class="line">    Field[] fields = clazz.getFields();</span><br><span class="line">    <span class="keyword">for</span>(Field f : fields)&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getDeclaredFields():获取当前运行时类中声明的所属性。（不包含父类中声明的属性</span></span><br><span class="line">    Field[] declaredFields = clazz.getDeclaredFields();</span><br><span class="line">    <span class="keyword">for</span>(Field f : declaredFields)&#123;</span><br><span class="line">        System.out.println(f);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//getMethods():获取当前运行时类及其所父类中声明为public权限的方法</span></span><br><span class="line">    Method[] methods = clazz.getMethods();</span><br><span class="line">    <span class="keyword">for</span>(Method m : methods)&#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//getDeclaredMethods():获取当前运行时类中声明的所方法。（不包含父类中声明的方法</span></span><br><span class="line">    Method[] declaredMethods = clazz.getDeclaredMethods();</span><br><span class="line">    <span class="keyword">for</span>(Method m : declaredMethods)&#123;</span><br><span class="line">        System.out.println(m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取构造器结构</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line">    <span class="comment">//getConstructors():获取当前运行时类中声明为public的构造器</span></span><br><span class="line">    Constructor[] constructors = clazz.getConstructors();</span><br><span class="line">    <span class="keyword">for</span>(Constructor c : constructors)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//getDeclaredConstructors():获取当前运行时类中声明的所的构造器</span></span><br><span class="line">    Constructor[] declaredConstructors = clazz.getDeclaredConstructors();</span><br><span class="line">    <span class="keyword">for</span>(Constructor c : declaredConstructors)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类的父类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">superclass</span> <span class="operator">=</span> clazz.getSuperclass();</span><br><span class="line">    System.out.println(superclass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类的带泛型的父类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line">    System.out.println(genericSuperclass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类的带泛型的父类的泛型</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    代码：逻辑性代码  vs 功能性代码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="type">Type</span> <span class="variable">genericSuperclass</span> <span class="operator">=</span> clazz.getGenericSuperclass();</span><br><span class="line">    <span class="type">ParameterizedType</span> <span class="variable">paramType</span> <span class="operator">=</span> (ParameterizedType) genericSuperclass;</span><br><span class="line">    <span class="comment">//获取泛型类型</span></span><br><span class="line">    Type[] actualTypeArguments = paramType.getActualTypeArguments();</span><br><span class="line">    <span class="comment">//        System.out.println(actualTypeArguments[0].getTypeName());</span></span><br><span class="line">    System.out.println(((Class)actualTypeArguments[<span class="number">0</span>]).getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类实现的接口</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    Class[] interfaces = clazz.getInterfaces();</span><br><span class="line">    <span class="keyword">for</span>(Class c : interfaces)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">//获取运行时类的父类实现的接口</span></span><br><span class="line">    Class[] interfaces1 = clazz.getSuperclass().getInterfaces();</span><br><span class="line">    <span class="keyword">for</span>(Class c : interfaces1)&#123;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    获取运行时类所在的包</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="type">Package</span> <span class="variable">pack</span> <span class="operator">=</span> clazz.getPackage();</span><br><span class="line">    System.out.println(pack);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">获取运行时类声明的注解</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    Annotation[] annotations = clazz.getAnnotations();</span><br><span class="line">    <span class="keyword">for</span>(Annotation annos : annotations)&#123;</span><br><span class="line">        System.out.println(annos);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3）调用运行时类的指定结构</strong></p><p><strong>调用指定的属性</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testField1</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1. getDeclaredField(String fieldName):获取运行时类中指定变量名的属性</span></span><br><span class="line">    <span class="type">Field</span> <span class="variable">name</span> <span class="operator">=</span> clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证当前属性是可访问的</span></span><br><span class="line">    name.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//3.获取、设置指定对象的此属性值</span></span><br><span class="line">    name.set(p,<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line">    System.out.println(name.get(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用指定的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> (Person) clazz.newInstance();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        1.获取指定的某个方法</span></span><br><span class="line"><span class="comment">        getDeclaredMethod():参数1 ：指明获取的方法的名称  参数2：指明获取的方法的形参列表</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="type">Method</span> <span class="variable">show</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;show&quot;</span>, String.class);</span><br><span class="line">    <span class="comment">//2.保证当前方法是可访问的</span></span><br><span class="line">    show.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        3. 调用方法的invoke():参数1：方法的调用者  参数2：给方法形参赋值的实参</span></span><br><span class="line"><span class="comment">        invoke()的返回值即为对应类中调用的方法的返回值。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> show.invoke(p,<span class="string">&quot;CHN&quot;</span>); <span class="comment">//String nation = p.show(&quot;CHN&quot;);</span></span><br><span class="line">    System.out.println(returnValue);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;*************如何调用静态方法*****************&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// private static void showDesc()</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Method</span> <span class="variable">showDesc</span> <span class="operator">=</span> clazz.getDeclaredMethod(<span class="string">&quot;showDesc&quot;</span>);</span><br><span class="line">    showDesc.setAccessible(<span class="literal">true</span>);</span><br><span class="line">    <span class="comment">//如果调用的运行时类中的方法没返回值，则此invoke()返回null</span></span><br><span class="line">    <span class="comment">//        Object returnVal = showDesc.invoke(null);</span></span><br><span class="line">    <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> showDesc.invoke(Person.class);</span><br><span class="line">    System.out.println(returnVal);<span class="comment">//null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>调用指定的构造器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Person.class;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//private Person(String name)</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    1.获取指定的构造器</span></span><br><span class="line"><span class="comment">    getDeclaredConstructor():参数：指明构造器的参数列表</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clazz.getDeclaredConstructor(String.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.保证此构造器是可访问的</span></span><br><span class="line">    constructor.setAccessible(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.调用此构造器创建运行时类的对象</span></span><br><span class="line">    <span class="type">Person</span> <span class="variable">per</span> <span class="operator">=</span> (Person) constructor.newInstance(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">    System.out.println(per);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>4）动态代理</strong></p><p>代理模式的原理：使用一个代理将对象包装起来, 然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上。 </p><p><strong>静态代理</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实现Runnable接口的方法创建多线程。</span></span><br><span class="line">Class MyThread <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;&#125; <span class="comment">//相当于被代理类</span></span><br><span class="line">Class Thread <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;&#125; <span class="comment">//相当于代理类</span></span><br><span class="line">main()&#123;</span><br><span class="line">    <span class="type">MyThread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(t);</span><br><span class="line">    thread.start();<span class="comment">//启动线程；调用线程的run()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>静态代理的缺点</strong></p><p>① 代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。</p><p>② 每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。</p><p><strong>动态代理</strong></p><p>动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象。</p><p><strong>需要解决的两个主要问题</strong></p><p>问题一：如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象。 （<strong>通过 Proxy.newProxyInstance() 实现</strong>）</p><p>问题二：当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a。(<strong>通过 InvocationHandler 接口的实现类及其方法 invoke()</strong>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 动态代理的举例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Human</span>&#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">getBelief</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SuperMan</span> <span class="keyword">implements</span> <span class="title class_">Human</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getBelief</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;I believe I can fly!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">(String food)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我喜欢吃&quot;</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">HumanUtil</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====================通用方法一====================&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;====================通用方法二====================&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyFactory</span>&#123;</span><br><span class="line">    <span class="comment">//调用此方法，返回一个代理类的对象。解决问题一</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getProxyInstance</span><span class="params">(Object obj)</span>&#123;<span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        <span class="type">MyInvocationHandler</span> <span class="variable">handler</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyInvocationHandler</span>();</span><br><span class="line"></span><br><span class="line">        handler.bind(obj);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyInvocationHandler</span> <span class="keyword">implements</span> <span class="title class_">InvocationHandler</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object obj;<span class="comment">//需要使用被代理类的对象进行赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bind</span><span class="params">(Object obj)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当我们通过代理类的对象，调用方法a时，就会自动的调用如下的方法：invoke()</span></span><br><span class="line">    <span class="comment">//将被代理类要执行的方法a的功能就声明在invoke()中</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">HumanUtil</span> <span class="variable">util</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HumanUtil</span>();</span><br><span class="line">        util.method1();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法</span></span><br><span class="line">        <span class="comment">//obj:被代理类的对象</span></span><br><span class="line">        <span class="type">Object</span> <span class="variable">returnValue</span> <span class="operator">=</span> method.invoke(obj,args);</span><br><span class="line"></span><br><span class="line">        util.method2();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//上述方法的返回值就作为当前类中的invoke()的返回值。</span></span><br><span class="line">        <span class="keyword">return</span> returnValue;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SuperMan</span> <span class="variable">superMan</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SuperMan</span>();</span><br><span class="line">        <span class="comment">//proxyInstance:代理类的对象</span></span><br><span class="line">        <span class="type">Human</span> <span class="variable">proxyInstance</span> <span class="operator">=</span> (Human) ProxyFactory.getProxyInstance(superMan);</span><br><span class="line">        <span class="comment">//当通过代理类对象调用方法时，会自动的调用被代理类中同名的方法</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">belief</span> <span class="operator">=</span> proxyInstance.getBelief();</span><br><span class="line">        System.out.println(belief);</span><br><span class="line">        proxyInstance.eat(<span class="string">&quot;四川麻辣烫&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;*****************************&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">NikeClothFactory</span> <span class="variable">nikeClothFactory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NikeClothFactory</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ClothFactory</span> <span class="variable">proxyClothFactory</span> <span class="operator">=</span> (ClothFactory) ProxyFactory.getProxyInstance(nikeClothFactory);</span><br><span class="line"></span><br><span class="line">        proxyClothFactory.produceCloth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第15章-网络编程"><a href="#第15章-网络编程" class="headerlink" title="第15章 网络编程"></a>第15章 网络编程</h3><h4 id="15-1-InetAddress-类的使用"><a href="#15-1-InetAddress-类的使用" class="headerlink" title="15.1 InetAddress 类的使用"></a>15.1 InetAddress 类的使用</h4><p><strong>1）网络通信的实现</strong></p><ol><li><p>准确地定位网络上一台或多台主机；定位主机上的特定的应用：<strong>IP 和端口号</strong>。</p></li><li><p>找到主机后可靠高效地进行数据传输：<strong>提供网络通信协议</strong>（TCP&#x2F;IP参考模型（应用层、传输层、网络层、物理+数据链路层））。</p></li></ol><p><strong>2）IP 和端口号</strong></p><p><strong>IP</strong>：<strong>唯一的标识</strong>，Internet 上的计算机（通信实体）。</p><ol><li>在 Java 中使用 InetAddress 类代表 IP。</li><li>IP分类：IPv4 和 IPv6；万维网 和 局域网。</li><li>域名:   <a href="http://www.baidu.com/">www.baidu.com</a>   <a href="http://www.mi.com/">www.mi.com</a>  <a href="http://www.sina.com/">www.sina.com</a>  <a href="http://www.jd.com/">www.jd.com</a></li><li>域名解析：域名容易记忆，当在连接网络时输入一个主机的域名后，域名服务器（DNS）负责将域名转化成IP地址，这样才能和主机建立连接。</li><li>本地回路地址：127.0.0.1 对应 localhost</li></ol><p><strong>端口号</strong>：正在计算机上运行的进程。</p><ul><li>要求：不同的进程不同的端口号。</li><li>范围：被规定为一个 16 位的整数 0~65535。</li></ul><p><strong>套接字</strong>：端口号与 IP 地址的组合得出一个网络套接字（Socket）。</p><p><strong>3）InetAddress 类</strong></p><ul><li><p>此类的一个对象就代表着一个具体的 IP 地址。</p></li><li><p><strong>实例化</strong>：getByName(String host) 、 getLocalHost()。</p></li><li><p><strong>常用方法</strong>：getHostName() &#x2F; getHostAddress()。</p></li></ul><p><strong>4）网络通信协议</strong></p><img src="/.io//参考模型.png" alt="参考模型" style="zoom:150%;"><p><strong>TCP 和 UDP 的区别</strong></p><p><strong>TCP 协议</strong></p><ol><li>使用 TCP 协议前，须先建立 TCP 连接，形成传输数据通道。</li><li>传输前，采用“三次握手”方式，<strong>点对点</strong>通信，是<strong>可靠的</strong>。</li><li>TCP 协议进行通信的两个应用进程：客户端、服务器。</li><li>在连接中可<strong>进行大数据量的传输</strong>。</li><li>传输完毕，<strong>须释放已建立的连接，效率低</strong>。</li></ol><p><strong>UDP 协议</strong></p><ol><li>将数据、源、目的封装成数据包，不需要建立连接。</li><li>每个数据报的大小限制在 64k 内。</li><li>发送不管对方是否准备好，接收方收到也不确认，故是不可靠的。</li><li>可以广播发送。</li><li>发送数据结束时无需是否资源，开销小，速度快。</li></ol><p><strong>TCP 三次握手和四次挥手</strong></p><img src="/.io//TCP 三次握手.png" alt="TCP 三次握手" style="zoom: 200%;"><img src="/.io//TCP 四次握手.png" alt="TCP 四次握手" style="zoom: 200%;"><h4 id="15-2-TCP-网络编程"><a href="#15-2-TCP-网络编程" class="headerlink" title="15.2 TCP 网络编程"></a>15.2 TCP 网络编程</h4><p><strong>1）代码示例1</strong>：客户端发送信息给服务端，服务端将数据显示在控制台上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span>  &#123;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建Socket对象，指明服务器端的ip和端口号</span></span><br><span class="line">        <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getByName(<span class="string">&quot;192.168.14.100&quot;</span>);</span><br><span class="line">        socket = <span class="keyword">new</span> <span class="title class_">Socket</span>(inet,<span class="number">8899</span>);</span><br><span class="line">        <span class="comment">//2.获取一个输出流，用于输出数据</span></span><br><span class="line">        os = socket.getOutputStream();</span><br><span class="line">        <span class="comment">//3.写出数据的操作</span></span><br><span class="line">        os.write(<span class="string">&quot;你好，我是客户端mm&quot;</span>.getBytes());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//4.资源的关闭</span></span><br><span class="line">        <span class="keyword">if</span>(os != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                os.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(socket != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//服务端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span>  &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//1.创建服务器端的ServerSocket，指明自己的端口号</span></span><br><span class="line">        ss = <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">8899</span>);</span><br><span class="line">        <span class="comment">//2.调用accept()表示接收来自于客户端的socket</span></span><br><span class="line">        socket = ss.accept();</span><br><span class="line">        <span class="comment">//3.获取输入流</span></span><br><span class="line">        is = socket.getInputStream();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不建议这样写，可能会乱码</span></span><br><span class="line">        <span class="comment">//        byte[] buffer = new byte[1024];</span></span><br><span class="line">        <span class="comment">//        int len;</span></span><br><span class="line">        <span class="comment">//        while((len = is.read(buffer)) != -1)&#123;</span></span><br><span class="line">        <span class="comment">//            String str = new String(buffer,0,len);</span></span><br><span class="line">        <span class="comment">//            System.out.print(str);</span></span><br><span class="line">        <span class="comment">//        &#125;</span></span><br><span class="line">        <span class="comment">//4.读取输入流中的数据</span></span><br><span class="line">        baos = <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">5</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            baos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;收到了来自于：&quot;</span> + socket.getInetAddress().getHostAddress() + <span class="string">&quot;的数据&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(baos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//5.关闭资源</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                baos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(socket != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ss != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ss.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）代码示例2</strong>：客户端发送文件给服务端，服务端将文件保存在本地。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">9090</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty.jpg&quot;</span>));</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//5.</span></span><br><span class="line">    fis.close();</span><br><span class="line">    os.close();</span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9090</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty1.jpg&quot;</span>));</span><br><span class="line">    <span class="comment">//5.</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//6.</span></span><br><span class="line">    fos.close();</span><br><span class="line">    is.close();</span><br><span class="line">    socket.close();</span><br><span class="line">    ss.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">代码示例<span class="number">3</span>：从客户端发送文件给服务端，服务端保存到本地。并返回“发送成功”给客户端。并关闭相应的连接。</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">client</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Socket</span>(InetAddress.getByName(<span class="string">&quot;127.0.0.1&quot;</span>),<span class="number">9090</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fis</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty.jpg&quot;</span>));</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = fis.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        os.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//关闭数据的输出</span></span><br><span class="line">    socket.shutdownOutput();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.接收来自于服务器端的数据，并显示到控制台上</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line">    <span class="type">byte</span>[] bufferr = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">20</span>];</span><br><span class="line">    <span class="type">int</span> len1;</span><br><span class="line">    <span class="keyword">while</span>((len1 = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        baos.write(buffer,<span class="number">0</span>,len1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(baos.toString());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.</span></span><br><span class="line">    fis.close();</span><br><span class="line">    os.close();</span><br><span class="line">    socket.close();</span><br><span class="line">    baos.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里涉及到的异常，应该使用try-catch-finally处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">server</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="comment">//1.</span></span><br><span class="line">    <span class="type">ServerSocket</span> <span class="variable">ss</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServerSocket</span>(<span class="number">9090</span>);</span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="type">Socket</span> <span class="variable">socket</span> <span class="operator">=</span> ss.accept();</span><br><span class="line">    <span class="comment">//3.</span></span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> socket.getInputStream();</span><br><span class="line">    <span class="comment">//4.</span></span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(<span class="string">&quot;beauty2.jpg&quot;</span>));</span><br><span class="line">    <span class="comment">//5.</span></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="type">int</span> len;</span><br><span class="line">    <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">        fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;图片传输完成&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.服务器端给予客户端反馈</span></span><br><span class="line">    <span class="type">OutputStream</span> <span class="variable">os</span> <span class="operator">=</span> socket.getOutputStream();</span><br><span class="line">    os.write(<span class="string">&quot;你好，美女，照片我已收到，非常漂亮！&quot;</span>.getBytes());</span><br><span class="line"></span><br><span class="line">    <span class="comment">//7.</span></span><br><span class="line">    fos.close();</span><br><span class="line">    is.close();</span><br><span class="line">    socket.close();</span><br><span class="line">    ss.close();</span><br><span class="line">    os.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-3-UDP-网络编程"><a href="#15-3-UDP-网络编程" class="headerlink" title="15.3 UDP 网络编程"></a>15.3 UDP 网络编程</h4><p><strong>代码示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//发送端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sender</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>();</span><br><span class="line"></span><br><span class="line">    <span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;我是UDP方式发送的导弹&quot;</span>;</span><br><span class="line">    <span class="type">byte</span>[] data = str.getBytes();</span><br><span class="line">    <span class="type">InetAddress</span> <span class="variable">inet</span> <span class="operator">=</span> InetAddress.getLocalHost();</span><br><span class="line">    <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(data,<span class="number">0</span>,data.length,inet,<span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">    socket.send(packet);</span><br><span class="line"></span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接收端</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">receiver</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">DatagramSocket</span> <span class="variable">socket</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramSocket</span>(<span class="number">9090</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">100</span>];</span><br><span class="line">    <span class="type">DatagramPacket</span> <span class="variable">packet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DatagramPacket</span>(buffer,<span class="number">0</span>,buffer.length);</span><br><span class="line"></span><br><span class="line">    socket.receive(packet);</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="keyword">new</span> <span class="title class_">String</span>(packet.getData(),<span class="number">0</span>,packet.getLength()));</span><br><span class="line"></span><br><span class="line">    socket.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-4-URL-编程"><a href="#15-4-URL-编程" class="headerlink" title="15.4  URL 编程"></a>15.4  URL 编程</h4><p><strong>1）URL（Uniform Resource Locator）</strong>：统一资源定位符，对应着互联网的某一资源地址。</p><p><strong>URL 的5个基本结构</strong>     </p><table><thead><tr><th>http:&#x2F;&#x2F;</th><th>localhost:</th><th>8080</th><th>&#x2F;examples&#x2F;beauty.jpg</th><th>?username&#x3D;Tom</th></tr></thead><tbody><tr><td>协议</td><td>主机名</td><td>端口号</td><td>资源地址</td><td>参数列表</td></tr></tbody></table><p><strong>实例化</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg?username=Tom&quot;</span>);</span><br></pre></td></tr></table></figure><p><strong>2）常用方法</strong></p><p><code>public String getProtocol()</code>：获取该 URL 的协议名。</p><p><code>public String getHost()</code>：获取该 URL 的主机名。</p><p><code>public String getPort()</code>：获取该 URL 的端口号。</p><p><strong><code>public String getPath()</code>：获取该 URL 的文件路径。</strong></p><p><code>public String getFile()</code>：获取该 URL 的文件名。</p><p><strong><code>public String getQuery()</code>：获取该 URL 的查询名。</strong></p><p><strong>3）读取、下载对应的 url 资源</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">HttpURLConnection</span> <span class="variable">urlConnection</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">InputStream</span> <span class="variable">is</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="type">FileOutputStream</span> <span class="variable">fos</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">URL</span>(<span class="string">&quot;http://localhost:8080/examples/beauty.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        urlConnection = (HttpURLConnection) url.openConnection();</span><br><span class="line"></span><br><span class="line">        urlConnection.connect();</span><br><span class="line"></span><br><span class="line">        is = urlConnection.getInputStream();</span><br><span class="line">        fos = <span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(<span class="string">&quot;day10\\beauty3.jpg&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] buffer = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="type">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len = is.read(buffer)) != -<span class="number">1</span>)&#123;</span><br><span class="line">            fos.write(buffer,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;下载完成&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭资源</span></span><br><span class="line">        <span class="keyword">if</span>(is != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fos != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                fos.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(urlConnection != <span class="literal">null</span>)&#123;</span><br><span class="line">            urlConnection.disconnect();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第16章-注解（Annotation）"><a href="#第16章-注解（Annotation）" class="headerlink" title="第16章 注解（Annotation）"></a>第16章 注解（Annotation）</h3><h4 id="16-1-注解的理解"><a href="#16-1-注解的理解" class="headerlink" title="16.1 注解的理解"></a>16.1 注解的理解</h4><ul><li><p>JDK 5.0 新增的功能</p></li><li><p>注解其实就是代码里的<strong>特殊标记</strong>，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用注解，程序员可以在不改变原逻辑的情况下，在源文件中嵌入一些补充信息。</p></li><li><p>在 Java SE 中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在 JavaEE 和 Android 中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替 Java EE 旧版中所遗留的繁冗代码和 XML 配置等。</p></li><li><p><strong>框架 &#x3D; 注解 + 反射机制 + 设计模式</strong></p></li></ul><h4 id="16-2-使用示例"><a href="#16-2-使用示例" class="headerlink" title="16.2 使用示例"></a>16.2 使用示例</h4><ol><li>生成文档相关的注解</li><li>在编译时进行格式检查（JDK 内置的基本注解）<ul><li>@Override：限定重写父类方法, 该注解只能用于方法。</li><li>@Deprecated：用于表示所修饰的元素（类, 方法等）已过时。通常是因为所修饰的结构危险或存在更好的选择。</li><li>@SuppressWarnings：抑制编译器警告。</li></ul></li></ol><h4 id="16-3-自定义注解"><a href="#16-3-自定义注解" class="headerlink" title="16.3 自定义注解"></a>16.3 自定义注解</h4><p><strong>参照 @SuppressWarnings 定义</strong></p><ol><li><p>注解声明为：@interface。</p></li><li><p>内部定义成员，通常使用 value 表示。</p></li><li><p>可以指定成员的默认值，使用 default 定义。</p></li><li><p>如果自定义注解没成员，表明是一个标识作用。</p></li></ol><p><strong>说明</strong></p><ul><li><p>如果注解有成员，在使用注解时，需要指明成员的值。</p></li><li><p>自定义注解必须配上注解的信息处理流程(使用反射)才意义。</p></li><li><p>自定义注解通过都会指明两个元注解：Retention、Target。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Repeatable(MyAnnotations.class)</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE,TYPE_PARAMETER,TYPE_USE&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line"></span><br><span class="line">    String <span class="title function_">value</span><span class="params">()</span> <span class="keyword">default</span> <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="16-4-元注解"><a href="#16-4-元注解" class="headerlink" title="16.4 元注解"></a>16.4 元注解</h4><ul><li>对现有的注解进行解释说明的注解。</li></ul><p><strong>JDK 提供的 4 种元注解</strong></p><ol><li>Retention：指定所修饰的 Annotation 的生命周期：SOURCE\CLASS（默认行为 RUNTIME 只声明为 RUNTIME 生命周期的注解，才能通过反射获取。）</li><li>Target：用于指定被修饰的 Annotation 能用于修饰哪些程序元素</li><li>Documented：表示所修饰的注解在被 javadoc 解析时，保留下来。</li><li>Inherited：被它修饰的 Annotation 将具继承性。</li></ol><h4 id="16-5-获取注解信息"><a href="#16-5-获取注解信息" class="headerlink" title="16.5 获取注解信息"></a>16.5 获取注解信息</h4><p><strong>1）通过反射来进行获取、调用。</strong></p><ul><li>要求此注解的元注解 Retention 中声明的生命周期状态为：RUNTIME.</li></ul><p><strong>2）JDK8中注解的新特性</strong></p><ol><li><strong>可重复注解</strong><ul><li>在 MyAnnotation 上声明 @Repeatable，成员值为 MyAnnotations.class。</li><li>MyAnnotation 的 Target 和 Retention 等元注解与 MyAnnotations 相同。</li></ul></li><li><strong>类型注解</strong><ul><li><code>ElementType.TYPE_PARAMETER</code> 表示该注解能写在类型变量的<strong>声明语句</strong>中，如：泛型声明。</li><li><code>ElementType.TYPE_USE</code> 表示该注解能写在使用类型的<strong>任何语句</strong>中。</li></ul></li></ol><h3 id="第17章-枚举类（Enumeration）"><a href="#第17章-枚举类（Enumeration）" class="headerlink" title="第17章 枚举类（Enumeration）"></a>第17章 枚举类（Enumeration）</h3><h4 id="17-1-枚举类的说明"><a href="#17-1-枚举类的说明" class="headerlink" title="17.1 枚举类的说明"></a>17.1 枚举类的说明</h4><ol><li><p>枚举类的理解：类的对象只有有限个，确定的。我们称此类为枚举类</p></li><li><p>当需要定义一组常量时，强烈建议使用枚举类</p></li><li><p>如果枚举类中只一个对象，则可以作为单例模式的实现方式。</p></li></ol><h4 id="17-2-自定义枚举类"><a href="#17-2-自定义枚举类" class="headerlink" title="17.2 自定义枚举类"></a>17.2 自定义枚举类</h4><ol><li>声明对象的属性：<code>private final</code> 修饰。</li><li>私化类的构造器,并给对象属性赋值。</li><li>提供当前枚举类的多个对象：<code>public static final</code> 的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义枚举类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Season</span>&#123;</span><br><span class="line">     <span class="comment">//1.声明Season对象的属性:private final修饰</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line">     <span class="comment">//2.私化类的构造器,并给对象属性赋值</span></span><br><span class="line">     <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">         <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">         <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//3.提供当前枚举类的多个对象：public static final的</span></span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SPRING</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>);</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">SUMMER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>);</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">AUTUMN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>);</span><br><span class="line">     <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Season</span> <span class="variable">WINTER</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Season</span>(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line">     <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> seasonName;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> seasonDesc;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="comment">//4.其他诉求1：提供toString()</span></span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> <span class="string">&quot;Season&#123;&quot;</span> +</span><br><span class="line">                 <span class="string">&quot;seasonName=&#x27;&quot;</span> + seasonName + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                 <span class="string">&quot;, seasonDesc=&#x27;&quot;</span> + seasonDesc + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                 <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="17-3-使用-enum-定义枚举类"><a href="#17-3-使用-enum-定义枚举类" class="headerlink" title="17.3 使用 enum 定义枚举类"></a>17.3 使用 enum 定义枚举类</h4><p><strong>1）使用 enum 定义枚举类（ jdk 5.0 新增）</strong></p><ol><li>提供当前枚举类的对象，多个对象之间用 “,” 隔开，末尾对象 “;” 结束。</li><li>声明对象的属性：<code>private final</code> 修饰。</li><li>私化类的构造器,并给对象属性赋值。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season</span> &#123;</span><br><span class="line">     <span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">     SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>),</span><br><span class="line">     SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>),</span><br><span class="line">     AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>),</span><br><span class="line">     WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="comment">//2.声明Season对象的属性:private final修饰</span></span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> String seasonName;</span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> String seasonDesc;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//3.私化类的构造器,并给对象属性赋值</span></span><br><span class="line"></span><br><span class="line">     <span class="keyword">private</span> <span class="title function_">Season</span><span class="params">(String seasonName,String seasonDesc)</span>&#123;</span><br><span class="line">         <span class="built_in">this</span>.seasonName = seasonName;</span><br><span class="line">         <span class="built_in">this</span>.seasonDesc = seasonDesc;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//4.其他诉求1：获取枚举类对象的属性</span></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">getSeasonName</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> seasonName;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">public</span> String <span class="title function_">getSeasonDesc</span><span class="params">()</span> &#123;</span><br><span class="line">         <span class="keyword">return</span> seasonDesc;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）枚举类常用方法（继承于 java.lang.Enum 类）</strong></p><ul><li><code>toString()</code>：返回枚举类对象的名称</li><li><code>values()</code>：返回所有的枚举类对象构成的数组</li><li><code>valueOf(String objName)</code>：返回枚举类中对象名是 objName 的对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用enum定义枚举类之后，枚举类常用方法：</span></span><br><span class="line"><span class="type">Season1</span> <span class="variable">summer</span> <span class="operator">=</span> Season.SUMMER;</span><br><span class="line"><span class="comment">// toString():返回枚举类对象的名称</span></span><br><span class="line">System.out.println(summer.toString());</span><br><span class="line"></span><br><span class="line"><span class="comment">// System.out.println(Season1.class.getSuperclass());</span></span><br><span class="line">System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line"><span class="comment">// values():返回所的枚举类对象构成的数组</span></span><br><span class="line">Season1[] values = Season.values();</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; values.length;i++)&#123;</span><br><span class="line">    System.out.println(values[i]);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;****************&quot;</span>);</span><br><span class="line">Thread.State[] values1 = Thread.State.values();</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; values1.length; i++) &#123;</span><br><span class="line">    System.out.println(values1[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//valueOf(String objName):返回枚举类中对象名是objName的对象。</span></span><br><span class="line"><span class="type">Season1</span> <span class="variable">winter</span> <span class="operator">=</span> Season1.valueOf(<span class="string">&quot;WINTER&quot;</span>);</span><br><span class="line"><span class="comment">//如果没objName的枚举类对象，则抛异常：IllegalArgumentException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//        Season1 winter = Season1.valueOf(&quot;WINTER1&quot;);</span></span><br><span class="line">System.out.println(winter);</span><br></pre></td></tr></table></figure><p><strong>3）枚举类对象分别实现接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用enum定义枚举类之后，如何让枚举类对象分别实现接口：</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用enum关键字枚举类</span></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">Season1</span> <span class="keyword">implements</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">    <span class="comment">//1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，末尾对象&quot;;&quot;结束</span></span><br><span class="line">    SPRING(<span class="string">&quot;春天&quot;</span>,<span class="string">&quot;春暖花开&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;春天在哪里？&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    SUMMER(<span class="string">&quot;夏天&quot;</span>,<span class="string">&quot;夏日炎炎&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;宁夏&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    AUTUMN(<span class="string">&quot;秋天&quot;</span>,<span class="string">&quot;秋高气爽&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;秋天不回来&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    WINTER(<span class="string">&quot;冬天&quot;</span>,<span class="string">&quot;冰天雪地&quot;</span>)&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;大约在冬季&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第18章-新特性"><a href="#第18章-新特性" class="headerlink" title="第18章 新特性"></a>第18章 新特性</h3><h4 id="18-1-Java8-的新特性"><a href="#18-1-Java8-的新特性" class="headerlink" title="18.1 Java8 的新特性"></a>18.1 Java8 的新特性</h4><p><strong>1）Lambda 表达式</strong></p><p><strong>2）函数式接口</strong></p><p><strong>3）方法引用</strong></p><p><strong>4）构造器引用和数组引用</strong></p><p><strong>5）Stream API</strong></p><p><strong>6）Optional 类的使用</strong></p><p><strong>7）其他新特性</strong></p><h4 id="18-2-Java9-新特性"><a href="#18-2-Java9-新特性" class="headerlink" title="18.2 Java9 新特性"></a>18.2 Java9 新特性</h4><h4 id="18-3-Java10-新特性"><a href="#18-3-Java10-新特性" class="headerlink" title="18.3 Java10 新特性"></a>18.3 Java10 新特性</h4><h4 id="18-4-Java11-新特性"><a href="#18-4-Java11-新特性" class="headerlink" title="18.4 Java11 新特性"></a>18.4 Java11 新特性</h4>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/.io//image%5CJava%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB.png&quot; alt=&quot;image-20210202171943966&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;编程语言核心结构：变量、基本语法、分支、循环、数组等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Java 面向对象的核心逻辑：OOP、封装、继承、多态、接口等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;开发Java SE 高级应用程序：异常、集合、I&amp;#x2F;O、多线程、反射机制、网络编程等&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;实训项目&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;项目一：讲完流程控制时，可以做。&lt;/p&gt;
&lt;p&gt;项目二：讲完面向对象（上），可以做&lt;/p&gt;
&lt;p&gt;项目三：讲完异常处理以后，可以做&lt;/p&gt;
&lt;p&gt;附加项目一：讲完异常处理以后，可以做&lt;/p&gt;
&lt;p&gt;附加项目二：讲完IO流以后，可以做&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java" scheme="https://actionding.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://actionding.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="编程" scheme="https://actionding.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://actionding.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Spring 笔记</title>
    <link href="https://actionding.github.io/2020/08/Spring%20%E7%AC%94%E8%AE%B0/"/>
    <id>https://actionding.github.io/2020/08/Spring%20%E7%AC%94%E8%AE%B0/</id>
    <published>2020-08-04T16:00:00.000Z</published>
    <updated>2022-03-09T05:29:04.662Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第1章-简介"><a href="#第1章-简介" class="headerlink" title="第1章 简介"></a>第1章 简介</h2><p><a href="https://spring.io/">Spring</a> 是轻量级的开源的 JavaEE 框架，可以解决企业应用开发的复杂性。</p><p>Spring 有两个核心部分：IoC 和 AOP</p><ol><li>IoC：Inverse of Control，控制反转</li><li>AOP：Aspect Orient Programming，面向切片</li></ol><span id="more"></span><p><a href="https://spring.io/projects/spring-framework">Spring 框架</a>的特点：</p><ol><li>方便解耦，简化开发</li><li>支持 AOP 编程</li><li>方便程序测试</li><li>方便和其他框架进行整合</li><li>方便进行事务操作</li><li>降低 API 开发难度</li></ol><h2 id="第2章-入门案例"><a href="#第2章-入门案例" class="headerlink" title="第2章 入门案例"></a>第2章 入门案例</h2><ol><li><p><strong>下载 <a href="https://repo.spring.io/release/org/springframework/spring/">Spring</a></strong></p></li><li><p><strong>创建普通 Java 工程</strong></p></li><li><p><strong>导入 Spring 相关 jar 包</strong></p></li></ol><p>核心包（容器）：Beans、Core、Context、Expression</p><blockquote><p>日志包：commons-logging-1.1.1.jar</p></blockquote><ol start="4"><li><strong>创建普通类</strong></li></ol><p>POJO(Plain Ordinary Java Object) 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line">    <span class="comment">// 属性</span></span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="comment">// 构造器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Student</span><span class="params">(String id, String name, <span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// getter 和 setter 方法</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setId</span><span class="params">(String id)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getAge</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAge</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// toString 方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Student&#123;&quot;</span> +</span><br><span class="line">                <span class="string">&quot;id=&#x27;&quot;</span> + id + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, name=&#x27;&quot;</span> + name + <span class="string">&#x27;\&#x27;&#x27;</span> +</span><br><span class="line">                <span class="string">&quot;, age=&quot;</span> + age +</span><br><span class="line">                <span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(id + <span class="string">&quot; --&gt; add()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="5"><li><strong>创建 Spring 配置文件</strong></li></ol><p>在配置文件配置创建的对象</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置 Student 对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ding.spring.bean.Student&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="6"><li><strong>进行代码测试</strong></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StudentTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAdd</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">// 加载 Spring 配置文件</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;Student.xml&quot;</span>);</span><br><span class="line">        <span class="comment">// 获取配置文件创建的对象</span></span><br><span class="line"><span class="comment">//        Student bean1 = context.getBean(Student.class);</span></span><br><span class="line">        <span class="type">Student</span> <span class="variable">bean1</span> <span class="operator">=</span> (Student) context.getBean(<span class="string">&quot;student01&quot;</span>);</span><br><span class="line">        <span class="comment">// 打印 bean</span></span><br><span class="line">        System.out.println(bean1);</span><br><span class="line">        bean1.add();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第3章-IoC"><a href="#第3章-IoC" class="headerlink" title="第3章 IoC"></a>第3章 IoC</h2><h3 id="3-1-IoC-简介"><a href="#3-1-IoC-简介" class="headerlink" title="3.1 IoC  简介"></a>3.1 IoC  简介</h3><p>Inverse of Control，控制反转。把对象创建和对象之间的调用过程，交给 Spring 进行管理。</p><p>IoC 可以降低耦合度</p><p><strong>IoC 的底层原理</strong>：XML 解析、工厂模式、反射</p><p><strong>IoC 容器</strong></p><p>IoC 思想基于 IoC 容器完成，IoC 容器底层就是对象工厂。</p><p>Spring 提供 IoC 容器的两种实现方式（两个接口）：</p><ol><li><strong>BeanFactory 接口</strong>：Spring 内部的使用接口<ul><li>加载配置文件的时候不会创建对象，在获取（使用）对象的时候才去创建对象</li></ul></li><li><strong>ApplicationContext 接口</strong>：BeanFactory 接口的子接口，提供更多、更强大的功能<ul><li>加载配置文件的时候就会把配置文件对象进行创建</li></ul></li></ol><h3 id="3-2-Bean-管理"><a href="#3-2-Bean-管理" class="headerlink" title="3.2 Bean 管理"></a>3.2 Bean 管理</h3><p><strong>两个操作</strong></p><p>Bean 管理指的是两个操作，分别是：</p><ol><li>Spring 创建对象</li><li>Spring 注入属性</li></ol><p><strong>两种方式</strong></p><p>操作的两种方式：</p><ol><li>基于 XML 配置文件方式实现</li><li>基于注解方式实现</li></ol><h3 id="3-3-基于-XML-方式"><a href="#3-3-基于-XML-方式" class="headerlink" title="3.3 基于 XML 方式"></a>3.3 基于 XML 方式</h3><blockquote><p><strong>什么是 XML</strong></p></blockquote><p><strong>1）创建对象</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;user&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ding.spring.User&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><ol><li><p>使用 bean 标签创建对象，并在标签里面添加对应的属性</p></li><li><p>常用的属性</p><ul><li>id 属性：唯一标识</li><li>class 属性：类全路径（包类路径）</li></ul></li><li><p>创建对象的时候，默认调用无参构造器方法完成对象创建</p></li></ol><p><strong>2）注入属性</strong></p><p>DI，Dependency Injection，依赖注入，即注入属性。</p><p><strong>① 使用 set 方法进行注入</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--setter 方法注入属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1001&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;黎明&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;25&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>② 使用有参构造器进行注入</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--有参构造器方法注入属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1002&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;白起&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;21&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3）注入其他类型属性</strong></p><p><strong>① null 值</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student03&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ding.spring.bean.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1003&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入 null 值属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">null</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;23&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>② 特殊字符</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student04&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ding.spring.bean.Student&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1004&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--注入含特殊符号的值属性</span></span><br><span class="line"><span class="comment">        1 把&lt;&gt;进行转义 &amp;lt; &amp;gt;</span></span><br><span class="line"><span class="comment">        2 把带特殊符号内容写到CDATA</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">value</span>&gt;</span><span class="symbol">&amp;lt;</span><span class="symbol">&amp;lt;</span>&lt;![CDATA[包青天&gt;&gt;]]&gt;<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;23&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>④ 外部 bean</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注入外部 bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentService01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ding.spring.service.StudentService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serviceId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;service01&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;studenDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;studentDaoImpl01&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentDaoImpl01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ding.spring.dao.StudentDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;daoId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dao01&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>⑤ 内部 bean</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--注入内部 bean--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentService02&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ding.spring.service.StudentService&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;serviceId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;service02&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;studenDao&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentDaoImpl02&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ding.spring.dao.StudentDaoImpl&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;daoId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;dao02&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>⑥ 其他</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:util</span>=<span class="string">&quot;http://www.springframework.org/schema/util&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;otherTypes&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ding.spring.bean.OtherTypes&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注入数组类型--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;arr&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>李四<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>王五<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注入 List 类型--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>西瓜<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>葡萄<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注入 Map 类型--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;Java&quot;</span> <span class="attr">value</span>=<span class="string">&quot;JavaWeb、大数据开发&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;Python&quot;</span> <span class="attr">value</span>=<span class="string">&quot;爬虫&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;C/C++&quot;</span> <span class="attr">value</span>=<span class="string">&quot;内核&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">entry</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注入 Set 类型--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>《三国演义》<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>《三国演义》<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>《水浒传》<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>《红楼梦》<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>《西游记》<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注入 Student 类型的 List--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        &lt;property name=&quot;studentList&quot;&gt;</span></span><br><span class="line"><span class="comment">            &lt;list&gt;</span></span><br><span class="line"><span class="comment">                &lt;ref bean=&quot;student01&quot;&gt;&lt;/ref&gt;</span></span><br><span class="line"><span class="comment">                &lt;ref bean=&quot;student02&quot;&gt;&lt;/ref&gt;</span></span><br><span class="line"><span class="comment">            &lt;/list&gt;</span></span><br><span class="line"><span class="comment">        &lt;/property&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;studentList&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;studentLists&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ding.spring.bean.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1001&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;黎明&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;25&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;student02&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ding.spring.bean.Student&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;id&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1002&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;郭富城&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;age&quot;</span> <span class="attr">value</span>=<span class="string">&quot;26&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--使用 util 标签完成 List 集合注入提取--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">util:list</span> <span class="attr">id</span>=<span class="string">&quot;studentLists&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;student01&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">&quot;student02&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ref</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">util:list</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>4）FactoryBean</strong></p><ol><li><p>Spring 有两种类型 bean，一种普通 bean，另外一种工厂 bean（FactoryBean）</p></li><li><p>普通 bean：在配置文件中定义 bean 类型就是返回类型</p></li><li><p>工厂 bean：在配置文件定义 bean 类型可以和返回类型不一样</p><ul><li><p>第一步 创建类，让这个类作为工厂 bean，实现接口 FactoryBean</p></li><li><p>第二步 实现接口里面的方法，在实现的方法中定义返回的 bean 类型</p></li></ul></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Student&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Student <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">        student.setName(<span class="string">&quot;张学友&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> student;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSingleton</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>5）bean 的作用域</strong></p><ol><li>在 Spring 里面，默认情况下，bean 是单实例对象</li><li>在 Spring 配置文件 bean 标签里面有属性（scope）用于设置单实例还是多实例<ul><li>第一个值 默认值，singleton，表示是单实例对象</li><li>第二个值 prototype，表示是多实例对象</li></ul></li><li>singleton 和 prototype 区别<ul><li>第一 singleton 单实例，prototype 多实例</li><li>第二 设置 scope 值是 singleton 时候，加载 spring 配置文件时候就会创建单实例对象<br>设置 scope 值是 prototype 时候，不是在加载 Spring 配置文件时候创建对象，在调用 getBean 方法时候创建多实例对象</li></ul></li></ol><p><strong>6）bean 的生命周期</strong></p><ol><li>执行无参构造器创建 bean 实例</li><li>调用 set 方法设置属性值</li><li>执行在初始化之前执行的方法（postProcessBeforeInitialization()）</li><li>执行初始化方法（initMethod()）</li><li>执行在初始化之后执行的方法（postProcessAfterInitialization()）</li><li>获取创建 bean 实例对象（getBean()）</li><li>执行销毁的方法（destroyMethod()）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyBeanPost</span> <span class="keyword">implements</span> <span class="title class_">BeanPostProcessor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之前执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;在初始化之后执行的方法&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;orders&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ding.bean.Book&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;initMethod&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destroyMethod&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>7）XML 自动装配</strong></p><p>根据指定装配规则（属性名称或者属性类型），Spring 自动将匹配的属性值进行注入</p><p><strong>① 根据属性名称自动注入</strong></p><p><strong>② 根据属性类型自动注入</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--实现自动装配 bean 标签属性 autowire，配置自动装配 autowire 属性常用两个值：</span></span><br><span class="line"><span class="comment">    byName 根据属性名称注入 ，注入值 bean 的 id 值和类属性名称一样</span></span><br><span class="line"><span class="comment">    byType 根据属性类型注入 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!--根据属性的名称自动注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentService01&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ding.spring.service.StudentService&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name=&quot;studentDao&quot; ref=&quot;studentDao&quot;&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--根据属性的类型自动注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentService02&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ding.spring.service.StudentService&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;property name=&quot;studentDao&quot; ref=&quot;studentDao&quot;&gt;&lt;/property&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;studentDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ding.spring.dao.StudentDaoImpl&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;daoId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;S1001&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="3-4-基于注解方式"><a href="#3-4-基于注解方式" class="headerlink" title="3.4 基于注解方式"></a>3.4 基于注解方式</h3><blockquote><p><strong>什么是注解</strong></p><p>注解是代码特殊标记，格式：@注解名称（属性名&#x3D;属性值，属性名&#x3D;属性值…）</p><p>可以简化 XML 配置</p></blockquote><p><strong>1）对象创建</strong></p><p><strong>Spring 针对 Bean 管理中创建对象提供的注解</strong></p><ol><li>@Component</li><li>@Service：一般用在业务层</li><li>@Control：一般用在表现层</li><li>@Repository一般用在持久层</li></ol><p>以上四个注解的功能是一样的，都可以用来创建 Bean 实例</p><p><strong>第一步：引入依赖</strong></p><p>spring-aop-5.x.x.RELEASW.jar</p><p><strong>第二步：开启组件扫描</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启组件扫描--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ding.spring&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>第三步：创建类，在类上面添加创建对象注解</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Component(value = &quot;userService&quot;)//&lt;bean id=&quot;userService&quot; class=&quot;..&quot;&gt;&lt;/bean&gt;</span></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;service add()...&quot;</span> + name);</span><br><span class="line">        userDao.add();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>注解中的 value 属性值可以省略不写</li><li>默认值是类名称，首字母小写</li></ol><p><strong>开启组件扫描的细节配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--示例一</span></span><br><span class="line"><span class="comment">    use-default-filters=&quot;false&quot; 表示不使用默认 filter，自己配置 filter</span></span><br><span class="line"><span class="comment">    context:include-filter 设置扫描哪些内容</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ding.spring&quot;</span> <span class="attr">use-default-filters</span>=<span class="string">&quot;false&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:include-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--示例二</span></span><br><span class="line"><span class="comment">    context:exclude-filter 设置不扫描哪些内容</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ding.spring&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:exclude-filter</span> <span class="attr">type</span>=<span class="string">&quot;annotation&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>2）注入属性</strong></p><ol><li><strong>@Autowired</strong>：根据属性类型进行自动装配</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要 set 方法</span></span><br><span class="line"><span class="meta">@Autowired</span> <span class="comment">// 根据类型注入</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>@Qualifier</strong>：根据名称进行注入</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不需要 set 方法</span></span><br><span class="line"><span class="meta">@Autowired</span> <span class="comment">// 根据类型注入</span></span><br><span class="line"><span class="meta">@Qualifier(value = &quot;userDaoImpl_1&quot;)</span> <span class="comment">// 根据名称注入，需要和 @Autowired 一起使用</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure><ol start="3"><li><strong>@Resource</strong>：既可以根据类型注入，也可以根据名称注入</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// @Resource</span></span><br><span class="line"><span class="meta">@Resource(name = &quot;userDaoImpl_1&quot;)</span></span><br><span class="line"><span class="keyword">private</span> UserDao userDao;</span><br></pre></td></tr></table></figure><ol start="4"><li><strong>@Value</strong>：注入普通类型属性</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Value(value = &quot;小王&quot;)</span></span><br><span class="line"><span class="keyword">private</span> String username;</span><br></pre></td></tr></table></figure><p><strong>3）完全注解开发</strong></p><ol><li>创建配置类，代替 XML 配置文件</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span> <span class="comment">// 配置类</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &quot;com.ding.spring&quot;)</span> <span class="comment">// 开启扫描</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>编写测试类</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testUserConfig</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 加载配置类</span></span><br><span class="line">    <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(UserConfig.class);</span><br><span class="line"></span><br><span class="line">    <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line"></span><br><span class="line">    System.out.println(userService);</span><br><span class="line">    userService.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第4章-AOP"><a href="#第4章-AOP" class="headerlink" title="第4章 AOP"></a>第4章 AOP</h2><p>Aspect Orient Program，面向切面编程，利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各个部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。</p><p>简而言之，不通过修改源代码的方式，在主干功能里面添加新功能。</p><h3 id="4-1-底层原理"><a href="#4-1-底层原理" class="headerlink" title="4.1 底层原理"></a>4.1 底层原理</h3><p>使用动态代理</p><p><strong>第一种情况：有接口情况，使用 JDK 动态代理</strong></p><p>创建接口实现类代理对象，增强类的方法</p><p><strong>第二种情况：没有接口情况，使用 CGLIB 动态代理</strong></p><p>创建子类的代理对象，增强类的方法</p><h3 id="4-2-JDK-动态代理"><a href="#4-2-JDK-动态代理" class="headerlink" title="4.2 JDK 动态代理"></a>4.2 JDK 动态代理</h3><ol><li><p>使用 Proxy 类里面的方法创建代理对象</p></li><li><p>编写 JDK 动态代理代码</p></li></ol><h3 id="4-3-CGLIB-动态代理"><a href="#4-3-CGLIB-动态代理" class="headerlink" title="4.3 CGLIB 动态代理"></a>4.3 CGLIB 动态代理</h3><p><strong>几个术语</strong></p><ol><li>连接点：类里面哪些方法可以被增强，这些方法称为连接点</li><li>切入点：实际被真正增强的方法，称为切入点</li><li>通知（增强）：实际增强的逻辑部分称为通知（增强）<ul><li>通知的种类：前置通知、后置通知、环绕通知、异常通知、最终通知</li></ul></li><li>切面：一个动作，把通知应用到切入点的过程</li></ol><p><strong>准备工作</strong></p><ol><li><p>Spring 框架一般都是基于 AspectJ 实现 AOP 操作</p><ul><li>AspectJ 不是 Spring 的组成部分，独立于 AOP 框架， 一般把 AspectJ 和 Spring 框架一起使用，进行 AOP 操作</li></ul></li><li><p>基于 AspectJ 实现 AOP 操作</p><ul><li>基于 XML 配置文件实现</li><li>基于注解方式实现</li></ul></li><li><p>在项目工程中引入 AOP 相关依赖</p></li><li><p>切入点表达式</p><ul><li>作用：知道对哪个类里面的哪个方法进行增强</li><li>语法结构：<code>execution([权限修饰符][返回类型][类全路径][方法名称]([参数列表]))</code></li></ul><blockquote><p>举例1：对com.ding.dao.BookDao类里面的 add() 进行增强</p><p>execution(* com.ding.dao.BookDao.add(..))</p><p>举例2：对com.ding.dao.BookDao类里面的所有的方法进行增强</p><p>execution(* com.ding.dao.BookDao.* (..))</p><p>举例3：对com.ding.dao包里面所有类，类里面所有方法进行增强</p><p>execution(* com.ding.dao.<em>.</em> (..))</p></blockquote></li></ol><p><strong>1）AspectJ 注解</strong></p><p><strong>AOP 操作</strong></p><ol><li>创建类，在类里面定义方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>创建增强类（编写增强逻辑）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>进行通知配置<ul><li>Spring 配置文件</li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 1 开启注解扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ding.spring&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 5 开启 Aspect 生成代理对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>使用注解创建对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 2 创建 User 对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;show()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span> <span class="comment">// 3 创建 UserProxy 对象</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 4 生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="4"><li><p>配置不同类型的通知</p></li><li><p>相同切入点的抽取</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 生成代理对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 相同切入点抽取</span></span><br><span class="line">    <span class="meta">@Pointcut(value = &quot;execution(* com.ding.spring.bean.User.show())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pointDemo</span><span class="params">()</span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 前置通知</span></span><br><span class="line">    <span class="meta">@Before(value = &quot;execution(* com.ding.spring.bean.User.show())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;before()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后置通知（返回通知）</span></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(* com.ding.spring.bean.User.show())&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最终通知</span></span><br><span class="line">    <span class="meta">@After(value = &quot;pointDemo()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;after()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异常通知</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;pointDemo()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 环绕通知</span></span><br><span class="line">    <span class="meta">@Around(value = &quot;pointDemo()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">around</span><span class="params">(ProceedingJoinPoint point)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around_before()...&quot;</span>);</span><br><span class="line">        point.proceed(); <span class="comment">// 执行被增强的方法</span></span><br><span class="line">        System.out.println(<span class="string">&quot;around_after()...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>设置增强类的优先级</strong></p><p>有多个增强类对同一个方法进行增强时，可以使用 <code>@Order(数字类型值)</code> 设置增强类的优先级,数字类型值越小优先级越高</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span> <span class="comment">// 生成代理对象</span></span><br><span class="line"><span class="meta">@Order(1)</span> <span class="comment">// 设置优先级</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserProxy</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p><strong>完全使用注解开发</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置类</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(basePackages = &#123;&quot;com.ding.spring&quot;&#125;)</span></span><br><span class="line"><span class="meta">@EnableAspectJAutoProxy(proxyTargetClass = true)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行的结果</strong></p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">com.ding.spring.bean.User@1c7a252</span><br><span class="line">around_before()...</span><br><span class="line">before()...</span><br><span class="line">show()...</span><br><span class="line">afterReturning()...</span><br><span class="line">after()...</span><br><span class="line">around_after()...</span><br></pre></td></tr></table></figure><p><strong>2）AspectJ 配置文件</strong></p><p><strong>AOP 操作</strong></p><ol><li><p>创建两个类，被增强类和增强类，创建方法</p></li><li><p>在 Spring 配置文件中创建两个类对象</p></li><li><p>在 Spring 配置文件中配置切入点</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--创建被增强类，Book 类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;book&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ding.spring.bean.Book&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--创建增强类，BookProxy 类--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;bookProxy&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.ding.spring.bean.BookProxy&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;p&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.ding.spring.bean.Book.show())&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">ref</span>=<span class="string">&quot;bookProxy&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--增强作用在具体的方法上--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">&quot;before&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;p&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:before</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="第5章-JdbcTemplate"><a href="#第5章-JdbcTemplate" class="headerlink" title="第5章 JdbcTemplate"></a>第5章 JdbcTemplate</h2><p>Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作。</p><h3 id="5-1-准备工作"><a href="#5-1-准备工作" class="headerlink" title="5.1 准备工作"></a>5.1 准备工作</h3><ol><li>引入相关 jar 包</li></ol><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">com.springsource.net.sf.cglib-2.2.0.jar</span><br><span class="line">com.springsource.org.aopalliance-1.0.0.jar</span><br><span class="line">com.springsource.org.aspectj.weaver-1.6.8.RELEASE.jar</span><br><span class="line">commons-logging-1.2.jar</span><br><span class="line">druid-1.1.9.jar</span><br><span class="line">mysql-connector-java-5.1.7-bin.jar</span><br><span class="line">spring-aop-5.2.8.RELEASE.jar</span><br><span class="line">spring-aspects-5.2.8.RELEASE.jar</span><br><span class="line">spring-beans-5.2.8.RELEASE.jar</span><br><span class="line">spring-context-5.2.8.RELEASE.jar</span><br><span class="line">spring-core-5.2.8.RELEASE.jar</span><br><span class="line">spring-expression-5.2.8.RELEASE.jar</span><br><span class="line">spring-jdbc-5.2.8.RELEASE.jar</span><br><span class="line">spring-orm-5.2.8.RELEASE.jar</span><br><span class="line">spring-tx-5.2.8.RELEASE.jar</span><br></pre></td></tr></table></figure><ol start="2"><li><p>在 Spring 配置文件配置数据库连接池</p></li><li><p>配置 JdbcTemplate 对象，注入 DataSource</p></li><li><p>创建 service 类和 dao 类，在 dao 类中注入 JdbcTemplate 对象</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置数据库连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/JdbcTemplate&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ding32&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置 JdbcTemplate 对象，注入 DataSource --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ding.spring&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-2-对数据库的操作"><a href="#5-2-对数据库的操作" class="headerlink" title="5.2 对数据库的操作"></a>5.2 对数据库的操作</h3><p><strong>1）添加</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update(String sql, <span class="meta">@Nullable</span> Object... args)</span><br></pre></td></tr></table></figure><ol><li>对应数据库创建实体类</li><li>编写 service 和 dao 类<ul><li>在 dao 类进行数据库添加操作</li><li>调用 JdbcTemplate 对象里面的 update 方法实现添加操作</li></ul></li><li>测试类</li></ol><p><strong>2）修改</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update(String sql, <span class="meta">@Nullable</span> Object... args)</span><br></pre></td></tr></table></figure><p><strong>3）删除</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">update(String sql, <span class="meta">@Nullable</span> Object... args)</span><br></pre></td></tr></table></figure><p><strong>4）查询</strong></p><ol><li>返回值</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queryForObject(String sql, Class&lt;T&gt; requiredType)</span><br></pre></td></tr></table></figure><ol start="2"><li>返回对象</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">queryForObject(String sql, RowMapper&lt;T&gt; rowMapper, <span class="meta">@Nullable</span> Object... args)</span><br></pre></td></tr></table></figure><ol start="3"><li>返回集合</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">query(String sql, RowMapper&lt;T&gt; rowMapper) </span><br></pre></td></tr></table></figure><h3 id="5-4-批量操作"><a href="#5-4-批量操作" class="headerlink" title="5.4 批量操作"></a>5.4 批量操作</h3><p><strong>1）批量添加</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">batchUpdate(String sql, List&lt;Object[]&gt; batchArgs)</span><br></pre></td></tr></table></figure><p><strong>2）批量修改</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">batchUpdate(String sql, List&lt;Object[]&gt; batchArgs)</span><br></pre></td></tr></table></figure><p><strong>3）批量删除</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">batchUpdate(String sql, List&lt;Object[]&gt; batchArgs)</span><br></pre></td></tr></table></figure><h2 id="第6章-事务操作"><a href="#第6章-事务操作" class="headerlink" title="第6章 事务操作"></a>第6章 事务操作</h2><h3 id="6-1-什么是事务"><a href="#6-1-什么是事务" class="headerlink" title="6.1 什么是事务"></a>6.1 什么是事务</h3><p>事务是数据库操作的最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败</p><p><strong>事务的四个特性（ACID）</strong>：原子性、一致性、隔离性、持久性</p><h3 id="6-2-转账实例"><a href="#6-2-转账实例" class="headerlink" title="6.2 转账实例"></a>6.2 转账实例</h3><ol><li><p>创建数据库表 account，添加记录</p><table><thead><tr><th align="center">id</th><th align="center">username</th><th align="center">money</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">lucy</td><td align="center">1000</td></tr><tr><td align="center">2</td><td align="center">mary</td><td align="center">1000</td></tr></tbody></table></li><li><p>创建 service，搭建 dao，完成对象创建和注入关系</p></li><li><p>在 dao 创建两个方法：多钱和少钱；在 service 创建转账方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reduceMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update account set money=money+? where username=?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, <span class="number">100</span>, <span class="string">&quot;mary&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">sql</span> <span class="operator">=</span> <span class="string">&quot;update account set money=money-? where username=?&quot;</span>;</span><br><span class="line">        jdbcTemplate.update(sql, <span class="number">100</span>, <span class="string">&quot;lucy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">account</span><span class="params">()</span>&#123;</span><br><span class="line">        userDao.reduceMoney();</span><br><span class="line"><span class="comment">//        int i = 10 / 0; // 模拟异常</span></span><br><span class="line">        userDao.addMoney();</span><br><span class="line">        System.out.println(<span class="string">&quot;Success...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>执行</p><ul><li><p>正常情况下，没有问题</p></li><li><p>当出现异常时，会出现问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TransactionTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testAccount</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;bean.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserService</span> <span class="variable">userService</span> <span class="operator">=</span> context.getBean(<span class="string">&quot;userService&quot;</span>, UserService.class);</span><br><span class="line">        userService.account();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置数据库连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/spring&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ding32&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置 JdbcTemplate 对象，注入 DataSource --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ding.spring&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>解决办法</p><ul><li><p>使用事务进行解决</p></li><li><p>事务操作过程</p><p>① 开启事务</p><p>② 进行业务操作</p><p>③ 没有异常，提交事务</p><p>④ 出现异常，事务回滚</p></li></ul></li></ol><h3 id="6-3-Spring-事务管理"><a href="#6-3-Spring-事务管理" class="headerlink" title="6.3 Spring 事务管理"></a>6.3 Spring 事务管理</h3><ol><li>事务添加到 JavaEE 三层结构里面 service 层（业务逻辑层）</li><li>进行事务管理操作的两种方式<ul><li>编程式事务管理 ×</li><li>声明式事务管理 √</li></ul></li><li>声明式事务管理<ul><li>基于注解方式 √</li><li>基于 XML 配置文件方式 ×</li></ul></li><li>在 Spring 进行声明式事务管理，底层使用 AOP 原理</li><li>Spring 事务管理 API：DataSourceTransactionManager 类</li></ol><p><strong>1）注解声明式事务管理</strong></p><ol><li>在 Spring 配置文件中配置事务管理器</li><li>在 Spring 配置文件中开启事务注解<ul><li>引入名称空间 tx</li><li>开启事务注解</li></ul></li><li>在 service 类（或类的方法）上面添加事务注解<ul><li>@Transactional，这个注解添加到类上面，也可以添加方法上面</li><li>如果把这个注解添加类上面，这个类里面所有的方法都添加事务</li><li>如果把这个注解添加方法上面，为这个方法添加事务</li></ul></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置数据库连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/spring&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ding32&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置 JdbcTemplate 对象，注入 DataSource --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ding.spring&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--创建事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--开启事务注解--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">&quot;transactionManager&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>声明式事务管理参数配置</strong></p><ol><li>propagation：事务传播行为</li><li>ioslation：事务隔离级别</li><li>timeout：超时时间</li><li>readonly：是否只读</li><li>rollbackFor：回滚</li><li>noRollbackFor：不会滚</li></ol><p><strong>2）XML 声明式事务管理</strong></p><p><strong>配置 Spring 配置文件</strong></p><ol><li>配置事务管理器</li><li>配置通知</li><li>配置切入点和切面</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">&quot;http://www.springframework.org/schema/tx&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">&quot;http://www.springframework.org/schema/aop&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">                            http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置数据库连接池--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">class</span>=<span class="string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;close&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;jdbc:mysql://localhost:3306/spring&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driverClassName&quot;</span> <span class="attr">value</span>=<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;root&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;ding32&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--配置 JdbcTemplate 对象，注入 DataSource --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;jdbcTemplate&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--组件扫描--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;com.ding.spring&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 1 创建事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;transactionManager&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--注入数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dataSource&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;dataSource&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 2 配置通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">&quot;txadvice&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置事务参数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--指定哪种规则的方法上面添加事务--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">&quot;account&quot;</span> <span class="attr">propagation</span>=<span class="string">&quot;REQUIRED&quot;</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--&lt;tx:method name=&quot;account*&quot;/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 3 配置切入点和切面--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切入点--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">&quot;pc&quot;</span> <span class="attr">expression</span>=<span class="string">&quot;execution(* com.ding.spring.service.UserService.*(..))&quot;</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切面--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">&quot;txadvice&quot;</span> <span class="attr">pointcut-ref</span>=<span class="string">&quot;pc&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>3）完全注解声明式事务管理</strong></p><p><strong>创建配置类，使用配置类代替 XML 配置文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;第1章-简介&quot;&gt;&lt;a href=&quot;#第1章-简介&quot; class=&quot;headerlink&quot; title=&quot;第1章 简介&quot;&gt;&lt;/a&gt;第1章 简介&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://spring.io/&quot;&gt;Spring&lt;/a&gt; 是轻量级的开源的 JavaEE 框架，可以解决企业应用开发的复杂性。&lt;/p&gt;
&lt;p&gt;Spring 有两个核心部分：IoC 和 AOP&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;IoC：Inverse of Control，控制反转&lt;/li&gt;
&lt;li&gt;AOP：Aspect Orient Programming，面向切片&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Spring" scheme="https://actionding.github.io/categories/Spring/"/>
    
    
    <category term="Spring" scheme="https://actionding.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】10-异常处理</title>
    <link href="https://actionding.github.io/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%9110-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://actionding.github.io/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%9110-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2020-07-04T19:02:10.000Z</published>
    <updated>2020-09-11T01:09:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>异常的体系结构、异常处理、手动抛出异常、自定义异常类</p><span id="more"></span><h3 id="一、异常的体系结构"><a href="#一、异常的体系结构" class="headerlink" title="一、异常的体系结构"></a>一、异常的体系结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Throwable</span><br><span class="line"> |-----java.lang.Error:一般不编写针对性的代码进行处理。</span><br><span class="line"> |-----java.lang.Exception:可以进行异常的处理</span><br><span class="line">|------编译时异常(checked)</span><br><span class="line">|-----IOException</span><br><span class="line">|-----FileNotFoundException</span><br><span class="line">|-----ClassNotFoundException</span><br><span class="line">|------运行时异常(unchecked,RuntimeException)</span><br><span class="line">|-----NullPointerException</span><br><span class="line">|-----ArrayIndexOutOfBoundsException</span><br><span class="line">|-----ClassCastException</span><br><span class="line">|-----NumberFormatException</span><br><span class="line">|-----InputMismatchException</span><br><span class="line">|-----ArithmeticException</span><br></pre></td></tr></table></figure><p><img src="/../../images/%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB.png" alt="异常体系"></p><h4 id="1-分类"><a href="#1-分类" class="headerlink" title="1 分类"></a>1 分类</h4><p>从程序执行过程看分为<strong>编译时异常</strong>和<strong>运行时异常</strong></p><p>1）编译时异常：执行<code>javac.exe</code>命名时，可能出现的异常</p><p>2）运行时异常：执行<code>java.exe</code>命名时，出现的异常</p><p><img src="/../../images/%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="执行过程"></p><h4 id="2-常见的异常类型"><a href="#2-常见的异常类型" class="headerlink" title="2 常见的异常类型"></a>2 常见的异常类型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 常见的异常类型，请举例说明：</span></span><br><span class="line"><span class="comment">//******************以下是运行时异常***************************</span></span><br><span class="line"><span class="comment">//ArithmeticException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test6</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">System.out.println(a / b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//InputMismatchException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test5</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">Scanner</span> <span class="variable">scanner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Scanner</span>(System.in);</span><br><span class="line"><span class="type">int</span> <span class="variable">score</span> <span class="operator">=</span> scanner.nextInt();</span><br><span class="line">System.out.println(score);</span><br><span class="line"></span><br><span class="line">scanner.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NumberFormatException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;123&quot;</span>;</span><br><span class="line">str = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ClassCastException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> (String)obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//IndexOutOfBoundsException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//ArrayIndexOutOfBoundsException</span></span><br><span class="line"><span class="comment">//int[] arr = new int[10];</span></span><br><span class="line"><span class="comment">//System.out.println(arr[10]);</span></span><br><span class="line"><span class="comment">//StringIndexOutOfBoundsException</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">System.out.println(str.charAt(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//NullPointerException</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int[] arr = null;</span></span><br><span class="line"><span class="comment">//System.out.println(arr[3]);</span></span><br><span class="line"></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">str = <span class="literal">null</span>;</span><br><span class="line">System.out.println(str.charAt(<span class="number">0</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//******************以下是编译时异常***************************</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test7</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="comment">//File file = new File(&quot;hello.txt&quot;);</span></span><br><span class="line"><span class="comment">//FileInputStream fis = new FileInputStream(file);</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//int data = fis.read();</span></span><br><span class="line"><span class="comment">//while(data != -1)&#123;</span></span><br><span class="line"><span class="comment">//System.out.print((char)data);</span></span><br><span class="line"><span class="comment">//data = fis.read();</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//fis.close();</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二、异常处理"><a href="#二、异常处理" class="headerlink" title="二、异常处理"></a>二、异常处理</h3><h4 id="1-java异常处理的抓抛模型"><a href="#1-java异常处理的抓抛模型" class="headerlink" title="1 java异常处理的抓抛模型"></a>1 java异常处理的抓抛模型</h4><h5 id="1）过程一：”抛”"><a href="#1）过程一：”抛”" class="headerlink" title="1）过程一：”抛”"></a>1）过程一：”抛”</h5><p>程序在正常执行的过程中，<strong>一旦</strong>出现异常，就会在异常代码处生成一个对应异常类的对象，并将此对象抛出。<strong>一旦</strong>抛出对象以后，其后的代码就不再执行</p><p>关于异常对象的产生：</p><p>① 系统自动生成的异常对象</p><p>② 手动的生成一个异常对象，并抛出（throw）</p><h5 id="2）过程二：”抓”"><a href="#2）过程二：”抓”" class="headerlink" title="2）过程二：”抓”"></a>2）过程二：”抓”</h5><p>可以理解为异常的处理方式：</p><p>① try-catch-finally  </p><p>② throws</p><h4 id="2-异常处理方式一"><a href="#2-异常处理方式一" class="headerlink" title="2 异常处理方式一"></a>2 异常处理方式一</h4><p>try-catch-finally</p><h5 id="1）语法格式"><a href="#1）语法格式" class="headerlink" title="1）语法格式"></a>1）语法格式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//可能出现异常的代码</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">1</span> 变量名<span class="number">1</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理异常的方式1</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">2</span> 变量名<span class="number">2</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理异常的方式2</span></span><br><span class="line"></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型<span class="number">3</span> 变量名<span class="number">3</span>)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//处理异常的方式3</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">....</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一定会执行的代码</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2）使用说明"><a href="#2）使用说明" class="headerlink" title="2）使用说明"></a>2）使用说明</h5><p>1）<code>finally</code> 是可选的。</p><p>2）使用 <code>try</code> 将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，根据此对象的类型，去 <code>catch</code> 中进行匹配</p><p>3）一旦 <code>try</code> 中的异常对象匹配到某一个 <code>catch</code> 时，就进入 <code>catch</code> 中进行异常的处理。一旦处理完成，就跳出当前的 <code>try-catch</code> 结构（在没写 <code>finally</code> 的情况）。继续执行其后的代码</p><p>4）<code>catch</code> 中的异常类型如果没子父类关系，则谁声明在上，谁声明在下无所谓</p><p>​    <code>catch</code> 中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面。否则，报错</p><p>5）常用的异常对象处理的方式： ① String  getMessage()    ② printStackTrace()</p><p>6）在 <code>try</code> 结构中声明的变量，再出了 <code>try</code> 结构以后，就不能再被调用</p><p>7）<code>try-catch-finally</code> 结构可以嵌套</p><h5 id="3）总结"><a href="#3）总结" class="headerlink" title="3）总结"></a>3）总结</h5><p><strong>如何看待代码中的编译时异常和运行时异常？</strong></p><p>① 使用 <code>try-catch-finally</code> 处理编译时异常，是得程序在编译时就不再报错，但是运行时仍可能报错。相当于我们使用 <code>try-catch-finally</code> 将一个编译时可能出现的异常，延迟到运行时出现。</p><p>② 开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写 <code>try-catch-finally</code> 了。针对于编译时异常，我们说一定要考虑异常的处理。</p><p><strong>finally 的再说明</strong></p><p>① <code>finally</code>是可的</p><p>② <code>finally</code> 中声明的是一定会被执行的代码。即使 <code>catch</code> 中又出现异常了，<code>try</code> 中 <code>return</code> 语句，<code>catch</code> 中 <code>return</code> 语句等情况</p><p>③ 像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动的回收的，我们需要自己手动的进行资源的释放。此时的资源释放，就需要声明在 <code>finally</code> 中</p><p><strong>面试题</strong></p><p>final、finally、finalize三者的区别？</p><blockquote><p>类似：</p><p>throw 和 throws<br>Collection 和 Collections<br>String 、StringBuffer、StringBuilder<br>ArrayList 、 LinkedList<br>HashMap 、LinkedHashMap<br>重写、重载</p><p>结构不相似的：</p><p>抽象类、接口<br>&#x3D;&#x3D; 、 equals()<br>sleep()、wait()</p></blockquote><h4 id="3-异常处理方式二"><a href="#3-异常处理方式二" class="headerlink" title="3 异常处理方式二"></a>3 异常处理方式二</h4><p>“throws + 异常类型”写在方法的声明处。指明此方法执行时，可能会抛出的异常类型</p><p>一旦当方法体执行时，出现异常，仍会在异常代码处生成一个异常类的对象，此对象满足throws后异常类型时，就会被抛出。异常代码后续的代码，就不再执行！</p><h5 id="1）对比两种处理方式"><a href="#1）对比两种处理方式" class="headerlink" title="1）对比两种处理方式"></a>1）对比两种处理方式</h5><p>try-catch-finally:真正的将异常给处理掉了。<br>throws的方式只是将异常抛给了方法的调用者。并没真正将异常处理掉。  </p><h5 id="2）体会开发中应该如何选择两种处理方式？"><a href="#2）体会开发中应该如何选择两种处理方式？" class="headerlink" title="2）体会开发中应该如何选择两种处理方式？"></a>2）体会开发中应该如何选择两种处理方式？</h5><p>① 如果父类中被重写的方法没throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中异常，必须使用try-catch-finally方式处理</p><p>② 执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。我们建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try-catch-finally方式进行处理</p><blockquote><p>补充<br>方法重写的规则之一：子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</p></blockquote><h3 id="三、手动抛出异常"><a href="#三、手动抛出异常" class="headerlink" title="三、手动抛出异常"></a>三、手动抛出异常</h3><h4 id="1-使用说明"><a href="#1-使用说明" class="headerlink" title="1 使用说明"></a>1 使用说明</h4><p>在程序执行中，除了自动抛出异常对象的情况之外，我们还可以手动的throw一个异常类的对象。</p><h4 id="2-面试题"><a href="#2-面试题" class="headerlink" title="2 面试题"></a>2 面试题</h4><p>throw 和  throws区别：</p><p>throw 表示抛出一个异常类的对象，生成异常对象的过程。声明在方法体内<br>throws 属于异常处理的一种方式，声明在方法的声明处</p><h4 id="3-典型例题"><a href="#3-典型例题" class="headerlink" title="3 典型例题"></a>3 典型例题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">regist</span><span class="params">(<span class="type">int</span> id)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"><span class="keyword">if</span>(id &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">this</span>.id = id;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//手动抛出异常对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//throw new RuntimeException(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line"><span class="comment">//throw new Exception(&quot;您输入的数据非法！&quot;);</span></span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">MyException</span>(<span class="string">&quot;不能输入负数&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Student [id=&quot;</span> + id + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、自定义异常类"><a href="#四、自定义异常类" class="headerlink" title="四、自定义异常类"></a>四、自定义异常类</h3><p><strong>如何自定义异常类？</strong></p><p>① 继承于现的异常结构：RuntimeException 、Exception</p><p>② 提供全局常量：serialVersionUID</p><p>③ 提供重载的构造器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyException</span> <span class="keyword">extends</span> <span class="title class_">Exception</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> -<span class="number">7034897193246939L</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">MyException</span><span class="params">(String msg)</span>&#123;</span><br><span class="line"><span class="built_in">super</span>(msg);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;异常的体系结构、异常处理、手动抛出异常、自定义异常类&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://actionding.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://actionding.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="编程" scheme="https://actionding.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://actionding.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】9-面向对象·下</title>
    <link href="https://actionding.github.io/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%919-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%C2%B7%E4%B8%8B/"/>
    <id>https://actionding.github.io/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%919-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%C2%B7%E4%B8%8B/</id>
    <published>2020-07-04T19:02:09.000Z</published>
    <updated>2020-09-12T09:41:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象学习的三条主线：</p><ol><li><p>Java类及类的成员：属性、方法、构造器；<strong>代码块</strong>、<strong>内部类</strong></p></li><li><p>面向对象的三大特征：封装性、继承性、多态性</p></li><li><p>其它关键字：this、super、<strong>static</strong>、<strong>final</strong>、abstract、<strong>interface</strong>、package、import等</p></li></ol><span id="more"></span><h3 id="一、关键字static"><a href="#一、关键字static" class="headerlink" title="一、关键字static"></a>一、关键字static</h3><p>static：静态的</p><h4 id="1-可以用来修饰的结构"><a href="#1-可以用来修饰的结构" class="headerlink" title="1 可以用来修饰的结构"></a>1 可以用来修饰的结构</h4><p>主要用来修饰类的内部结构（属性、方法、代码块、内部类）</p><h4 id="2-static修饰属性：静态变量（或类变量）"><a href="#2-static修饰属性：静态变量（或类变量）" class="headerlink" title="2 static修饰属性：静态变量（或类变量）"></a>2 static修饰属性：静态变量（或类变量）</h4><h5 id="1）静态属性和非静态属性-实例变量"><a href="#1）静态属性和非静态属性-实例变量" class="headerlink" title="1）静态属性和非静态属性(实例变量)"></a>1）静态属性和非静态属性(实例变量)</h5><p>属性按是否使用static修饰，又分为：静态属性 和 非静态属性(实例变量)</p><p>实例变量：我们创建了类的多个对象，每个对象都独立的拥一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。</p><p>静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。</p><h5 id="2）static修饰属性的其他说明"><a href="#2）static修饰属性的其他说明" class="headerlink" title="2）static修饰属性的其他说明"></a>2）static修饰属性的其他说明</h5><p>① 静态变量随着类的加载而加载。可以通过”类.静态变量”的方式进行调用</p><p>② 静态变量的加载要早于对象的创建。</p><p>③ 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。</p><p>④</p><table><thead><tr><th align="center"></th><th align="center">类变量</th><th align="center">实例变量</th></tr></thead><tbody><tr><td align="center">类</td><td align="center">yes</td><td align="center">no</td></tr><tr><td align="center">对象</td><td align="center">yes</td><td align="center">yes</td></tr></tbody></table><h5 id="3）静态属性举例：System-out-Math-PI"><a href="#3）静态属性举例：System-out-Math-PI" class="headerlink" title="3）静态属性举例：System.out; Math.PI;"></a>3）静态属性举例：System.out; Math.PI;</h5><h4 id="3-static修饰方法：静态方法、类方法"><a href="#3-static修饰方法：静态方法、类方法" class="headerlink" title="3 static修饰方法：静态方法、类方法"></a>3 static修饰方法：静态方法、类方法</h4><p>1）随着类的加载而加载，可以通过”类.静态方法”的方式进行调用<br>2）</p><table><thead><tr><th></th><th>静态方法</th><th>非静态方法</th></tr></thead><tbody><tr><td>类</td><td>yes</td><td>no</td></tr><tr><td>对象</td><td>yes</td><td>yes</td></tr></tbody></table><p>3）静态方法中，只能调用静态的方法或属性<br>      非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</p><blockquote><p>static的注意点<br>① 在静态的方法内，不能使用this关键字、super关键字<br>② 关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。</p></blockquote><h4 id="4-如何判定属性和方法是否应该使用static关键字"><a href="#4-如何判定属性和方法是否应该使用static关键字" class="headerlink" title="4 如何判定属性和方法是否应该使用static关键字"></a>4 如何判定属性和方法是否应该使用static关键字</h4><p>1）关于属性</p><p>属性是可以被多个对象所共享的，不会随着对象的不同而不同的</p><p>类中的常量也常常声明为static</p><p>2）关于方法</p><p>操作静态属性的方法，通常设置为static的</p><p>工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections</p><h4 id="5-使用举例"><a href="#5-使用举例" class="headerlink" title="5 使用举例"></a>5 使用举例</h4><p>举例一：Arrays、Math、Collections等工具类</p><p>举例二：单例模式</p><h3 id="二、单例模式"><a href="#二、单例模式" class="headerlink" title="二、单例模式"></a>二、单例模式</h3><h4 id="1-设计模式的说明"><a href="#1-设计模式的说明" class="headerlink" title="1 设计模式的说明"></a>1 设计模式的说明</h4><h5 id="1）理解"><a href="#1）理解" class="headerlink" title="1）理解"></a>1）理解</h5><p><strong>设计模式</strong>是<strong>在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式</strong> 。 设计模免去我们自己再思考和摸索 。就像是经典的棋谱，不同的棋局，我们用不同的棋谱。“套路”</p><h5 id="2）常用的设计模式"><a href="#2）常用的设计模式" class="headerlink" title="2）常用的设计模式"></a>2）常用的设计模式</h5><p>① <strong>创建型模式</strong>，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式<br>② <strong>结构型模式</strong>，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式<br>③ <strong>行为型模式</strong>，共11种：策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</p><h4 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2 单例模式"></a>2 单例模式</h4><h5 id="1）要解决的问题"><a href="#1）要解决的问题" class="headerlink" title="1）要解决的问题"></a>1）要解决的问题</h5><p>所谓<strong>类的单例设计模式</strong>，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。</p><h5 id="2）具体代码的实现"><a href="#2）具体代码的实现" class="headerlink" title="2）具体代码的实现"></a>2）具体代码的实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式1</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bank</span>&#123;</span><br><span class="line"><span class="comment">//1.私化类的构造器</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Bank</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.内部创建类的对象</span></span><br><span class="line"><span class="comment">//4.要求此对象也必须声明为静态的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Bank</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bank</span>();</span><br><span class="line"><span class="comment">//3.提供公共的静态的方法，返回类的对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 饿汉式2：使用了静态代码块</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line"><span class="comment">//1.私化类的构造器</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Order</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line"><span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Order</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 懒汉式</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Order</span>&#123;</span><br><span class="line"><span class="comment">//1.私化类的构造器</span></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">Order</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//2.声明当前类对象，没初始化</span></span><br><span class="line"><span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Order</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">instance = <span class="keyword">new</span> <span class="title class_">Order</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3）两种方式的对比"><a href="#3）两种方式的对比" class="headerlink" title="3）两种方式的对比"></a>3）两种方式的对比</h5><p>① 饿汉式    </p><p>坏处：对象加载时间过长。</p><p>好处：饿汉式是线程安全的</p><p>② 懒汉式</p><p>好处：延迟对象的创建。</p><p>目前的写法坏处：线程不安全。—&gt;到多线程内容时，再修改</p><h3 id="三、代码块"><a href="#三、代码块" class="headerlink" title="三、代码块"></a>三、代码块</h3><h4 id="1-代码块的作用"><a href="#1-代码块的作用" class="headerlink" title="1 代码块的作用"></a>1 代码块的作用</h4><p>用来初始化类、对象的信息</p><h4 id="2-分类"><a href="#2-分类" class="headerlink" title="2.分类"></a>2.分类</h4><p>代码块要是使用修饰符，只能使用static</p><p>分类：静态代码块  vs 非静态代码块</p><h4 id="3-静态代码块"><a href="#3-静态代码块" class="headerlink" title="3 静态代码块"></a>3 静态代码块</h4><p>① 内部可以有输出语句</p><p>② 随着类的加载而执行,而且只执行一次</p><p>③ 作用：初始化类的信息</p><p>④ 如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</p><p>⑤ 静态代码块的执行要优先于非静态代码块的执行</p><p>⑥ 静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</p><h4 id="4-非静态代码块"><a href="#4-非静态代码块" class="headerlink" title="4 非静态代码块"></a>4 非静态代码块</h4><p>① 内部可以有输出语句</p><p>② 随着对象的创建而执行</p><p>③ 每创建一个对象，就执行一次非静态代码块</p><p>④ 作用：可以在创建对象时，对对象的属性等进行初始化</p><p>⑤ 如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</p><p>⑥ 非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法</p><blockquote><p>实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序：由父及子，静态先行。</p></blockquote><blockquote><p>①默认初始化</p><p>②显式初始化&#x2F;⑤在代码块中赋值</p><p>③构造器中初始化</p><p>④有了对象以后，可以通过”对象.属性”或”对象.方法”的方式，进行赋值</p><p>执行的先后顺序：① - ② &#x2F; ⑤ - ③ - ④</p></blockquote><h3 id="四、关键字final"><a href="#四、关键字final" class="headerlink" title="四、关键字final"></a>四、关键字final</h3><p>final：最终的</p><h4 id="1-可以用来修饰结构"><a href="#1-可以用来修饰结构" class="headerlink" title="1 可以用来修饰结构"></a>1 可以用来修饰结构</h4><p>类、方法、变量</p><h4 id="2-final-用来修饰一个类"><a href="#2-final-用来修饰一个类" class="headerlink" title="2 final 用来修饰一个类"></a>2 final 用来修饰一个类</h4><p>此类不能被其他类所继承。</p><p>比如：String类、System类、StringBuffer类</p><h4 id="3-final-用来修饰方法"><a href="#3-final-用来修饰方法" class="headerlink" title="3 final 用来修饰方法"></a>3 final 用来修饰方法</h4><p>表明此方法不可以被重写</p><p>比如：Object类中getClass();</p><h4 id="4-final-用来修饰变量"><a href="#4-final-用来修饰变量" class="headerlink" title="4 final 用来修饰变量"></a>4 final 用来修饰变量</h4><p>此时的”变量”就称为是一个常量</p><p>1）final修饰属性：可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化</p><p>2）final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。</p><blockquote><p>static final 用来修饰属性：全局常量</p></blockquote><h3 id="五、关键字abstract"><a href="#五、关键字abstract" class="headerlink" title="五、关键字abstract"></a>五、关键字abstract</h3><p>abstract：抽象的</p><h4 id="1-可以用来修饰结构-1"><a href="#1-可以用来修饰结构-1" class="headerlink" title="1 可以用来修饰结构"></a>1 可以用来修饰结构</h4><p>类、方法</p><h4 id="2-abstract修饰类：抽象类"><a href="#2-abstract修饰类：抽象类" class="headerlink" title="2 abstract修饰类：抽象类"></a>2 abstract修饰类：抽象类</h4><p>1）此类<strong>不能实例化</strong></p><p>2）抽象类中<strong>一定有构造器</strong>，便于子类实例化时调用（涉及：子类对象实例化的全过程）</p><p>3）开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作 —&gt;抽象的使用前提：继承性</p><h4 id="3-abstract修饰方法：抽象方法"><a href="#3-abstract修饰方法：抽象方法" class="headerlink" title="3 abstract修饰方法：抽象方法"></a>3 abstract修饰方法：抽象方法</h4><p>1）抽象方法只有方法的声明，没方法体</p><p>2）包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</p><p>3）若子类重写了父类中的所的抽象方法后，此子类方可实例化</p><p>​      若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</p><h4 id="4-注意点"><a href="#4-注意点" class="headerlink" title="4 注意点"></a>4 注意点</h4><p>1）abstract不能用来修饰：属性、构造器等结构</p><p>2）abstract不能用来修饰私方法、静态方法、final的方法、final的类</p><h3 id="六、模板方法模式"><a href="#六、模板方法模式" class="headerlink" title="六、模板方法模式"></a>六、模板方法模式</h3><h4 id="1-解决的问题"><a href="#1-解决的问题" class="headerlink" title="1 解决的问题"></a>1 解决的问题</h4><p>在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变<br>部分可以抽象出来，供不同子类实现。这就是一种模板模式。</p><h4 id="2-举例"><a href="#2-举例" class="headerlink" title="2 举例"></a>2 举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Template</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算某段代码执行所需要花费的时间</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">spendTime</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line"><span class="built_in">this</span>.code();<span class="comment">//不确定的部分、易变的部分</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;花费的时间为：&quot;</span> + (end - start));</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SubTemplate</span> <span class="keyword">extends</span> <span class="title class_">Template</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">code</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>;i &lt;= <span class="number">1000</span>;i++)&#123;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>;j &lt;= Math.sqrt(i);j++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(i % j == <span class="number">0</span>)&#123;</span><br><span class="line">isFlag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">System.out.println(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-应用场景"><a href="#3-应用场景" class="headerlink" title="3 应用场景"></a>3 应用场景</h4><p>模板方法设计模式是编程中经常用得到的模式。各个框架、类库中都有他的影子，比如常见的有：</p><p>1）数据库访问的封装</p><p>2）Junit单元测试</p><p>3）JavaWeb的Servlet中关于doGet&#x2F;doPost方法调用</p><p>4）Hibernate中模板程序</p><p>5）Spring中JDBCTemlate、Hibernate Template等</p><h3 id="七、关键字interface"><a href="#七、关键字interface" class="headerlink" title="七、关键字interface"></a>七、关键字interface</h3><p>interface：接口</p><h4 id="1-使用说明"><a href="#1-使用说明" class="headerlink" title="1 使用说明"></a>1 使用说明</h4><p>1）接口使用 <code>interface</code> 来定义</p><p>2）Java中，接口和类是<strong>并列</strong>的两个结构</p><p>3）如何定义接口：定义接口中的成员</p><p>​    ① JDK7及以前：只能定义全局常量和抽象方法</p><blockquote><p>全局常量：public static final的.但是书写时，可以省略不写</p><p>抽象方法：public abstract的</p></blockquote><p>​    ② JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略）</p><p>4）接口中不能定义构造器的！意味着接口不可以实例化</p><p>5）Java开发中，接口通过让类去实现（implements）的方式来使用</p><p>​    如果实现类覆盖了接口中的所抽象方法，则此实现类就可以实例化</p><p>​    如果实现类没覆盖接口中所的抽象方法，则此实现类仍为一个抽象类</p><p>6）Java类可以实现多个接口   —&gt; 弥补了Java单继承性的局限性</p><p>​    格式：class AA extends BB implements CC,DD,EE</p><p>7）接口与接口之间可以继承，而且可以多继承</p><p>8）接口的具体使用，体现多态性</p><p>9）接口，实际上可以看做是一种规范</p><h4 id="2-举例-1"><a href="#2-举例-1" class="headerlink" title="2 举例"></a>2 举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Computer</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">transferData</span><span class="params">(USB usb)</span>&#123;<span class="comment">//USB usb = new Flash();</span></span><br><span class="line">usb.start();</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">&quot;具体传输数据的细节&quot;</span>);</span><br><span class="line"></span><br><span class="line">usb.stop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">USB</span>&#123;</span><br><span class="line"><span class="comment">//常量：定义了长、宽、最大最小的传输速度等</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Flash</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;U盘开启工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;U盘结束工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Printer</span> <span class="keyword">implements</span> <span class="title class_">USB</span>&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打印机开启工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;打印机结束工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>体会</strong></p><p>1）接口使用上也满足多态性</p><p>2）接口，实际上就是定义了一种规范</p><p>3）开发中，体会面向接口编程！    </p><h4 id="3-体会面向接口编程的思想"><a href="#3-体会面向接口编程的思想" class="headerlink" title="3 体会面向接口编程的思想"></a>3 体会面向接口编程的思想</h4><p><img src="/../../images/%E9%9D%A2%E5%90%91%E6%8E%A5%E5%8F%A3%E7%BC%96%E7%A8%8B.png" alt="image-20200910163721358"></p><p>我们在应用程序中，调用的结构都是JDBC中定义的接口，不会出现具体某一个数据库厂商的API</p><h4 id="4-Java8中关于接口的新规范"><a href="#4-Java8中关于接口的新规范" class="headerlink" title="4 Java8中关于接口的新规范"></a>4 Java8中关于接口的新规范</h4><p>1）接口中定义的静态方法，只能通过接口来调用</p><p>2）通过实现类的对象，可以调用接口中的默认方法</p><p>​    如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</p><p>3）如果子类（或实现类）继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没重写此方法的情况下，默认调用的是父类中的同名同参数的方法。–&gt; <strong>类优先原则</strong></p><p>4）如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么在实现类没重写此方法的情况下，报错。–&gt; <strong>接口冲突</strong></p><p>​    这就需要我们必须在实现类中重写此方法</p><p>5）如何在子类（或实现类）的方法中调用父类、接口中被重写的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">myMethod</span><span class="params">()</span>&#123;</span><br><span class="line">    method3();<span class="comment">//调用自己定义的重写的方法</span></span><br><span class="line">    <span class="built_in">super</span>.method3();<span class="comment">//调用的是父类中声明的</span></span><br><span class="line">    <span class="comment">//调用接口中的默认方法</span></span><br><span class="line">    CompareA.<span class="built_in">super</span>.method3();</span><br><span class="line">    CompareB.<span class="built_in">super</span>.method3();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>面试题</strong></p><p>抽象类和接口的异同？</p><p>相同点：不能实例化；都可以包含抽象方法的</p><p>不同点：</p><p>1）把抽象类和接口（java7，java8，java9）的定义、内部结构解释说明</p><p>2）类：单继承性    接口：多继承      类与接口：多实现</p><h3 id="八、代理模式"><a href="#八、代理模式" class="headerlink" title="八、代理模式"></a>八、代理模式</h3><h4 id="1-解决的问题-1"><a href="#1-解决的问题-1" class="headerlink" title="1 解决的问题"></a>1 解决的问题</h4><p>代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问 </p><h4 id="2-举例-2"><a href="#2-举例-2" class="headerlink" title="2 举例"></a>2 举例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">NetWork</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 被代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Server</span> <span class="keyword">implements</span> <span class="title class_">NetWork</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;真实的服务器访问网络&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 代理类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ProxyServer</span> <span class="keyword">implements</span> <span class="title class_">NetWork</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> NetWork work;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ProxyServer</span><span class="params">(NetWork work)</span>&#123;</span><br><span class="line"><span class="built_in">this</span>.work = work;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;联网之前的检查工作&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">browse</span><span class="params">()</span> &#123;</span><br><span class="line">check();</span><br><span class="line"></span><br><span class="line">work.browse();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-应用场景-1"><a href="#3-应用场景-1" class="headerlink" title="3 应用场景"></a>3 应用场景</h4><h5 id="1）应用场景"><a href="#1）应用场景" class="headerlink" title="1）应用场景"></a>1）应用场景</h5><p>安全代理：屏蔽对真实角色的直接访问</p><p>远程代理：通过代理类处理远程方法调用（RMl）</p><p>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</p><p>比如你要开发一个大文档查看软件，大文档中有大的图片，有可能一个图片有100MB，在打开文件时，不可能将所有的图片都显示出来，这样就可以使用代理模式，当需要查看图片时，用proxy来进行大图片的打开。</p><h5 id="2）分类"><a href="#2）分类" class="headerlink" title="2）分类"></a>2）分类</h5><p>① 静态代理（静态定义代理类）</p><p>② 动态代理（动态生成代理类）</p><blockquote><p>JDK自带的动态代理，需要反射等知识</p></blockquote><blockquote><p><strong>工厂的设计模式</strong></p><p>① 解决的问题<br>实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的</p><p>② 具体模式<br>简单工厂模式：用来生产同一等级结构中的任意产品。（对于增加新的产品，需要修改已有代码）<br>工厂方法模式：用来生产同一等级结构中的固定产品。（支持增加任意产品)<br>抽象工厂模式：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族)</p></blockquote><h3 id="九、内部类"><a href="#九、内部类" class="headerlink" title="九、内部类"></a>九、内部类</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h4><p>Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类</p><h4 id="2-内部类的分类"><a href="#2-内部类的分类" class="headerlink" title="2 内部类的分类"></a>2 内部类的分类</h4><p>成员内部类（静态、非静态 ）vs 局部内部类(方法内、代码块内、构造器内)</p><h4 id="3-成员内部类的理解"><a href="#3-成员内部类的理解" class="headerlink" title="3 成员内部类的理解"></a>3 成员内部类的理解</h4><p>一方面，作为外部类的成员：① 调用外部类的结构；②可以被static修饰；③可以被4种不同的权限修饰<br>另一方面，作为一个类：① 类内可以定义属性、方法、构造器等；② 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承；③ 可以被abstract修饰</p><h4 id="4-成员内部类"><a href="#4-成员内部类" class="headerlink" title="4 成员内部类"></a>4 成员内部类</h4><p>1）如何创建成员内部类的对象？(静态的 &amp; 非静态的)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建静态的Dog内部类的实例(静态的成员内部类):</span></span><br><span class="line">Person.<span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>.Dog();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建非静态的Bird内部类的实例(非静态的成员内部类):</span></span><br><span class="line"><span class="comment">//Person.Bird bird = new Person.Bird();//错误的</span></span><br><span class="line"><span class="type">Person</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">Person.<span class="type">Bird</span> <span class="variable">bird</span> <span class="operator">=</span> p.<span class="keyword">new</span> <span class="title class_">Bird</span>();</span><br></pre></td></tr></table></figure><p>2）如何在成员内部类中调用外部类的结构？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;小明&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//非静态成员内部类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bird</span>&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="string">&quot;杜鹃&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">display</span><span class="params">(String name)</span>&#123;</span><br><span class="line">System.out.println(name);<span class="comment">//方法的形参</span></span><br><span class="line">System.out.println(<span class="built_in">this</span>.name);<span class="comment">//内部类的属性</span></span><br><span class="line">System.out.println(Person.<span class="built_in">this</span>.name);<span class="comment">//外部类的属性</span></span><br><span class="line"><span class="comment">//Person.this.eat();</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-局部内部类"><a href="#5-局部内部类" class="headerlink" title="5 局部内部类"></a>5 局部内部类</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//返回一个实现了Comparable接口的类的对象</span><br><span class="line">public Comparable getComparable()&#123;</span><br><span class="line"></span><br><span class="line">//创建一个实现了Comparable接口的类:局部内部类</span><br><span class="line">//方式一：</span><br><span class="line"></span><br><span class="line">//class MyComparable implements Comparable&#123;</span><br><span class="line">//</span><br><span class="line">//@Override</span><br><span class="line">//public int compareTo(Object o) &#123;</span><br><span class="line">//return 0;</span><br><span class="line">//&#125;</span><br><span class="line">//&#125;</span><br><span class="line">//return new MyComparable();</span><br><span class="line"></span><br><span class="line">//方式二：</span><br><span class="line">return new Comparable()&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public int compareTo(Object o) &#123;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-注意点"><a href="#6-注意点" class="headerlink" title="6 注意点"></a>6 注意点</h4><p>在局部内部类的<strong>方法</strong>中如果调用局部内部类所声明的<strong>方法</strong>中的<strong>局部变量</strong>的话，要求此局部变量声明为final的</p><blockquote><p>jdk 7及之前版本：要求此局部变量显式的声明为final的<br>jdk 8及之后的版本：可以省略final的声明</p></blockquote><p><strong>总结：</strong></p><p>成员内部类和局部内部类，在编译以后，都会生成字节码文件。</p><p><strong>格式：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">成员内部类：外部类$内部类名.class</span><br><span class="line">局部内部类：外部类$数字 内部类名.class</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;面向对象学习的三条主线：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Java类及类的成员：属性、方法、构造器；&lt;strong&gt;代码块&lt;/strong&gt;、&lt;strong&gt;内部类&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;面向对象的三大特征：封装性、继承性、多态性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其它关键字：this、super、&lt;strong&gt;static&lt;/strong&gt;、&lt;strong&gt;final&lt;/strong&gt;、abstract、&lt;strong&gt;interface&lt;/strong&gt;、package、import等&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Java" scheme="https://actionding.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://actionding.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="编程" scheme="https://actionding.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://actionding.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】8-面向对象·中</title>
    <link href="https://actionding.github.io/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%918-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%C2%B7%E4%B8%AD/"/>
    <id>https://actionding.github.io/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%918-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%C2%B7%E4%B8%AD/</id>
    <published>2020-07-04T19:02:08.000Z</published>
    <updated>2020-09-12T09:41:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象学习的三条主线：</p><ol><li><p>Java类及类的成员：属性、方法、构造器；代码块、内部类</p></li><li><p>面向对象的三大特征：封装性、<strong>继承性</strong>、<strong>多态性</strong></p></li><li><p>其它关键字：this、<strong>super</strong>、static、final、abstract、interface、package、import等</p></li></ol><span id="more"></span><h3 id="一、OOP特征之继承性"><a href="#一、OOP特征之继承性" class="headerlink" title="一、OOP特征之继承性"></a>一、OOP特征之继承性</h3><h4 id="1-为什么要有类的继承性（继承性的好处）"><a href="#1-为什么要有类的继承性（继承性的好处）" class="headerlink" title="1 为什么要有类的继承性（继承性的好处）"></a>1 为什么要有类的继承性（继承性的好处）</h4><p>① 减少了代码的冗余，提高了代码的复用性</p><p>② 便于功能的扩展</p><p>③ 为之后多态性的使用，提供了前提</p><h4 id="2-继承性的格式"><a href="#2-继承性的格式" class="headerlink" title="2 继承性的格式"></a>2 继承性的格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> <span class="keyword">extends</span> <span class="title class_">B</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A:子类、派生类、subclass</span></span><br><span class="line"><span class="comment">// B:父类、超类、基类、superclass</span></span><br><span class="line"><span class="comment">// extends：延展、扩展</span></span><br></pre></td></tr></table></figure><h4 id="3-子类继承父类以后有哪些不同？"><a href="#3-子类继承父类以后有哪些不同？" class="headerlink" title="3 子类继承父类以后有哪些不同？"></a>3 子类继承父类以后有哪些不同？</h4><p>① 体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法</p><p>② 特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。只因为封装性的影响，使得子类不能直接调用父类的结构而已</p><p>③ 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。子类和父类的关系，不同于子集和集合的关系。（extends：延展、扩展）</p><h4 id="4-Java中继承性的说明"><a href="#4-Java中继承性的说明" class="headerlink" title="4 Java中继承性的说明"></a>4 Java中继承性的说明</h4><p>① 一个类可以被多个子类继承。<br>② Java中类的单继承性：一个类只能有一个父类<br>③ 子父类是相对的概念。<br>④ 子类直接继承的父类，称为：直接父类；间接继承的父类称为：间接父类<br>⑤ 子类继承父类以后，就获取了直接父类以及所间接父类中声明的属性和方法</p><h4 id="5-java-lang-Object类的理解"><a href="#5-java-lang-Object类的理解" class="headerlink" title="5 java.lang.Object类的理解"></a>5 java.lang.Object类的理解</h4><p>① 如果我们没显式的声明一个类的父类的话，则此类继承于java.lang.Object类</p><p>② 所有的java类（除java.lang.Object类之外）都直接或间接的继承于java.lang.Object类</p><p>③ 意味着，所有的java类具有java.lang.Object类声明的功能。</p><h3 id="二、方法的重写"><a href="#二、方法的重写" class="headerlink" title="二、方法的重写"></a>二、方法的重写</h3><h4 id="1-什么是方法的重写-override-或-overwrite"><a href="#1-什么是方法的重写-override-或-overwrite" class="headerlink" title="1 什么是方法的重写(override 或 overwrite)"></a>1 什么是方法的重写(override 或 overwrite)</h4><p>子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作</p><h4 id="2-应用"><a href="#2-应用" class="headerlink" title="2 应用"></a>2 应用</h4><p>重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法</p><h4 id="3-重写的规则"><a href="#3-重写的规则" class="headerlink" title="3 重写的规则"></a>3 重写的规则</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法的声明： 权限修饰符  返回值类型  方法名(形参列表) <span class="keyword">throws</span> 异常的类型&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法体</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法</p><p>① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表<strong>相同</strong></p><p>② 子类重写的方法的权限修饰符<strong>不小于</strong>父类被重写的方法的权限修饰符</p><blockquote><p>特殊情况：子类不能重写父类中声明为private权限的方法</p></blockquote><p>③ 返回值类型</p><blockquote><p>父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</p><p>父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</p><p>父类被重写的方法的返回值类型是基本数据类型(比如：double)，则子类重写的方法的返回值类型必须是相同的基本数据类型(必须也是double)</p></blockquote><p>④ 子类重写的方法抛出的异常类型<strong>不大于</strong>父类被重写的方法抛出的异常类型（具体放到异常处理时候讲）</p><p>⑤ 子类和父类中的同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（不是重写)。</p><p><strong>面试题</strong></p><p>区分方法的重写和重载？</p><p>答：① 二者的概念；② 重载和重写的具体规则；③ 重载：不表现为多态性；重写：表现为多态性。</p><p><strong>重载</strong>，是指允许存在多个同名方法，而这些方法的参数不同。编译器根据方法不同的参数表，对同名方法的名称做修饰。对于编译器而言，这些同名方法就成了不同的方法。它们的调用地址在编译期就绑定了。Java的重载是可以包括父类和子类的，即子类可以重载父类的同名不同参数的方法。所以，对于重载而言，在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”；而对于<strong>多态</strong>，只等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。 引用一句Bruce Eckel的话：“不要犯傻，如果它不是晚绑定，它就不是多态。”</p><h3 id="三、关键字super"><a href="#三、关键字super" class="headerlink" title="三、关键字super"></a>三、关键字super</h3><p>super 关键字可以理解为：父类的</p><h4 id="1-可以用来调用的结构"><a href="#1-可以用来调用的结构" class="headerlink" title="1 可以用来调用的结构"></a>1 可以用来调用的结构</h4><p>属性、方法、构造器</p><h4 id="2-super调用属性、方法"><a href="#2-super调用属性、方法" class="headerlink" title="2 super调用属性、方法"></a>2 super调用属性、方法</h4><p>① 我们可以在子类的方法或构造器中。通过使用”super.属性”或”super.方法”的方式，显式的调用父类中声明的属性或方法。但是，通常情况下，我们习惯省略”super.”</p><p>② 特殊情况：当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，则必须显式的使用”super.属性”的方式，表明调用的是父类中声明的属性</p><p>③ 特殊情况：当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的使用”super.方法”的方式，表明调用的是父类中被重写的方法</p><h4 id="3-super调用构造器"><a href="#3-super调用构造器" class="headerlink" title="3 super调用构造器"></a>3 super调用构造器</h4><p>① 我们可以在子类的构造器中显式的使用”super(形参列表)”的方式，调用父类中声明的指定的构造器</p><p>② “super(形参列表)”的使用，必须声明在子类构造器的首行！</p><p>③ 我们在类的构造器中，针对于”this(形参列表)”或”super(形参列表)”只能二选一，不能同时出现</p><p>④ 在构造器的首行，没显式的声明”this(形参列表)”或”super(形参列表)”，则默认调用的是父类中空参的构造器：super()</p><p>⑤ 在类的多个构造器中，至少一个类的构造器中使用了”super(形参列表)”，调用父类中的构造器</p><h4 id="4-子类对象实例化全过程"><a href="#4-子类对象实例化全过程" class="headerlink" title="4 子类对象实例化全过程"></a>4 子类对象实例化全过程</h4><p>1）从结果上看：继承性</p><p>子类继承父类以后，就获取了父类中声明的属性或方法。创建子类的对象，在堆空间中，就会加载所父类中声明的属性<br>2）从过程上看</p><p>当我们通过子类的构造器创建子类对象时，我们一定会直接或间接的调用其父类的构造器，进而调用父类的父类的构造器，……，直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所的父类的结构，所以才可以看到内存中父类中的结构，子类对象才可以考虑进行调用</p><blockquote><p>强调说明：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象。</p></blockquote><h3 id="四、OOP特征之多态性"><a href="#四、OOP特征之多态性" class="headerlink" title="四、OOP特征之多态性"></a>四、OOP特征之多态性</h3><p>多态性可以理解为一个事物的多种形态</p><h4 id="1何为多态性"><a href="#1何为多态性" class="headerlink" title="1何为多态性"></a>1何为多态性</h4><p>对象的多态性：<strong>父类的引用指向子类的对象</strong>（或子类的对象赋给父类的引用）</p><h4 id="2-多态性的使用：虚拟方法调用"><a href="#2-多态性的使用：虚拟方法调用" class="headerlink" title="2 多态性的使用：虚拟方法调用"></a>2 多态性的使用：虚拟方法调用</h4><p>有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。</p><blockquote><p>总结：编译，看左边；运行，看右边</p><p>注意点：对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</p><p>多态是编译时行为还是运行时行为？答：运行时行为</p></blockquote><h4 id="3-多态性的使用前提"><a href="#3-多态性的使用前提" class="headerlink" title="3 多态性的使用前提"></a>3 多态性的使用前提</h4><p>① 类的继承关系  </p><p>② 方法的重写</p><h4 id="4-关于向上转型与向下转型"><a href="#4-关于向上转型与向下转型" class="headerlink" title="4 关于向上转型与向下转型"></a>4 关于向上转型与向下转型</h4><p>1）向上转型：多态</p><p>2）向下转型</p><p>① 为什么使用向下转型？</p><p>有了对象的多态性以后，内存中实际上是加载了子类特有的属性和方法的，但是由于变量声明为父类类型，导致编译时，只能调用父类中声明的属性和方法。子类特有的属性和方法不能调用。如何才能调用子类特的属性和方法？使用向下转型</p><p>② 如何实现向下转型？</p><p>使用强制类型转换符：()</p><blockquote><p>使用时的注意点：<br>① 使用强转时，可能出现ClassCastException的异常。<br>② 为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断，一旦返回true，就进行向下转型。如果返回false，不进行向下转型。</p></blockquote><h4 id="5-instanceof-的使用"><a href="#5-instanceof-的使用" class="headerlink" title="5 instanceof 的使用"></a>5 instanceof 的使用</h4><p>① a instanceof A：判断对象a是否是类A的实例。如果是，返回true；如果不是，返回false</p><p>② 如果 a instanceof A返回true，则 a instanceof B也返回true。其中，类B是类A的父类</p><p>③ 要求a所属的类与类A必须是子类和父类的关系，否则编译错误</p><p><strong>面试题</strong></p><p>谈谈你对多态性的理解？</p><p>① 实现代码的通用性</p><p>② Object类中定义的public boolean equals(Object obj){  }<br>        JDBC:使用java程序操作(获取数据库连接、CRUD)数据库(MySQL、Oracle、DB2、SQL Server)</p><p>③ 抽象类、接口的使用肯定体现了多态性。（抽象类、接口不能实例化）</p><h3 id="五、Object类的使用"><a href="#五、Object类的使用" class="headerlink" title="五、Object类的使用"></a>五、Object类的使用</h3><h4 id="1-java-lang-Object类的说明"><a href="#1-java-lang-Object类的说明" class="headerlink" title="1 java.lang.Object类的说明"></a>1 java.lang.Object类的说明</h4><p>1）Object类是所Java类的根父类</p><p>2）如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类 </p><p>3）Object类中的功能(属性、方法)就具通用性。</p><p>① 属性：无</p><p>② 方法：equals() &#x2F; toString() &#x2F; getClass() &#x2F;hashCode() &#x2F; clone() &#x2F; finalize()；wait() 、 notify()、notifyAll()</p><p>4）Object类只声明了一个空参的构造器</p><h4 id="2-equals-方法"><a href="#2-equals-方法" class="headerlink" title="2 equals()方法"></a>2 equals()方法</h4><h5 id="1）equals-的使用"><a href="#1）equals-的使用" class="headerlink" title="1）equals()的使用"></a>1）equals()的使用</h5><p>① equals()是一个方法，而非运算符</p><p>② 只能适用于引用数据类型</p><p>③ Object类中equals()的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：Object类中定义的equals()和&#x3D;&#x3D;的作用是相同的：比较两个对象的地址值是否相同。即两个引用是否指向同一个对象实体</p><p>④ 像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同</p><p>⑤ 通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的”实体内容”是否相同。那么，我们就需要对Object类中的equals()进行重写</p><blockquote><p>重写的原则：比较两个对象的实体内容是否相同</p></blockquote><h5 id="2）如何重写equals"><a href="#2）如何重写equals" class="headerlink" title="2）如何重写equals()"></a>2）如何重写equals()</h5><p>开发中如何实现：自动生成的</p><blockquote><p>回顾 &#x3D;&#x3D; 运算符的使用：</p><ol><li><p>可以使用在基本数据类型变量和引用数据类型变量中</p></li><li><p>如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）</p><p>如果比较的是引用数据类型变量：比较两个对象的地址值是否相同.即两个引用是否指向同一个对象实体</p></li></ol><p>补充： &#x3D;&#x3D; 符号使用时，必须保证符号左右两边的变量类型一致。</p></blockquote><h4 id="3-toString-方法"><a href="#3-toString-方法" class="headerlink" title="3 toString()方法"></a>3 toString()方法</h4><h5 id="1）toString-的使用"><a href="#1）toString-的使用" class="headerlink" title="1）toString()的使用"></a>1）toString()的使用</h5><p>① 当我们输出一个对象的引用时，实际上就是调用当前对象的toString()</p><p>② Object类中toString()的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> getClass().getName() + <span class="string">&quot;@&quot;</span> + Integer.toHexString(hashCode());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③ 像String、Date、File、包装类等都重写了Object类中的toString()方法</p><p>​     使得在调用对象的toString()时，返回”实体内容”信息</p><p>④ 自定义类也可以重写toString()方法，当调用此方法时，返回对象的”实体内容”</p><h5 id="2）如何重写toString"><a href="#2）如何重写toString" class="headerlink" title="2）如何重写toString()"></a>2）如何重写toString()</h5><p>开发中如何实现：自动生成的</p><p><strong>面试题</strong></p><p>① final、finally、finalize的区别？</p><p>②  &#x3D;&#x3D; 和 equals() 区别</p><h3 id="六、Java中的JUnit单元测试"><a href="#六、Java中的JUnit单元测试" class="headerlink" title="六、Java中的JUnit单元测试"></a>六、Java中的JUnit单元测试</h3><h4 id="1-步骤"><a href="#1-步骤" class="headerlink" title="1 步骤"></a>1 步骤</h4><p>1）在中当前工程 - 右键择：build path - add libraries - JUnit 4 - 下一步</p><p>2）创建Java类，进行单元测试。</p><p>​      此时的Java类要求：① 此类是public的  ②此类提供公共的无参的构造器</p><p>3）此类中声明单元测试方法</p><p>​      此时的单元测试方法：方法的权限是public,没返回值，没形参</p><p>4）此单元测试方法上需要声明注解：@Test,并在单元测试类中导入：import org.junit.Test;</p><p>5）声明好单元测试方法以后，就可以在方法体内测试相关的代码。</p><p>6）写完代码以后，左键双击单元测试方法名，右键：run as - JUnit Test</p><h5 id="2-说明"><a href="#2-说明" class="headerlink" title="2 说明"></a>2 说明</h5><p>1）如果执行结果没任何异常：绿条</p><p>2）如果执行结果出现异常：红条</p><h3 id="七、包装类的使用"><a href="#七、包装类的使用" class="headerlink" title="七、包装类的使用"></a>七、包装类的使用</h3><h4 id="1-为什么要有包装类-或封装类）"><a href="#1-为什么要有包装类-或封装类）" class="headerlink" title="1 为什么要有包装类(或封装类）"></a>1 为什么要有包装类(或封装类）</h4><p>为了使基本数据类型的变量具有类的特征，引入包装类。</p><h4 id="2-基本数据类型与对应的包装类"><a href="#2-基本数据类型与对应的包装类" class="headerlink" title="2 基本数据类型与对应的包装类"></a>2 基本数据类型与对应的包装类</h4><p><img src="/../../images/%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8C%85%E8%A3%85%E7%B1%BB.png" alt="基本数据类型与对应的包装类"></p><h4 id="3-需要掌握的类型间的转换：（基本数据类型、包装类、String）"><a href="#3-需要掌握的类型间的转换：（基本数据类型、包装类、String）" class="headerlink" title="3 需要掌握的类型间的转换：（基本数据类型、包装类、String）"></a>3 需要掌握的类型间的转换：（基本数据类型、包装类、String）</h4><p><img src="/../../images/%E7%B1%BB%E5%9E%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png" alt="类型间的转换"></p><p>简易版：</p><p>基本数据类型&lt;—&gt;包装类：JDK 5.0 新特性：自动装箱 与 自动拆箱</p><p>基本数据类型、包装类—&gt;String:调用String重载的valueOf(Xxx xxx)</p><p>String—&gt;基本数据类型、包装类:调用包装类的parseXxx(String s)</p><p><strong>注意</strong>：转换时，可能会报NumberFormatException</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;面向对象学习的三条主线：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Java类及类的成员：属性、方法、构造器；代码块、内部类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;面向对象的三大特征：封装性、&lt;strong&gt;继承性&lt;/strong&gt;、&lt;strong&gt;多态性&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其它关键字：this、&lt;strong&gt;super&lt;/strong&gt;、static、final、abstract、interface、package、import等&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Java" scheme="https://actionding.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://actionding.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="编程" scheme="https://actionding.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://actionding.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】7-面向对象·上</title>
    <link href="https://actionding.github.io/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%917-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%C2%B7%E4%B8%8A/"/>
    <id>https://actionding.github.io/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%917-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%C2%B7%E4%B8%8A/</id>
    <published>2020-07-04T19:02:07.000Z</published>
    <updated>2020-09-12T09:40:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>面向对象学习的三条主线：</p><ol><li><p>Java类及类的成员：<strong>属性</strong>、<strong>方法</strong>、<strong>构造器</strong>；代码块、内部类</p></li><li><p>面向对象的三大特征：<strong>封装性</strong>、继承性、多态性</p></li><li><p>其它关键字：<strong>this</strong>、super、static、final、abstract、interface、<strong>package</strong>、<strong>import</strong>等</p></li></ol><span id="more"></span><h3 id="一、类和对象"><a href="#一、类和对象" class="headerlink" title="一、类和对象"></a>一、类和对象</h3><h4 id="1-面向对象与面向过程"><a href="#1-面向对象与面向过程" class="headerlink" title="1 面向对象与面向过程"></a>1 面向对象与面向过程</h4><p>1）面向过程：强调的是<strong>功能行为</strong>，以函数为最小单位，考虑<strong>怎么做</strong></p><p>2）面向对象：强调具备了功能的<strong>对象</strong>，以类&#x2F;对象为最小单位，考虑<strong>谁来做</strong></p><p>举例对比：<strong>人</strong>把<strong>大象</strong>装进<strong>冰箱</strong>。</p><blockquote><p>面向对象：Object Oriented Programming<br>面向过程：Procedure Oriented Programming</p></blockquote><h4 id="2-面向对象中两个重要的概念"><a href="#2-面向对象中两个重要的概念" class="headerlink" title="2 面向对象中两个重要的概念"></a>2 面向对象中两个重要的概念</h4><p>1）类（Class）：对一类事物的描述，是抽象的、概念上的定义</p><p>2）对象（Object）：是实际存在的该类事物的每个个体，因而也称为实例（instance）</p><p><strong>二者的关系</strong>：对象，是由类new出来的，派生出来的。</p><p><strong>“万事万物皆对象”</strong></p><blockquote><p>面向对象程序设计的重点是类的设计</p><p>设计类，就是设计类的成员</p><p>创建类的对象 &#x3D; 类的实例化 &#x3D; 实例化类</p><p>匿名对象：我们创建的对象，没显式的赋给一个变量名。即为匿名对象</p><p>特点：匿名对象只能调用一次</p></blockquote><h4 id="3-面向对象的三大特征"><a href="#3-面向对象的三大特征" class="headerlink" title="3 面向对象的三大特征"></a>3 面向对象的三大特征</h4><p>1）封装（Encapsulation）</p><p>2）继承（Inheritance）</p><p>3）多态（Polymorphism）</p><h3 id="二、类的成员"><a href="#二、类的成员" class="headerlink" title="二、类的成员"></a>二、类的成员</h3><h4 id="1-类的属性"><a href="#1-类的属性" class="headerlink" title="1 类的属性"></a>1 类的属性</h4><p><strong>属性</strong>：对应类中的<strong>成员变量</strong></p><blockquote><p>属性 &#x3D; 成员变量 &#x3D; field &#x3D; 域、字段</p></blockquote><p><strong>属性与局部变量的对比</strong></p><p>1）相同点</p><ul><li><pre><code>    定义变量的**格式**：数据类型  变量名 = 变量值</code></pre></li><li><pre><code>    先声明，后使用</code></pre></li><li><pre><code>    变量都其对应的作用域</code></pre></li></ul><p>2）不同点</p><p>① 在类中声明的位置的不同</p><ul><li><pre><code>    属性：直接定义在类的一对&#123;&#125;内</code></pre></li><li><pre><code>    局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</code></pre></li></ul><p>② 关于权限修饰符的不同</p><ul><li><pre><code>    属性：可以在声明属性时，指明其权限，使用权限修饰符。</code></pre><ul><li><pre><code>        常用的权限修饰符：private、public、缺省、protected  ---&gt;封装性</code></pre></li></ul></li><li><pre><code>    局部变量：不可以使用权限修饰符。</code></pre></li></ul><p>③ 默认初始化值的情况：</p><ul><li><pre><code>    属性：类的属性，根据其类型，都默认初始化值。</code></pre><ul><li><pre><code>        整型（byte、short、int、long：0）</code></pre></li><li><pre><code>        浮点型（float、double：0.0）</code></pre></li><li><pre><code>        字符型（char：0  （或&#39;\u0000&#39;））</code></pre></li><li><pre><code>        布尔型（boolean：false）</code></pre></li><li><pre><code>        引用数据类型（类、数组、接口：null）</code></pre></li></ul></li><li><pre><code>    局部变量：没默认初始化值。</code></pre><ul><li><pre><code>     意味着，我们在调用局部变量之前，一定要显式赋值。</code></pre></li><li><pre><code>        特别地：形参在调用时，我们赋值即可。</code></pre></li></ul></li></ul><p>④ 在内存中加载的位置：</p><ul><li><pre><code>    属性：加载到**堆**空间中   （非static）</code></pre></li><li><pre><code>    局部变量：加载到**栈**空间</code></pre></li></ul><h4 id="2-类的方法"><a href="#2-类的方法" class="headerlink" title="2 类的方法"></a>2 类的方法</h4><p><strong>方法</strong>：描述类应该具的功能。</p><blockquote><p>方法 &#x3D; 成员方法 &#x3D; 函数 &#x3D; method</p></blockquote><p><strong>方法的声明</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符 返回值类型 方法名(形参列表)&#123;</span><br><span class="line">方法体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）<strong>权限修饰符</strong></p><p>默认方法的权限修饰符先都使用public</p><p>Java规定的4种权限修饰符：private、public、缺省、protected  –&gt;封装性再细说</p><p>2）<strong>返回值类型</strong></p><p>返回值  vs 没返回值</p><p>① 如果方法返回值，则必须在方法声明时，指定返回值的类型。同时，方法中，需要使用</p><p>return关键字来返回指定类型的变量或常量：“return 数据”。</p><p>② 如果方法没返回值，则方法声明时，使用void来表示。通常，没返回值的方法中，就不需要</p><p>使用return.但是，如果使用的话，只能“return;”表示结束此方法的意思。</p><p>3）<strong>方法名</strong></p><p>属于标识符，遵循标识符的规则和规范，“见名知意”</p><p>4） <strong>形参列表</strong></p><p>方法可以声明0个，1个，或多个形参。</p><p><strong>格式</strong>：数据类型1 形参1,数据类型2 形参2,…</p><p>5）<strong>方法体</strong></p><p>方法功能的体现。     </p><blockquote><p>return关键字</p><p>使用范围：使用在方法体中</p><p>作用：</p><p>① 结束方法</p><p>② 针对于返回值类型的方法，使用”return 数据”方法返回所要的数据。</p><p><strong>注意点</strong>：return关键字后面不可以声明执行语句。</p></blockquote><h4 id="3-方法的重载"><a href="#3-方法的重载" class="headerlink" title="3 方法的重载"></a>3 方法的重载</h4><p>定义：在同一个类中，允许存在一个以上的<strong>同名方法</strong>，只要它们的参数个数或者参数类型不同即可。</p><p><strong>“两同一不同”</strong></p><p>1）同一个类、相同方法名</p><p>2）参数列表不同：参数个数不同，参数类型不同</p><blockquote><p>严格按照定义判断：两同一不同。</p><p>跟方法的权限修饰符、返回值类型、形参变量名、方法体都没关系！</p></blockquote><p><strong>可变个数形参的方法</strong></p><p>1）可变个数形参的格式：数据类型 … 变量名</p><p>2）当调用可变个数形参的方法时，传入的参数个数可以是：0个，1个,2个，。。。</p><p>3）可变个数形参的方法与本类中方法名相同，形参不同的方法之间构成重载</p><p>4）可变个数形参的方法与本类中方法名相同，形参类型也相同的数组之间不构成重载。换句话说，二者不能共存。</p><p>5）可变个数形参在方法的形参中，必须声明在末尾</p><p>6）可变个数形参在方法的形参中,最多只能声明一个可变形参。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String s)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;show(String)&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(String ... strs)</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;show(String ... strs)&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; strs.length;i++)&#123;</span><br><span class="line">System.out.println(strs[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不能与上一个方法同时存在</span></span><br><span class="line"><span class="comment">//public void show(String[] strs)&#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br></pre></td></tr></table></figure><h4 id="4-java的值传递机制"><a href="#4-java的值传递机制" class="headerlink" title="4 java的值传递机制"></a>4 java的值传递机制</h4><p>1）值传递规则</p><p>如果变量是<strong>基本数据类型</strong>，此时赋值的是变量所保存的<strong>数据值</strong></p><p>如果变量是<strong>引用数据类型</strong>，此时赋值的是变量所保存的<strong>数据的地址值</strong></p><p>2）形参和实参</p><p>形参：方法定义时，声明的小括号内的参数</p><p>实参：方法调用时，实际传递给形参的数据</p><p>3）java中参数传递机制：值传递</p><p><strong>规则</strong></p><p>如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值</p><p>如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值</p><h4 id="5-递归方法"><a href="#5-递归方法" class="headerlink" title="5 递归方法"></a>5 递归方法</h4><p>定义：一个方法体内调用它自身</p><p>理解</p><p>方法递归包含了一种隐式的循环，它会重复执行某段代码，但这种重复执行无须循环控制。</p><p>递归一定要向已知方向递归，否则这种递归就变成了无穷递归，类似于死循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例1：计算1-n之间所自然数的和</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum</span><span class="params">(<span class="type">int</span> n)</span> &#123;<span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n + getSum(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 例2：计算1-n之间所自然数的乘积:n!</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSum1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> n * getSum1(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例3：已知一个数列：f(0) = 1,f(1) = 4,f(n+2)=2*f(n+1) + f(n),</span></span><br><span class="line"><span class="comment">//其中n是大于0的整数，求f(10)的值。</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">1</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line"><span class="comment">//return f(n + 2) - 2 * f(n + 1);</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>*f(n - <span class="number">1</span>) + f(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例4：斐波那契数列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例5：汉诺塔问题</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//例6：快排</span></span><br></pre></td></tr></table></figure><h4 id="6-类的构造器"><a href="#6-类的构造器" class="headerlink" title="6 类的构造器"></a>6 类的构造器</h4><p>1）构造器（或构造方法，Constructor）的作用：</p><p>① 创建对象</p><p>② 初始化对象的信息</p><p>2）使用说明</p><p>① 如果没显式的定义类的构造器的话，则系统默认提供一个空参的构造器</p><p>② 定义构造器的格式：<code>权限修饰符  类名(形参列表)&#123;&#125;</code></p><p>③ 一个类中定义的多个构造器，彼此构成重载</p><p>④ 一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器</p><p>⑤ 一个类中，至少会有一个构造器。</p><blockquote><p>总结：属性赋值的先后顺序</p><p>① 默认初始化</p><p>② 显式初始化</p><p>③ 构造器中初始化</p><p>④ 通过”对象.方法” 或 “对象.属性”的方式，赋值</p><p>以上操作的先后顺序：① - ② - ③ - ④  </p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">所谓JavaBean，是指符合如下标准的Java类：</span><br><span class="line">&gt;类是公共的</span><br><span class="line">&gt;一个无参的公共的构造器</span><br><span class="line">&gt;属性，且对应的get、set方法</span><br></pre></td></tr></table></figure><h4 id="7-关键字this"><a href="#7-关键字this" class="headerlink" title="7 关键字this"></a>7 关键字this</h4><p>1）可以调用的结构：属性、方法；构造器</p><p>2）this 调用属性、方法：</p><p>this 理解为：当前对象  或 当前正在创建的对象</p><p>① 在类的方法中，我们可以使用<code>this.属性</code>或<code>this.方法</code>的方式，调用当前对象属性或方法。但是，通常情况下，我们都择省略<code>this.</code>。特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用<code>this.变量</code>的方式，表明此变量是属性，而非形参。</p><p>② 在类的构造器中，我们可以使用<code>this.属性</code>或<code>this.方法</code>的方式，调用当前正在创建的对象属性或方法。但是，通常情况下，我们都择省略<code>this.</code>。特殊情况下，如果构造器的形参和类的属性<strong>同名</strong>时，我们必须显式的使用<code>this.变量</code>的方式，表明此变量是属性，而非形参。</p><p>3）this调用构造器：</p><p>① 我们在类的构造器中，可以显式的使用”this(形参列表)”方式，调用本类中指定的其他构造器</p><p>② 构造器中不能通过<code>this(形参列表)</code>方式调用自己</p><p>③ 如果一个类中有n个构造器，则最多有 n - 1构造器中使用了<code>this(形参列表)</code></p><p>④ 规定：<code>this(形参列表)</code>必须声明在当前构造器的<strong>首行</strong></p><p>⑤ 构造器内部，<strong>最多只能声明一个</strong><code>this(形参列表)</code>，用来调用其他的构造器</p><h4 id="8-关键字package"><a href="#8-关键字package" class="headerlink" title="8 关键字package"></a>8 关键字package</h4><h5 id="1）使用说明"><a href="#1）使用说明" class="headerlink" title="1）使用说明"></a>1）使用说明</h5><p>① 为了更好的实现项目中类的管理，提供包的概念</p><p>② 使用package声明类或接口所属的包，声明在源文件的首行</p><p>③ 包，属于标识符，遵循标识符的命名规则、规范(xxxyyyzzz)、“见名知意”</p><p>④ 每”.”一次，就代表一层文件目录。</p><h5 id="2）举例：MVC设计模式"><a href="#2）举例：MVC设计模式" class="headerlink" title="2）举例：MVC设计模式"></a>2）举例：MVC设计模式</h5><p><img src="/.io//../images%5CMVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" alt="MVC设计模式"></p><h5 id="3）JDK中的主要包介绍"><a href="#3）JDK中的主要包介绍" class="headerlink" title="3）JDK中的主要包介绍"></a>3）JDK中的主要包介绍</h5><p><img src="/.io//images%5CJDK%E4%B8%AD%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%85.png" alt="JDK中的主要包"></p><h4 id="9-关键字import"><a href="#9-关键字import" class="headerlink" title="9 关键字import"></a>9 关键字import</h4><h5 id="1）使用说明-1"><a href="#1）使用说明-1" class="headerlink" title="1）使用说明"></a>1）使用说明</h5><p>① 在源文件中显式的使用import结构导入指定包下的类、接口</p><p>② 声明在包的声明和类的声明之间</p><p>③ 如果需要导入多个结构，则并列写出即可</p><p>④ 可以使用”xxx.*”的方式，表示可以导入xxx包下的所结构</p><p>⑤ 如果使用的类或接口是java.lang包下定义的，则可以省略import结构</p><p>⑥ 如果使用的类或接口是本包下定义的，则可以省略import结构</p><p>⑦ 如果在源文件中，使用了不同包下的同名的类，则必须至少一个类需要以全类名的方式显示。</p><p>⑧ 使用”xxx.*”方式表明可以调用xxx包下的所有结构。但是如果使用的是xxx子包下的结构，则仍需要显式导入</p><p>⑨ <code>import static</code>：导入指定类或接口中的静态结构（属性或方法） </p><h3 id="三、OOP特征之封装性"><a href="#三、OOP特征之封装性" class="headerlink" title="三、OOP特征之封装性"></a>三、OOP特征之封装性</h3><h4 id="1-为什么要引入封装性？"><a href="#1-为什么要引入封装性？" class="headerlink" title="1 为什么要引入封装性？"></a>1 为什么要引入封装性？</h4><p>① 我们程序设计追求<strong>“高内聚，低耦合”</strong>。</p><p>高内聚 ：类的内部数据操作细节自己完成，不允许外部干涉；</p><p>低耦合 ：仅对外暴露少量的方法用于使用。</p><p>② 隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。</p><h4 id="2-封装性思想具体的代码体现"><a href="#2-封装性思想具体的代码体现" class="headerlink" title="2 封装性思想具体的代码体现"></a>2 封装性思想具体的代码体现</h4><p>体现一：将类的属性xxx私化(private),同时，提供公共的(public)方法来获取(getXxx)和设置(setXxx)此属性的值</p><p>体现二：不对外暴露的私有的方法</p><p>体现三：单例模式（将构造器私有化）</p><p>体现四：如果不希望类在包外被调用，可以将类设置为缺省的。</p><h4 id="3）Java规定的四种权限修饰符"><a href="#3）Java规定的四种权限修饰符" class="headerlink" title="3）Java规定的四种权限修饰符"></a>3）Java规定的四种权限修饰符</h4><p>① 权限从小到大顺序为：private &lt;  缺省 &lt; protected &lt; public</p><p>② 具体的修饰范围：</p><table><thead><tr><th align="center">修饰符</th><th align="center">内部类</th><th align="center">同一个包</th><th align="center">不同包的子类</th><th align="center">同一个工程</th></tr></thead><tbody><tr><td align="center">private</td><td align="center">Yes</td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td align="center">（缺省）</td><td align="center">Yes</td><td align="center">Yes</td><td align="center"></td><td align="center"></td></tr><tr><td align="center">protected</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">Yes</td><td align="center"></td></tr><tr><td align="center">public</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">Yes</td><td align="center">Yes</td></tr></tbody></table><p>③ 权限修饰符可用来修饰的结构</p><p>4种权限都可以用来修饰类的内部结构：属性、方法、构造器、内部类</p><p>修饰类的话，只能使用：缺省、public</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;面向对象学习的三条主线：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Java类及类的成员：&lt;strong&gt;属性&lt;/strong&gt;、&lt;strong&gt;方法&lt;/strong&gt;、&lt;strong&gt;构造器&lt;/strong&gt;；代码块、内部类&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;面向对象的三大特征：&lt;strong&gt;封装性&lt;/strong&gt;、继承性、多态性&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;其它关键字：&lt;strong&gt;this&lt;/strong&gt;、super、static、final、abstract、interface、&lt;strong&gt;package&lt;/strong&gt;、&lt;strong&gt;import&lt;/strong&gt;等&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Java" scheme="https://actionding.github.io/categories/Java/"/>
    
    <category term="Java基础" scheme="https://actionding.github.io/categories/Java/Java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="编程" scheme="https://actionding.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://actionding.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】6-数组</title>
    <link href="https://actionding.github.io/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%916-%E6%95%B0%E7%BB%84/"/>
    <id>https://actionding.github.io/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%916-%E6%95%B0%E7%BB%84/</id>
    <published>2020-07-04T19:02:06.000Z</published>
    <updated>2022-03-08T12:43:16.102Z</updated>
    
    <content type="html"><![CDATA[<p>数组、一维数组、二维数组</p><span id="more"></span><h3 id="一、数组的概念"><a href="#一、数组的概念" class="headerlink" title="一、数组的概念"></a>一、数组的概念</h3><h4 id="1-数组的理解"><a href="#1-数组的理解" class="headerlink" title="1 数组的理解"></a>1 数组的理解</h4><p>数组 (<strong>Array</strong>) 是多个相同类型数据按一定顺序排列的集合，并使用一个名字命名，并通过编号的方式对这些数据进行统一管理。</p><h4 id="2-相关的概念"><a href="#2-相关的概念" class="headerlink" title="2 相关的概念"></a>2 相关的概念</h4><p>1）<strong>数组名</strong></p><p>2）<strong>元素</strong></p><p>3）<strong>索引</strong>：角标、下标、</p><p>4）<strong>数组的长度</strong>：元素的个数</p><h4 id="3-数组的特点"><a href="#3-数组的特点" class="headerlink" title="3 数组的特点"></a>3 数组的特点</h4><p>1）数组是有序排列的</p><p>2）数组属于<strong>引用数据类型</strong>的变量。数组的元素，既可以是基本数据类型，也可以是引用数据类型</p><p>3）创建数组对象会在内存中开辟一整块连续的空间</p><p>4）数组的长度一旦确定，就不能修改</p><h4 id="4-数组的分类"><a href="#4-数组的分类" class="headerlink" title="4 数组的分类"></a>4 数组的分类</h4><p>1）按照维数：一维数组、二维数组……</p><p>2）按照数组元素的类型：基本数据类型元素的数组、引用数据类型元素的数组</p><h3 id="二、一维数组"><a href="#二、一维数组" class="headerlink" title="二、一维数组"></a>二、一维数组</h3><h4 id="1-声明与初始化"><a href="#1-声明与初始化" class="headerlink" title="1 声明与初始化"></a>1 声明与初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] ids;<span class="comment">//声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//①静态初始化:数组的初始化和数组元素的赋值操作同时进行</span></span><br><span class="line">ids = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1001</span>,<span class="number">1002</span>,<span class="number">1003</span>,<span class="number">1004</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//②动态初始化:数组的初始化和数组元素的赋值操作分开进行</span></span><br><span class="line">String[] names = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">5</span>];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span>[] arr4 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;<span class="comment">//类型推断</span></span><br></pre></td></tr></table></figure><h4 id="2-调用数组的指定位置的元素"><a href="#2-调用数组的指定位置的元素" class="headerlink" title="2 调用数组的指定位置的元素"></a>2 调用数组的指定位置的元素</h4><p>通过角标的方式调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">names[<span class="number">0</span>] = <span class="string">&quot;王铭&quot;</span>;</span><br><span class="line">names[<span class="number">1</span>] = <span class="string">&quot;王赫&quot;</span>;</span><br><span class="line">names[<span class="number">2</span>] = <span class="string">&quot;张学良&quot;</span>;</span><br><span class="line">names[<span class="number">3</span>] = <span class="string">&quot;孙居龙&quot;</span>;</span><br><span class="line">names[<span class="number">4</span>] = <span class="string">&quot;王宏志&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="3-数组的长度"><a href="#3-数组的长度" class="headerlink" title="3 数组的长度"></a>3 数组的长度</h4><p>数组一旦初始化，其长度就是确定的，就不可修改。使用<code>arr.length</code>获取数组的长度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(names.length);<span class="comment">//5</span></span><br><span class="line">System.out.println(ids.length);</span><br></pre></td></tr></table></figure><h4 id="4-遍历数组"><a href="#4-遍历数组" class="headerlink" title="4 遍历数组"></a>4 遍历数组</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; names.length;i++)&#123;</span><br><span class="line">System.out.println(names[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-数组元素的默认初始化值"><a href="#5-数组元素的默认初始化值" class="headerlink" title="5 数组元素的默认初始化值"></a>5 数组元素的默认初始化值</h4><p>1）数组元素是整型：0</p><p>2）数组元素是浮点型：0.0</p><p>3）数组元素是char型：0 或 ‘\u0000’，而非 ‘0’</p><p>4）数组元素是boolean型：false</p><p>5）数组元素是引用数据类型：null</p><h3 id="三、二维数组"><a href="#三、二维数组" class="headerlink" title="三、二维数组"></a>三、二维数组</h3><h4 id="1-理解二维数组"><a href="#1-理解二维数组" class="headerlink" title="1 理解二维数组"></a>1 理解二维数组</h4><p>一个一维数组A的元素如果还是一个一维数组类型的，则，此数组A称为二维数组</p><h4 id="2-声明与初始化"><a href="#2-声明与初始化" class="headerlink" title="2 声明与初始化"></a>2 声明与初始化</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">int[][] arr1;//声明</span><br><span class="line"></span><br><span class="line">//静态初始化</span><br><span class="line">arr1 = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;</span><br><span class="line">//动态初始化1</span><br><span class="line">String[][] arr2 = new String[3][2];</span><br><span class="line">//动态初始化2</span><br><span class="line">String[][] arr3 = new String[3][];</span><br><span class="line"></span><br><span class="line">int[] arr4[] = new int[][]&#123;&#123;1,2,3&#125;,&#123;4,5,9,10&#125;,&#123;6,7,8&#125;&#125;;//也是正确的写法</span><br><span class="line">int[] arr5[] = &#123;&#123;1,2,3&#125;,&#123;4,5&#125;,&#123;6,7,8&#125;&#125;;//类型推断</span><br></pre></td></tr></table></figure><h4 id="3-调用数组的指定位置的元素"><a href="#3-调用数组的指定位置的元素" class="headerlink" title="3 调用数组的指定位置的元素"></a>3 调用数组的指定位置的元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(arr1[<span class="number">0</span>][<span class="number">1</span>]);<span class="comment">//2</span></span><br><span class="line">System.out.println(arr2[<span class="number">1</span>][<span class="number">1</span>]);<span class="comment">//null</span></span><br><span class="line"></span><br><span class="line">arr3[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">String</span>[<span class="number">4</span>];</span><br><span class="line">System.out.println(arr3[<span class="number">1</span>][<span class="number">0</span>]);</span><br><span class="line">System.out.println(arr3[<span class="number">0</span>]);<span class="comment">//</span></span><br></pre></td></tr></table></figure><h4 id="4-数组的长度"><a href="#4-数组的长度" class="headerlink" title="4 数组的长度"></a>4 数组的长度</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(arr4.length);<span class="comment">//3</span></span><br><span class="line">System.out.println(arr4[<span class="number">0</span>].length);<span class="comment">//3</span></span><br><span class="line">System.out.println(arr4[<span class="number">1</span>].length);<span class="comment">//4</span></span><br></pre></td></tr></table></figure><h4 id="5-遍历二维数组元素"><a href="#5-遍历二维数组元素" class="headerlink" title="5 遍历二维数组元素"></a>5 遍历二维数组元素</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr4.length;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arr4[i].length;j++)&#123;</span><br><span class="line">System.out.print(arr4[i][j] + <span class="string">&quot;  &quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-默认初始化值"><a href="#6-默认初始化值" class="headerlink" title="6 默认初始化值"></a>6 默认初始化值</h4><p>二维数组分为外层数组的元素，内层数组的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">外层元素：arr[<span class="number">0</span>],arr[<span class="number">1</span>]等</span><br><span class="line"></span><br><span class="line">内层元素：arr[<span class="number">0</span>][<span class="number">0</span>],arr[<span class="number">1</span>][<span class="number">2</span>]等</span><br></pre></td></tr></table></figure><p>1）针对于初始化方式一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>外层元素的初始化值为：<strong>地址值</strong></p><p>内层元素的初始化值为：与一维数组初始化情况相同</p><p>2）针对于初始化方式二</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][];</span><br></pre></td></tr></table></figure><p>外层元素的初始化值为：<strong>null</strong></p><p>内层元素的初始化值为：不能调用，否则报错。</p><h3 id="四、数组的常见算法"><a href="#四、数组的常见算法" class="headerlink" title="四、数组的常见算法"></a>四、数组的常见算法</h3><h4 id="1-数组的创建与元素赋值"><a href="#1-数组的创建与元素赋值" class="headerlink" title="1 数组的创建与元素赋值"></a>1 数组的创建与元素赋值</h4><p>杨辉三角（二维数组）、回形数（二维数组）、6个数，1-30之间随机生成且不重复。</p><h4 id="2-对于数值型的数组"><a href="#2-对于数值型的数组" class="headerlink" title="2 对于数值型的数组"></a>2 对于数值型的数组</h4><p>最大值、最小值、总和、平均数</p><h4 id="3-数组的赋值与复制"><a href="#3-数组的赋值与复制" class="headerlink" title="3 数组的赋值与复制"></a>3 数组的赋值与复制</h4><p><strong>1）赋值</strong></p><p>两个变量指向同一个数组的地址，修改一个数组的元素，另一个也跟着修改。</p><p><strong>2）复制</strong></p><p>两个独立的数组，数组的元素相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr1,arr2;</span><br><span class="line">arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">arr2 = arr1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//复制</span></span><br><span class="line">arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[arr1.length];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr2.length;i++)&#123;</span><br><span class="line">arr2[i] = arr1[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-反转"><a href="#4-反转" class="headerlink" title="4 反转"></a>4 反转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法一：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length / <span class="number">2</span>;i++)&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">arr[i] = arr[arr.length - i -<span class="number">1</span>];</span><br><span class="line">arr[arr.length - i -<span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>,j = arr.length - <span class="number">1</span>;i &lt; j;i++,j--)&#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">arr[i] = arr[j];</span><br><span class="line">arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-查找"><a href="#5-查找" class="headerlink" title="5 查找"></a>5 查找</h4><p><strong>1）线性查找</strong> </p><p><strong>实现思路</strong>：通过遍历的方式，一个一个的数据进行比较、查找</p><p><strong>适用性</strong>：具有普遍适用性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length;i++)&#123;</span><br><span class="line"><span class="keyword">if</span>(dest.equals(arr[i]))&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;找到了指定的元素，位置为：&quot;</span> + i);</span><br><span class="line">isFlag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;很遗憾，没有找到的啦！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）二分法查找</strong></p><p><strong>实现思路</strong>：每次比较中间值，折半的方式检索</p><p><strong>适用性</strong>：（前提：数组必须有序）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">head</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//初始的首索引</span></span><br><span class="line"><span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;<span class="comment">//初始的末索引</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isFlag</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">while</span>(head &lt;= end)&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">middle</span> <span class="operator">=</span> (head + end)/<span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span>(dest == arr[middle])&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;找到了指定的元素，位置为：&quot;</span> + middle);</span><br><span class="line">isFlag = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(arr[middle] &gt; dest1)&#123;</span><br><span class="line">end = middle - <span class="number">1</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;<span class="comment">//arr[middle] &lt; dest1</span></span><br><span class="line">head = middle + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(isFlag)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;很遗憾，没有找到的啦！&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-排序"><a href="#6-排序" class="headerlink" title="6 排序"></a>6 排序</h4><table><thead><tr><th align="center">排序算法</th><th align="center">平均时间复杂度</th><th align="center">最差时间复杂度</th><th align="center">空间复杂度</th><th align="center">数据对象稳定性</th></tr></thead><tbody><tr><td align="center">冒泡排序</td><td align="center">O(n2)</td><td align="center">O(n2)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">选择排序</td><td align="center">O(n2)</td><td align="center">O(n2)</td><td align="center">O(1)</td><td align="center">数组不稳定、链表稳定</td></tr><tr><td align="center">插入排序</td><td align="center">O(n2)</td><td align="center">O(n2)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">快速排序</td><td align="center">O(n*log2n)</td><td align="center">O(n2)</td><td align="center">O(log2n)</td><td align="center">不稳定</td></tr><tr><td align="center">堆排序</td><td align="center">O(n*log2n)</td><td align="center">O(n*log2n)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">归并排序</td><td align="center">O(n*log2n)</td><td align="center">O(n*log2n)</td><td align="center">O(n)</td><td align="center">稳定</td></tr><tr><td align="center">希尔排序</td><td align="center">O(n*log2n)</td><td align="center">O(n2)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">计数排序</td><td align="center">O(n+m)</td><td align="center">O(n+m)</td><td align="center">O(n+m)</td><td align="center">稳定</td></tr><tr><td align="center">桶排序</td><td align="center">O(n)</td><td align="center">O(n)</td><td align="center">O(m)</td><td align="center">稳定</td></tr><tr><td align="center">基数排序</td><td align="center">O(k*n)</td><td align="center">O(n2)</td><td align="center"></td><td align="center">稳定</td></tr></tbody></table><p><strong>1）冒泡排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;i &lt; arr.length - <span class="number">1</span>;i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;j &lt; arr.length - <span class="number">1</span> - i;j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(arr[j] &gt; arr[j + <span class="number">1</span>])&#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2）快速排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">QuickSort</span> &#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] data, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> data[i];</span><br><span class="line">data[i] = data[j];</span><br><span class="line">data[j] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">subSort</span><span class="params">(<span class="type">int</span>[] data, <span class="type">int</span> start, <span class="type">int</span> end)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (start &lt; end) &#123;</span><br><span class="line"><span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> data[start];</span><br><span class="line"><span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> start;</span><br><span class="line"><span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> end + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">while</span> (low &lt; end &amp;&amp; data[++low] - base &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line"><span class="keyword">while</span> (high &gt; start &amp;&amp; data[--high] - base &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line"><span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">swap(data, low, high);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">swap(data, start, high);</span><br><span class="line"></span><br><span class="line">subSort(data, start, high - <span class="number">1</span>);<span class="comment">//递归调用</span></span><br><span class="line">subSort(data, high + <span class="number">1</span>, end);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">quickSort</span><span class="params">(<span class="type">int</span>[] data)</span>&#123;</span><br><span class="line">subSort(data,<span class="number">0</span>,data.length-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、Array工具类"><a href="#五、Array工具类" class="headerlink" title="五、Array工具类"></a>五、Array工具类</h3><p>Arrays 定义在 <code>java.util</code> 包下，提供了很多操作数组的方法</p><p>导包：<code>import java.util.Arrays;</code></p><h4 id="1-equals"><a href="#1-equals" class="headerlink" title="1 equals()"></a>1 equals()</h4><p><code>boolean equals(int[] a,int[] b)</code>: 判断两个数组是否相等</p><h4 id="2-toString"><a href="#2-toString" class="headerlink" title="2 toString()"></a>2 toString()</h4><p><code>String toString(int[] a)</code>: 输出数组信息</p><h4 id="3-fill"><a href="#3-fill" class="headerlink" title="3 fill()"></a>3 fill()</h4><p><code>void fill(int[] a,int val)</code>: 将指定值填充到数组之中</p><h4 id="4-sort"><a href="#4-sort" class="headerlink" title="4 sort()"></a>4 sort()</h4><p><code>void sort(int[] a)</code>: 对数组进行排序</p><h4 id="5-binarySearch"><a href="#5-binarySearch" class="headerlink" title="5 binarySearch()"></a>5 binarySearch()</h4><p><code>int binarySearch(int[] a,int key)</code>: 二分查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.boolean equals(int[] a,int[] b): 判断两个数组是否相等。</span></span><br><span class="line"><span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="type">boolean</span> <span class="variable">isEquals</span> <span class="operator">=</span> Arrays.equals(arr1, arr2);</span><br><span class="line">System.out.println(isEquals);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.String toString(int[] a): 输出数组信息。</span></span><br><span class="line">System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3.void fill(int[] a,int val): 将指定值填充到数组之中。</span></span><br><span class="line">Arrays.fill(arr1,<span class="number">10</span>);</span><br><span class="line">System.out.println(Arrays.toString(arr1));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.void sort(int[] a): 对数组进行排序。</span></span><br><span class="line">Arrays.sort(arr2);</span><br><span class="line">System.out.println(Arrays.toString(arr2));</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.int binarySearch(int[] a,int key)</span></span><br><span class="line"><span class="type">int</span>[] arr3 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">98</span>,-<span class="number">34</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">54</span>,<span class="number">66</span>,<span class="number">79</span>,<span class="number">105</span>,<span class="number">210</span>,<span class="number">333</span>&#125;;</span><br><span class="line"><span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> Arrays.binarySearch(arr3, <span class="number">210</span>);</span><br><span class="line"><span class="keyword">if</span>(index &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">    System.out.println(index);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;未找到&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="六、数组的常见异常"><a href="#六、数组的常见异常" class="headerlink" title="六、数组的常见异常"></a>六、数组的常见异常</h3><h4 id="1-数组角标越界异常"><a href="#1-数组角标越界异常" class="headerlink" title="1 数组角标越界异常"></a>1 数组角标越界异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//System.out.println(arr[-2]);//ArrayIndexOutOfBoundsException</span></span><br></pre></td></tr></table></figure><h4 id="2-空指针异常"><a href="#2-空指针异常" class="headerlink" title="2 空指针异常"></a>2 空指针异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//情况一：</span></span><br><span class="line"><span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">arr1 = <span class="literal">null</span>;</span><br><span class="line"><span class="comment">//System.out.println(arr1[0]);//NullPointerException</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//情况二：</span></span><br><span class="line"><span class="type">int</span>[][] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][];</span><br><span class="line"><span class="comment">//System.out.println(arr2[0][0]);//NullPointerException</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;数组、一维数组、二维数组&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://actionding.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="编程" scheme="https://actionding.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://actionding.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】5-流程控制之循环结构</title>
    <link href="https://actionding.github.io/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%915-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B9%8B%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/"/>
    <id>https://actionding.github.io/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%915-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B9%8B%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84/</id>
    <published>2020-07-04T19:02:05.000Z</published>
    <updated>2022-03-08T12:42:57.155Z</updated>
    
    <content type="html"><![CDATA[<p>循环结构：for 循环结构、while 循环结构、do-while 循环结构、嵌套循环</p><span id="more"></span><h3 id="一、循环结构的四要素"><a href="#一、循环结构的四要素" class="headerlink" title="一、循环结构的四要素"></a>一、循环结构的四要素</h3><p>① 初始化条件<br>② 循环条件  —&gt;是boolean类型<br>③ 循环体<br>④ 迭代条件</p><p><strong>说明</strong>：通常情况下，循环结束都是因为②中循环条件返回 <code>false </code>了。</p><h3 id="二、for-循环结构"><a href="#二、for-循环结构" class="headerlink" title="二、for 循环结构"></a>二、for 循环结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(①;②;④)&#123;</span><br><span class="line">③</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行过程</strong>：① - ② - ③ - ④ - ② - ③ - ④ - … - ②</p><h3 id="三、while-循环结构"><a href="#三、while-循环结构" class="headerlink" title="三、while 循环结构"></a>三、while 循环结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①</span><br><span class="line"><span class="keyword">while</span>(②)&#123;</span><br><span class="line">③;</span><br><span class="line">④;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行过程</strong>：① - ② - ③ - ④ - ② - ③ - ④ - … - ②</p><p><strong>说明</strong></p><p>1）写while循环千万小心不要丢了迭代条件。一旦丢了，就可能导致死循环！<br>2）我们写程序，要避免出现死循环。<br>3）for循环和while循环是可以相互转换的！ </p><blockquote><p>for 和 while 循环总结：</p><p>1）开发中，基本上我们都会从for、while中进行选择，实现循环结构。</p><p>2）for循环和while循环是可以相互转换的！ </p><p>3）我们写程序，要避免出现死循环。</p><p>4）<strong>区别</strong>：for循环和while循环的初始化条件部分的作用范围不同。</p></blockquote><h3 id="四、do-while-循环结构"><a href="#四、do-while-循环结构" class="headerlink" title="四、do-while 循环结构"></a>四、do-while 循环结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">①</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">③;</span><br><span class="line">④;</span><br><span class="line">&#125;<span class="keyword">while</span>(②);</span><br></pre></td></tr></table></figure><p><strong>执行过程</strong>：① - ③ - ④ - ② - ③ - ④ - … - ②</p><p><strong>说明</strong><br>1）do-while 循环至少会执行一次循环体！<br>2）开发中，使用 for 和 while 更多一些。较少使用 do-while</p><h3 id="五、嵌套循环"><a href="#五、嵌套循环" class="headerlink" title="五、嵌套循环"></a>五、嵌套循环</h3><p><strong>1 嵌套循环</strong>：将一个循环结构A声明在另一个循环结构B的循环体中,就构成了嵌套循环</p><p>1）<strong>外层循环</strong>：循环结构B</p><p>2）<strong>内层循环</strong>：循环结构A</p><p><strong>2 说明</strong></p><p>1）内层循环结构遍历一遍，只相当于外层循环循环体执行了一次</p><p>2）假设外层循环需要执行m次，内层循环需要执行n次。此时内层循环的循环体一共执行了m * n次</p><p>3）外层循环控制行数，内层循环控制列数</p><h3 id="六、break-和-continue-关键字"><a href="#六、break-和-continue-关键字" class="headerlink" title="六、break 和 continue 关键字"></a>六、break 和 continue 关键字</h3><table><thead><tr><th align="center"></th><th align="center">使用范围</th><th align="center">循环中的作用</th><th align="center">相同点</th></tr></thead><tbody><tr><td align="center">break</td><td align="center">switch-case、循环结构中</td><td align="center">结束当前循环</td><td align="center">关键字后面不能声明执行语句</td></tr><tr><td align="center">continue</td><td align="center">循环结构中</td><td align="center">结束当次循环</td><td align="center">关键字后面不能声明执行语句</td></tr></tbody></table><blockquote><p><strong>“无限循环”结构</strong>: while(true) 或 for(;;)</p><p><strong>总结</strong>：如何结束一个循环结构？<br>​    方式一：当循环条件是false时<br>​    方式二：在循环体中，执行break</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;循环结构：for 循环结构、while 循环结构、do-while 循环结构、嵌套循环&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://actionding.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="编程" scheme="https://actionding.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://actionding.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】4-流程控制之分支结构</title>
    <link href="https://actionding.github.io/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%914-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B9%8B%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/"/>
    <id>https://actionding.github.io/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%914-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E4%B9%8B%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84/</id>
    <published>2020-07-04T19:02:04.000Z</published>
    <updated>2022-03-08T12:42:46.938Z</updated>
    
    <content type="html"><![CDATA[<p>分支结构：if-else 条件判断结构、switch-case 选择结构</p><span id="more"></span><h3 id="一、if-else-条件判断结构"><a href="#一、if-else-条件判断结构" class="headerlink" title="一、if-else 条件判断结构"></a>一、if-else 条件判断结构</h3><p>分支结构中的if-else（条件判断结构）</p><h4 id="1-三种结构"><a href="#1-三种结构" class="headerlink" title="1 三种结构"></a>1 三种结构</h4><p>① 第一种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>② 第二种：二选一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">执行表达式<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>③ 第三种：n选一</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式<span class="number">1</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式<span class="number">2</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(条件表达式)&#123;</span><br><span class="line">执行表达式<span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">执行表达式n</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>产生<strong>随机数</strong>：使用 Math.random() → [0.0 - 1.0)</p><p>公式：[a,b] → (int)(Math.random() * (b - a + 1) ) + a</p></blockquote><h4 id="2-说明"><a href="#2-说明" class="headerlink" title="2 说明"></a>2 说明</h4><p>1）else 结构是可选的。</p><p>2）针对于条件表达式：</p><p>​    如果多个条件表达式之间是“互斥”关系(或没有交集的关系)，哪个判断和执行语句声明顺序无所谓。<br>​    如果多个条件表达式之间有交集的关系，需要根据实际情况，考虑清楚应该将哪个结构先声明。<br>​    如果多个条件表达式之间有包含的关系，通常情况下，需要将范围小声明在范围大的前面。否则，范围小的就没机会执行了。</p><p>3）if-else结构是可以相互嵌套的。</p><p>4）如果if-else结构中的执行语句只有一行时，对应的一对{}可以省略的。但是，不建议大家省略。</p><h3 id="二、switch-case-选择结构"><a href="#二、switch-case-选择结构" class="headerlink" title="二、switch-case 选择结构"></a>二、switch-case 选择结构</h3><h4 id="1-格式"><a href="#1-格式" class="headerlink" title="1 格式"></a>1 格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式)&#123;</span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">1</span>:</span><br><span class="line">执行语句<span class="number">1</span>;</span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">case</span> 常量<span class="number">2</span>:</span><br><span class="line">执行语句<span class="number">2</span>;</span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">执行语句n;</span><br><span class="line"><span class="comment">//break;</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-说明-1"><a href="#2-说明-1" class="headerlink" title="2 说明"></a>2 说明</h4><p>1）根据switch表达式中的值，依次匹配各个case中的常量。一旦匹配成功，则进入相应case结构中，调用其执行语句。<br>    当调用完执行语句以后，则仍然继续向下执行其他case结构中的执行语句，直到遇到break关键字或此switch-case结构末尾结束为止。</p><p>2）<code>break</code>：可以使用在switch-case结构中，表示一旦执行到此关键字，就跳出switch-case结构</p><p>3）switch结构中的表达式，只能是如下的6种数据类型之一：<code>byte 、short、char、int、枚举类型(JDK5.0新增)、String类型(JDK7.0新增)</code></p><p>4）case 之后只能声明常量。不能声明范围。</p><p>5）break关键字是可选的。</p><p>6）<code>default</code>：相当于if-else结构中的else；default结构是可选的，而且位置是灵活的。</p><blockquote><p><strong>注意</strong></p><p>1）凡是可以使用switch-case的结构，都可以转换为if-else。反之，不成立。</p><p>2）我们写分支结构时，当发现既可以使用switch-case,（同时，switch中表达式的取值情况不太多），又可以使用if-else时，我们优先选择使用switch-case。原因：switch-case执行效率稍高。</p><p>3）如果switch-case结构中的多个case的执行语句相同，则可以考虑进行合并。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;分支结构：if-else 条件判断结构、switch-case 选择结构&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://actionding.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="编程" scheme="https://actionding.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://actionding.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】3-运算符</title>
    <link href="https://actionding.github.io/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%913-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://actionding.github.io/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%913-%E8%BF%90%E7%AE%97%E7%AC%A6/</id>
    <published>2020-07-04T19:02:03.000Z</published>
    <updated>2022-03-08T12:42:39.788Z</updated>
    
    <content type="html"><![CDATA[<p>算数运算符、赋值运算符、比较运算符、逻辑运算符、位运算符、三元运算符</p><span id="more"></span><h3 id="一、算术运算符"><a href="#一、算术运算符" class="headerlink" title="一、算术运算符"></a>一、算术运算符</h3><table><thead><tr><th align="center"><code>+</code></th><th align="center"><code>-</code></th><th align="center"><code>+</code></th><th align="center"><code>-</code></th><th align="center"><code>*</code></th><th align="center"><code>/</code></th><th align="center"><code>%</code></th><th align="center"><code>++</code></th><th align="center"><code>--</code></th><th align="center"><code>++</code></th><th align="center"><code>--</code></th><th align="center"><code>+</code></th></tr></thead><tbody><tr><td align="center">正号</td><td align="center">负号</td><td align="center">加</td><td align="center">减</td><td align="center">乘</td><td align="center">除</td><td align="center">取余</td><td align="center">前自增</td><td align="center">前自减</td><td align="center">后自增</td><td align="center">后自减</td><td align="center">字符串连接</td></tr></tbody></table><p><strong>1 自增</strong></p><p>​    (前)++：先自增1，后运算<br>​    (后)++：先运算，后自增1</p><p><strong>2 自减</strong></p><p>​    (前)–：先自减1，后运算<br>​    (后)–：先运算，后自减1</p><p><strong>3 连接符</strong>：+（只能使用在String与其他数据类型变量之间使用）</p><h3 id="二、赋值运算符"><a href="#二、赋值运算符" class="headerlink" title="二、赋值运算符"></a>二、赋值运算符</h3><p><code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code></p><blockquote><p><strong>注意</strong>：运算的结果不会改变变量本身的数据类型</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开发中，如果希望变量实现+2的操作，有几种方法？(前提：int num = 10;)</span></span><br><span class="line"><span class="comment">//方式一：num = num + 2;</span></span><br><span class="line"><span class="comment">//方式二：num += 2; (推荐)</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开发中，如果希望变量实现+1的操作，有几种方法？(前提：int num = 10;)</span></span><br><span class="line"><span class="comment">//方式一：num = num + 1;</span></span><br><span class="line"><span class="comment">//方式二：num += 1; </span></span><br><span class="line"><span class="comment">//方式三：num++; (推荐)</span></span><br></pre></td></tr></table></figure><h3 id="三、比较运算符"><a href="#三、比较运算符" class="headerlink" title="三、比较运算符"></a>三、比较运算符</h3><p>也叫<strong>关系运算符</strong></p><p><code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>&lt;=</code>、<code>&gt;=</code>、<code>instanceof</code></p><blockquote><p>比较运算符的结果都是 boolean 型</p><ol><li><p>&lt;、&gt;&#x3D;、&lt;&#x3D; :只能使用在数值类型的数据之间。</p></li><li><p>&#x3D;&#x3D; 和 !&#x3D;: 不仅可以使用在数值类型数据之间，还可以使用在其他引用类型变量之间。</p></li></ol></blockquote><h3 id="四、逻辑运算符"><a href="#四、逻辑运算符" class="headerlink" title="四、逻辑运算符"></a>四、逻辑运算符</h3><table><thead><tr><th align="center"><code>&amp;</code></th><th align="center"><code>&amp;&amp;</code></th><th align="center"><code>|</code></th><th align="center"><code>||</code></th><th align="center"><code>!</code></th><th align="center"><code>^</code></th></tr></thead><tbody><tr><td align="center">逻辑与</td><td align="center">短路与</td><td align="center">逻辑或</td><td align="center">短路或</td><td align="center">逻辑非</td><td align="center">逻辑异或</td></tr></tbody></table><blockquote><p>逻辑运算符操作的都是boolean类型的变量，而且结果也是boolean类型</p></blockquote><h3 id="五、位运算符"><a href="#五、位运算符" class="headerlink" title="五、位运算符"></a>五、位运算符</h3><table><thead><tr><th align="center"><code>&lt;&lt;</code></th><th align="center"><code>&gt;&gt;</code></th><th align="center"><code>&gt;&gt;&gt;</code></th><th align="center"><code>&amp;</code></th><th align="center"><code>|</code></th><th align="center"><code>^</code></th><th align="center"><code>~</code></th></tr></thead><tbody><tr><td align="center">左移</td><td align="center">右移</td><td align="center">无符号右移</td><td align="center">与运算</td><td align="center">或运算</td><td align="center">异或运算</td><td align="center">取反运算</td></tr></tbody></table><p><strong>注</strong>：无<code>&lt;&lt;&lt;</code></p><blockquote><p>位运算是直接对整数的二进制进行的运算，操作的都是整型的数据</p><ol><li>&lt;&lt;：在一定范围内，每向左移1位，相当于 * 2</li><li>&gt;&gt;：在一定范围内，每向右移1位，相当于 &#x2F; 2</li></ol></blockquote><h3 id="六、三元运算符"><a href="#六、三元运算符" class="headerlink" title="六、三元运算符"></a>六、三元运算符</h3><p><strong>格式</strong>：<code>(条件表达式)?表达式 1 : 表达式 2;</code></p><p><strong>1</strong> 条件表达式的结果为 <strong>boolean</strong> 类型 </p><p><strong>2</strong> 根据条件表达式真或假，决定执行表达式1，还是表达式2.</p><p>​     如果表达式为true，则执行表达式1。<br>​     如果表达式为false，则执行表达式2。</p><p><strong>3</strong> 表达式1 和表达式2要求是一致的。</p><p><strong>4</strong> 三元运算符可以嵌套使用</p><p><strong>5</strong> 凡是可以使用三元运算符的地方，都可以改写为if-else；反之，不成立。</p><p><strong>6</strong> 如果程序既可以使用三元运算符，又可以使用if-else结构，那么优先选择三元运算符。原因：简洁、执行效率高。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;算数运算符、赋值运算符、比较运算符、逻辑运算符、位运算符、三元运算符&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://actionding.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="编程" scheme="https://actionding.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://actionding.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】2-变量</title>
    <link href="https://actionding.github.io/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%912-%E5%8F%98%E9%87%8F/"/>
    <id>https://actionding.github.io/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%912-%E5%8F%98%E9%87%8F/</id>
    <published>2020-07-04T19:02:02.000Z</published>
    <updated>2022-03-08T12:42:31.838Z</updated>
    
    <content type="html"><![CDATA[<p>关键字、保留字、标识符、变量、自动类型转换、强制类型转换</p><h3 id="一、关键字与保留字"><a href="#一、关键字与保留字" class="headerlink" title="一、关键字与保留字"></a>一、关键字与保留字</h3><h4 id="1-关键字-keyword"><a href="#1-关键字-keyword" class="headerlink" title="1 关键字(keyword)"></a>1 关键字(keyword)</h4><p><strong>定义</strong></p><p>​     被 Java 语言赋予了特殊含义，用做专门用途的字符串（单词）</p><p><strong>特点</strong></p><p>​    关键字中所有字母都为<strong>小写</strong></p><p><strong><a href="https://docs.oracle.com/javase/tutorial/java/nutsandbolts/_keywords.html">官方地址</a></strong></p><p><img src="/../../images/%E5%85%B3%E9%94%AE%E5%AD%971.png" alt="关键字1"></p><p><img src="/../../images/%E5%85%B3%E9%94%AE%E5%AD%972.png" alt="关键字2"></p><h4 id="2-保留字-reserved-word"><a href="#2-保留字-reserved-word" class="headerlink" title="2 保留字(reserved word)"></a>2 保留字(reserved word)</h4><p><strong>保留字</strong></p><p>​    现有 Java 版本尚未使用,但以后版本可能会作为关键字使用。自己命名标识符时要避免使用这些保留字</p><ul><li><strong>goto</strong> 、 <strong>const</strong></li><li>命名标识符时要避免使用这些保留字</li></ul><h3 id="二、标识符-Identifier"><a href="#二、标识符-Identifier" class="headerlink" title="二、标识符 (Identifier)"></a>二、标识符 (Identifier)</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1 定义"></a>1 定义</h4><p>​    Java 对各种变量、方法和类等要素命名时使用的字符序列称为<strong>标识符</strong></p><blockquote><p>凡是自己可以起名字的地方都叫<strong>标识符</strong></p><p>包名、类名、接口名、变量名、方法名、常量名</p></blockquote><h4 id="2-规则"><a href="#2-规则" class="headerlink" title="2 规则"></a>2 规则</h4><ul><li>由 26 个英文字母大小写， 0 9 或 $ 组成</li><li>数字不可以开头。</li><li>不可以使用关键字和保留字，但能包含关键字和保留字。</li><li>Java 中严格区分大小写，长度无限制。</li><li>标识符不能包含空格。</li></ul><h4 id="3-命名规范"><a href="#3-命名规范" class="headerlink" title="3 命名规范"></a>3 命名规范</h4><ul><li>包名：<code>xxxyyyzzz</code></li><li>类名、接口名：<code>XxxYyyZzz</code></li><li>变量名、方法名：<code>xxxYyyZzz</code></li><li>常亮名：<code>XXX_YYY_ZZZ</code></li></ul><blockquote><p>在起名字时，为了提高阅读性，要尽量意义，“见名知意”。</p></blockquote><h3 id="三、变量"><a href="#三、变量" class="headerlink" title="三、变量"></a>三、变量</h3><h4 id="1-定义变量"><a href="#1-定义变量" class="headerlink" title="1 定义变量"></a>1 定义变量</h4><p><strong>格式</strong></p><ol><li>数据类型  变量名 &#x3D; 变量值;</li><li>数据类型  变量名;<br>变量名 &#x3D; 变量值;<blockquote><p><strong>注意</strong></p><ol><li>变量必须先声明，后使用</li><li>变量都定义在其<strong>作用域</strong>内</li><li>同一个作用域内，不可以声明两个同名的变量</li></ol></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VariableTest</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//变量的定义</span></span><br><span class="line"><span class="type">int</span> <span class="variable">myAge</span> <span class="operator">=</span> <span class="number">22</span>;</span><br><span class="line"><span class="comment">//变量的使用</span></span><br><span class="line">System.out.println(myAge);</span><br><span class="line"></span><br><span class="line"><span class="comment">//变量的声明</span></span><br><span class="line"><span class="type">int</span> myNumber;</span><br><span class="line"><span class="comment">//System.out.println(myNnmber);//赋值后才能使用</span></span><br><span class="line"><span class="comment">//变量的赋值</span></span><br><span class="line">myNumber = <span class="number">1001</span>;</span><br><span class="line">System.out.println(myNumber);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span> <span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//作用域不同，可以定义同名变量</span></span><br><span class="line"><span class="comment">//变量的定义</span></span><br><span class="line"><span class="type">int</span> <span class="variable">myAge</span> <span class="operator">=</span> <span class="number">22</span>;</span><br><span class="line"><span class="comment">//变量的使用</span></span><br><span class="line">System.out.println(myAge);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-变量的分类"><a href="#2-变量的分类" class="headerlink" title="2 变量的分类"></a>2 变量的分类</h4><h5 id="按数据类型分类"><a href="#按数据类型分类" class="headerlink" title="按数据类型分类"></a>按数据类型分类</h5><p><img src="/../../images/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B.png" alt="数据类型"></p><h5 id="按声明的位置分类"><a href="#按声明的位置分类" class="headerlink" title="*按声明的位置分类"></a>*按声明的位置分类</h5><p><img src="/../../images/%E5%8F%98%E9%87%8F.png" alt="变量"></p><h4 id="3-基本数据类型"><a href="#3-基本数据类型" class="headerlink" title="3 基本数据类型"></a>3 基本数据类型</h4><h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><table><thead><tr><th align="center">byte</th><th align="center">short</th><th align="center">int</th><th align="center">long</th></tr></thead><tbody><tr><td align="center">1字节</td><td align="center">2字节</td><td align="center">4字节</td><td align="center">8字节</td></tr></tbody></table><blockquote><ol><li>byte范围：-128 ~ 127</li><li>声明long型变量，必须以”l”或”L”结尾</li><li>通常，定义整型变量时，使用int型。</li><li>整型的常量，默认类型是：int型</li></ol></blockquote><h5 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h5><table><thead><tr><th align="center">float</th><th align="center">double</th></tr></thead><tbody><tr><td align="center">4字节</td><td align="center">8字节</td></tr></tbody></table><blockquote><ol><li>浮点型，表示带小数点的数值</li><li>float表示数值的范围比long还大</li><li>定义float类型变量时，变量要以”f”或”F”结尾</li><li>通常，定义浮点型变量时，使用double型。</li><li>浮点型的常量，默认类型为：double</li></ol></blockquote><h5 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h5><table><thead><tr><th align="left">char</th></tr></thead><tbody><tr><td align="left">定义char型变量，通常使用一对’’,内部只能写一个字符</td></tr><tr><td align="left">表示方式：1. 声明一个字符 2. 转义字符 3. 直接使用 Unicode 值来表示字符型常量</td></tr></tbody></table><h5 id="布尔型"><a href="#布尔型" class="headerlink" title="布尔型"></a>布尔型</h5><table><thead><tr><th align="left">boolean</th></tr></thead><tbody><tr><td align="left">只能取两个值之一：true 、 false</td></tr><tr><td align="left">常常在条件判断、循环结构中使用</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VariableTest1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//基本数据类型</span></span><br><span class="line"><span class="comment">//整型：byte 1字节 -128 ~ 127</span></span><br><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line"><span class="comment">//byte b2 = 128;</span></span><br><span class="line">System.out.println(b1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//整型：short 2字节</span></span><br><span class="line"><span class="comment">//整型：int 4字节</span></span><br><span class="line"><span class="comment">//整型：long 8字节 以&#x27;l&#x27;或&#x27;L&#x27;结尾</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通常，定义整型变量时，使用int型</span></span><br><span class="line"></span><br><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">123456789098765432L</span>;</span><br><span class="line"><span class="comment">//long l2 = 987654321012345678;</span></span><br><span class="line">System.out.println(l1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//浮点型：float 4字节 以&#x27;f&#x27;或&#x27;F&#x27;结尾</span></span><br><span class="line"><span class="comment">//浮点型：double 8字节</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通常，定义浮点型变量时，使用double型</span></span><br><span class="line"></span><br><span class="line"><span class="type">float</span> <span class="variable">f1</span> <span class="operator">=</span> <span class="number">123.45f</span>;</span><br><span class="line"><span class="comment">//float f2 = 678.90;</span></span><br><span class="line">System.out.println(f1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//字符型：char 1字符=2字节 用一对单引号&#x27;&#x27;</span></span><br><span class="line"><span class="comment">//表示方式：</span></span><br><span class="line"><span class="comment">//1.声明一个字符 </span></span><br><span class="line"><span class="comment">//2.转义字符 </span></span><br><span class="line"><span class="comment">//3.直接使用 Unicode 值来表示字符型常量</span></span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line"><span class="comment">//char c2 = &#x27;ab&#x27;;</span></span><br><span class="line">System.out.println(c1);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="variable">c3</span> <span class="operator">=</span> <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c4</span> <span class="operator">=</span> <span class="string">&#x27;の&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c5</span> <span class="operator">=</span> <span class="string">&#x27;中&#x27;</span>;</span><br><span class="line">System.out.println(c3);</span><br><span class="line">System.out.println(c4);</span><br><span class="line">System.out.println(c5);</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> <span class="variable">c6</span> <span class="operator">=</span> <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c7</span> <span class="operator">=</span> <span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line"><span class="type">char</span> <span class="variable">c8</span> <span class="operator">=</span> <span class="string">&#x27;\u1001&#x27;</span>;</span><br><span class="line">System.out.println(<span class="string">&quot;***&quot;</span> + c6 + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;***&quot;</span> + c7 + <span class="string">&quot;***&quot;</span>);</span><br><span class="line">System.out.println(c8);</span><br><span class="line"></span><br><span class="line"><span class="comment">//布尔型：boolean true/false </span></span><br><span class="line"><span class="comment">//常常在条件判断、循环结构中使用</span></span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isMale</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">System.out.println(isMale);</span><br><span class="line"></span><br><span class="line"><span class="type">boolean</span> <span class="variable">isMarried</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">if</span> (isMarried)&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Go home&quot;</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Go party&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四、自动类型转换"><a href="#四、自动类型转换" class="headerlink" title="四、自动类型转换"></a>四、自动类型转换</h3><p>当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型。<br>    <code>byte 、char 、short --&gt; int --&gt; long --&gt; float --&gt; double </code><br><strong>特别的</strong>：当byte、char、short三种类型的变量做运算时，结果为int型</p><blockquote><p>此时的容量大小指的是，表示数的范围的大和小。比如：float容量要大于long的容量</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VariableTest2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">byte</span> <span class="variable">b1</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> <span class="number">129</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> b1 + i1;</span><br><span class="line"><span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> b1 + i1;</span><br><span class="line"><span class="type">float</span> <span class="variable">f</span> <span class="operator">=</span> b1 + i1;</span><br><span class="line">System.out.println(i2);</span><br><span class="line">System.out.println(l);</span><br><span class="line">System.out.println(f);</span><br><span class="line"></span><br><span class="line"><span class="type">short</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> s1;</span><br><span class="line">System.out.println(d1);<span class="comment">//123.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//***************特别地*********************</span></span><br><span class="line"><span class="type">char</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>;<span class="comment">//97</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i3</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> <span class="variable">i4</span> <span class="operator">=</span> c1 + i3;</span><br><span class="line">System.out.println(i4);</span><br><span class="line"></span><br><span class="line"><span class="type">short</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//char c3 = c1 + b2;//编译不通过</span></span><br><span class="line"><span class="comment">//short s3 = b2 + s2;//编译不通过</span></span><br><span class="line"><span class="comment">//short s4 = b1 + b2;//编译不通过</span></span><br><span class="line"><span class="comment">//****************************************</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五、强制类型转换"><a href="#五、强制类型转换" class="headerlink" title="五、强制类型转换"></a>五、强制类型转换</h3><p><strong>强转符</strong>：()</p><blockquote><p><strong>注意</strong>：强制类型转换，可能导致精度损失。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">VariableTest3</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="type">double</span> <span class="variable">d1</span> <span class="operator">=</span> <span class="number">12.9</span>;</span><br><span class="line"><span class="comment">//精度损失举例1</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> (<span class="type">int</span>)d1;<span class="comment">//截断操作</span></span><br><span class="line">System.out.println(i1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//没有精度损失</span></span><br><span class="line"><span class="type">long</span> <span class="variable">l1</span> <span class="operator">=</span> <span class="number">123</span>;</span><br><span class="line"><span class="type">short</span> <span class="variable">s2</span> <span class="operator">=</span> (<span class="type">short</span>)l1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//精度损失举例2</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i2</span> <span class="operator">=</span> <span class="number">128</span>;</span><br><span class="line"><span class="type">byte</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">byte</span>)i2;</span><br><span class="line">System.out.println(b);<span class="comment">//-128</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关键字、保留字、标识符、变量、自动类型转换、强制类型转换&lt;/p&gt;
&lt;h3 id=&quot;一、关键字与保留字&quot;&gt;&lt;a href=&quot;#一、关键字与保留字&quot; class=&quot;headerlink&quot; title=&quot;一、关键字与保留字&quot;&gt;&lt;/a&gt;一、关键字与保留字&lt;/h3&gt;&lt;h4 id=&quot;1</summary>
      
    
    
    
    <category term="笔记" scheme="https://actionding.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="编程" scheme="https://actionding.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://actionding.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】1-第一个Java程序</title>
    <link href="https://actionding.github.io/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%911-%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F/"/>
    <id>https://actionding.github.io/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%911-%E7%AC%AC%E4%B8%80%E4%B8%AAJava%E7%A8%8B%E5%BA%8F/</id>
    <published>2020-07-04T19:02:01.000Z</published>
    <updated>2022-03-08T12:38:21.940Z</updated>
    
    <content type="html"><![CDATA[<p><strong>国际惯例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印 Hello World</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="一、第一个Java程序"><a href="#一、第一个Java程序" class="headerlink" title="一、第一个Java程序"></a>一、第一个Java程序</h3><h4 id="1-编译运行过程"><a href="#1-编译运行过程" class="headerlink" title="1 编译运行过程"></a>1 编译运行过程</h4><p>① 将 Java 代码编写到扩展名为 .java 的文件中。</p><p>② 通过 javac 命令对该 java 文件进行<strong>编译</strong> 。</p><p>③ 通过 java 命令对生成的 class 文件进行<strong>运行</strong> 。</p><p><img src="/../../images/%E7%BC%96%E8%AF%91%E8%BF%90%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="编译运行过程"></p><h4 id="2-具体步骤"><a href="#2-具体步骤" class="headerlink" title="2 具体步骤"></a>2 具体步骤</h4><p><strong>步骤一</strong>：打开记事本，输入以上代码，保存为 <code>HelloWorld.java</code></p><p><strong>步骤二</strong>：在保存文件的位置打开命令行，输入<code>javac HelloWorld.java</code>，会生成一个HelloWorld.class文件</p><p><strong>步骤三</strong>：命令行继续输入<code>java HelloWorld</code></p><p><img src="/../../images/helloworld.png" alt="helloworld"></p><h3 id="二、注释"><a href="#二、注释" class="headerlink" title="二、注释"></a>二、注释</h3><h4 id="1-单行注释"><a href="#1-单行注释" class="headerlink" title="1 单行注释"></a>1 单行注释</h4><p>​    <strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注释文字</span></span><br></pre></td></tr></table></figure><h4 id="2-多行注释"><a href="#2-多行注释" class="headerlink" title="2 多行注释"></a>2 多行注释</h4><p>​    <strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">注释文字 </span></span><br><span class="line"><span class="comment">注释文字 </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h4 id="3-文档注释"><a href="#3-文档注释" class="headerlink" title="3 文档注释"></a>3 文档注释</h4><p>​    <strong>格式</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> 指定 java 程序的作者</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 指定源文件的版本</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><blockquote><p>注释内容可以被 JDK 提供的工具 javadoc 所解析，生成一套以网页文件形式体现的该程序的说明文档。</p></blockquote><p>​    <strong>操作方式</strong>：<code>javadoc -d mydoc -author -version HelloWorld.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Java注释的三种方式：</span></span><br><span class="line"><span class="comment">①单行注释</span></span><br><span class="line"><span class="comment">②多行注释</span></span><br><span class="line"><span class="comment">③文档注释（Java特有）</span></span><br><span class="line"><span class="comment">生成文档：javadoc -d mydoc -author -version HelloJava.java</span></span><br><span class="line"><span class="comment">mydoc为文档目录</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*****这属于多行注释*****</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"><span class="doctag">@author</span> Ding</span></span><br><span class="line"><span class="comment"><span class="doctag">@version</span> 1.0</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*****这属于文档注释*****</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HelloJava</span> &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main方法是程序的入口*****这属于单行注释*****</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印HelloJava</span></span><br><span class="line">System.out.println(<span class="string">&quot;HelloJava&quot;</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="附"><a href="#附" class="headerlink" title="附"></a>附</h3><p><strong>Tips | 文件资源管理器</strong></p><p>①<code>win + E</code>打开文件资源管理器</p><p>②在地址栏输入 <code>cmd</code> 回车即可打开<strong>命令行</strong></p><p>③在查看工具栏中，打开<code>隐藏/显示</code>中的 <code>文件扩展名</code></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;国际惯例&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;// 打印 Hello World&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title class_&quot;&gt;HelloWorld&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title function_&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(String[] args)&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        System.out.println(&lt;span class=&quot;string&quot;&gt;&amp;quot;Hello World&amp;quot;&lt;/span&gt;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://actionding.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="编程" scheme="https://actionding.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://actionding.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>【Java基础】0-Java语言概述</title>
    <link href="https://actionding.github.io/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%910-Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/"/>
    <id>https://actionding.github.io/2020/07/%E3%80%90Java%E5%9F%BA%E7%A1%80%E3%80%910-Java%E8%AF%AD%E8%A8%80%E6%A6%82%E8%BF%B0/</id>
    <published>2020-07-04T19:02:00.000Z</published>
    <updated>2022-03-08T12:38:13.988Z</updated>
    
    <content type="html"><![CDATA[<p>Java 语言是 SUN (Stanford University Network, 斯坦福大学网络公司) 1995 年推出的一门高级编程语言。</p><p><a href="https://www.tiobe.com/tiobe-index/"><strong>TIOBE 指数</strong></a></p><span id="more"></span><h3 id="一、Java简史"><a href="#一、Java简史" class="headerlink" title="一、Java简史"></a>一、Java简史</h3><p>1991 年，Green 项目，开发语言最初命名为 Oak ( 橡树 )<br>1994 年，开发组意识到 Oak 非常适合于互联网<br>1996 年，发布 JDK 1.0，约 8.3 万个网页应用 Java 技术来制作<br>1997 年，发布 JDK 1.1 JavaOne 会议召开，创当时全球同类会议规模之最<br>1998 年，发布 JDK 1.2 ，同年发布企业平台 J2EE<br>1999 年， Java 分成 J2SE 、 J2EE 和 J2ME JSP&#x2F;Servlet 技术诞生<br><strong>2004 年，发布里程碑式版本： JDK 1.5 为突出此版本的重要性，更名为 JDK 5.0</strong><br>2005 年， J2SE –&gt; JavaSE；J2EE –&gt; JavaEE；J2ME –&gt; JavaME<br>2009 年， Oracle 公司收购 SUN，交易价格 74 亿美元<br>2011 年，发布 JDK 7.0<br><strong>2014 年，发布 JDK 8.0 ，是继 JDK 5.0 以来变化最大的版本</strong><br>2017 年，发布 JDK 9.0 ，最大限度实现模块化<br>2018 年 3 月，发布 JDK 10.0 ，版本号也称为 18.3<br>2018 年 9 月，发布 JDK 11.0 ，版本号也称为 18.9<br>2019 年 3 月，发布 JDK 12.0 ，版本号也称为 19.3<br>2019 年 9 月，发布 JDK 13.0 ，版本号也称为 19.9<br>2020 年 3 月，发布 JDK 14.0 ，版本号也称为 20.3</p><h3 id="二、Java技术体系平台"><a href="#二、Java技术体系平台" class="headerlink" title="二、Java技术体系平台"></a>二、Java技术体系平台</h3><h4 id="1-Java-SE"><a href="#1-Java-SE" class="headerlink" title="1 Java SE"></a>1 Java SE</h4><p>Java SE (Java Standard Edition): 标准版，支持面向桌面级应用（如Windows 下的应用程序）的 Java 平台，提供了完整的 Java 核心 API ，此版本以前称为 J2SE</p><h4 id="2-Java-EE"><a href="#2-Java-EE" class="headerlink" title="2 Java EE"></a>2 Java EE</h4><p>Java EE (Java Enterprise Edition): 企业版，为开发企业环境下的应用程序提供的一套解决方案。该技术体系中包含的技术如Servlet 、 Jsp 等，主要针对于 Web 应用程序开发。版本以前称为 J2EE</p><h4 id="3-Java-ME"><a href="#3-Java-ME" class="headerlink" title="3 Java ME"></a>3 Java ME</h4><p>Java ME (Java Micro Edition): 小型版，支持Java 程序运行在移动终端（手机、 PDA ）上的平台，对 Java API 有所精简，并加入了针对移动终端的支持，此版本以前称为 J2ME</p><h4 id="4-Java-Card"><a href="#4-Java-Card" class="headerlink" title="4 Java Card"></a>4 Java Card</h4><p>支持一些Java 小程序（ Applets ）运行在小内存设备（如智能卡）上的平台</p><h3 id="三、应用领域"><a href="#三、应用领域" class="headerlink" title="三、应用领域"></a>三、应用领域</h3><h4 id="1-企业级应用"><a href="#1-企业级应用" class="headerlink" title="1 企业级应用"></a>1 企业级应用</h4><p>主要指复杂的大企业的软件系统、各种类型的网站。Java 的安全机制以及它的跨平台的优势，使它在分布式系统领域开发中有广泛应用。应用领域包括金融、电信、交通、电子商务等。</p><h4 id="2-Android-平台应用"><a href="#2-Android-平台应用" class="headerlink" title="2 Android 平台应用"></a>2 Android 平台应用</h4><p>Android 应用程序使用 Java 语言编写。Android 开发水平的高低很大程度上取决于 Java 语言核心能力是否扎实。</p><h4 id="3-大数据平台开发"><a href="#3-大数据平台开发" class="headerlink" title="3 大数据平台开发"></a>3 大数据平台开发</h4><p>各类框架有 Hadoop、spark、storm、flink 等，就这类技术生态圈来讲，还有各种中间件如 flume、kafka、sqoop 等等 ，这些框架以及工具大多数是用 Java 编写而成，但提供诸如 Java、scala、Python、R 等各种语言 API 供编程。</p><h4 id="4-移动领域应用"><a href="#4-移动领域应用" class="headerlink" title="4 移动领域应用"></a>4 移动领域应用</h4><p>主要表现在消费和嵌入式领域，是指在各种小型设备上的应用，包括手机、 PDA 、机顶盒、汽车通信设备等。</p><h3 id="四、主要特性"><a href="#四、主要特性" class="headerlink" title="四、主要特性"></a>四、主要特性</h3><p>1 <strong>Java 语言是易学的</strong></p><p>2 <strong>Java 语言是强制面向对象的</strong></p><p>3 <strong>Java 语言是分布式的</strong></p><p>4 <strong>Java 语言是健壮的</strong></p><p>5 <strong>Java 语言是安全的</strong></p><p>6 <strong>Java 语言是体系结构中立的</strong></p><p>7 <strong>Java 语言是解释型的</strong></p><p>8 <strong>Java 是性能略高的</strong></p><p>9 <strong>Java 语言是原生支持多线程的</strong></p><h3 id="五、Java语言运行机制"><a href="#五、Java语言运行机制" class="headerlink" title="五、Java语言运行机制"></a>五、Java语言运行机制</h3><h4 id="1-Java语言的特点"><a href="#1-Java语言的特点" class="headerlink" title="1 Java语言的特点"></a>1 Java语言的特点</h4><p>① 面向对象</p><ul><li>两个基本概念：类、对象</li><li>三大特性：封装、继承、多态</li></ul><p>② 健壮性</p><p>③ 跨平台性</p><h4 id="2-Java两种核心机制"><a href="#2-Java两种核心机制" class="headerlink" title="2 Java两种核心机制"></a>2 Java两种核心机制</h4><p>① <strong>Java虚拟机</strong>（Java Virtual Machine）</p><p>​    JVM 是一个虚拟的计算机，具有指令集并使用不同的存储区域。负责执行指令，管理数据、内存、寄存器 。</p><ul><li>对于不同的平台，有不同的虚拟机。</li><li>Java 虚拟机机制屏蔽了底层运行平台的差别，实现了“ 一次编译，到处运行“</li></ul><p>② <strong>垃圾回收机制</strong>（Garbage Collection）</p><ul><li>不再使用的内存空间应回收–垃圾回收。</li><li>垃圾回收在 Java 程序运行过程中自动进行，程序员无法精确控制和干预。</li></ul><h4 id="3-Java语言的环境搭建"><a href="#3-Java语言的环境搭建" class="headerlink" title="3 Java语言的环境搭建"></a>3 Java语言的环境搭建</h4><p>①<strong>JDK</strong>(Java Development Kit Java 开发工具包)</p><p>②<strong>JRE</strong>(Java R untime Environment Java 运行环境 )</p><p>③<strong>JDK、 JRE 、JVM之间的关系</strong></p><p><img src="/../../images/JDK%E3%80%81JRE%E3%80%81JVM%E4%B9%8B%E9%97%B4%E7%9A%84%E5%85%B3%E7%B3%BB.png" alt="JDK、JRE、JVM之间的关系"></p><ul><li>JDK &#x3D; JRE + 开发工具集（例如 Javac 编译工具 等）</li><li>JRE &#x3D; JVM + Java SE 标准类库</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Java 语言是 SUN (Stanford University Network, 斯坦福大学网络公司) 1995 年推出的一门高级编程语言。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.tiobe.com/tiobe-index/&quot;&gt;&lt;strong&gt;TIOBE 指数&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="笔记" scheme="https://actionding.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="编程" scheme="https://actionding.github.io/tags/%E7%BC%96%E7%A8%8B/"/>
    
    <category term="Java" scheme="https://actionding.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Markdown 笔记</title>
    <link href="https://actionding.github.io/2020/03/Markdown%20%E7%AC%94%E8%AE%B0/"/>
    <id>https://actionding.github.io/2020/03/Markdown%20%E7%AC%94%E8%AE%B0/</id>
    <published>2020-03-01T16:00:00.000Z</published>
    <updated>2022-03-11T01:50:22.637Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Markdown-笔记"><a href="#Markdown-笔记" class="headerlink" title="Markdown 笔记"></a>Markdown 笔记</h1><p>[toc]</p><p><a href="https://markdown.com.cn/">Markdown</a> 是一种可以使用普通文本编辑器编写的标记语言，通过简单的标记语法，它可以使普通文本内容具有一定的格式。</p><h2 id="标题"><a href="#标题" class="headerlink" title="标题"></a>标题</h2><h3 id="1级标题"><a href="#1级标题" class="headerlink" title="1级标题"></a>1级标题</h3><p>   使用<code>=</code>（一个以上）或者<code>#</code>（一个）+ 空格</p><h3 id="2级标题"><a href="#2级标题" class="headerlink" title="2级标题"></a>2级标题</h3><p>   使用<code>-</code>（一个以上）或者<code>#</code>（两个）+ 空格</p><h3 id="3-6级标题"><a href="#3-6级标题" class="headerlink" title="3-6级标题"></a>3-6级标题</h3><p>   使用#（3-6个）+ 空格</p><h2 id="段落"><a href="#段落" class="headerlink" title="段落"></a>段落</h2><h3 id="换行"><a href="#换行" class="headerlink" title="换行"></a>换行</h3><p>使用两个以上空格加回车</p><h3 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h3><ol><li>斜体<br>使用一对<code>*</code>或者<code>_</code></li><li>粗体<br>使用一对<code>**</code>或者<code>__</code></li><li>粗斜体<br>使用一对<code>***</code>或者<code>___</code></li></ol><h3 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h3><p>使用两个以上的<code>*</code>、<code>-</code>或者<code>_</code></p><h3 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h3><p>使用波浪线<code>~~删除线文本~~</code></p><h3 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h3><p>使用HTML的标签<code>&lt;u&gt;下划线文本&lt;/u&gt;</code></p><h3 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h3><p>使用<code>[^脚注]</code> +<code>[^脚注]:脚注内容</code></p><h3 id="角标"><a href="#角标" class="headerlink" title="角标"></a>角标</h3><ol><li>上角标：使用<code>x^2^</code>–x^2^</li><li>下角标：使用<code>H~2~O</code>–H<del>2</del>O</li></ol><h3 id="高亮"><a href="#高亮" class="headerlink" title="高亮"></a>高亮</h3><p>使用等号<code>==高亮文本==</code></p><h3 id="居中"><a href="#居中" class="headerlink" title="居中"></a>居中</h3><p>使用HTML的标签<code>&lt;center&gt;居中文本&lt;/center&gt;</code></p><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><p>使用<code>[TOC]</code></p><h3 id="表情"><a href="#表情" class="headerlink" title="表情"></a>表情</h3><p>使用<code>:单词:</code></p><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>可分为<strong>有序列表</strong>和<strong>无序列表</strong>，可嵌套使用</p><h3 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h3><p>使用<code>数字</code> + <code>.  </code> + <code>空格</code></p><h3 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h3><p>使用<code>*</code>、<code>+</code>或者<code>-</code> + <code>空格</code></p><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>使用<code>&gt;</code> + <code>空格</code>，可嵌套，并可与列表嵌套</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="一行代码"><a href="#一行代码" class="headerlink" title="一行代码"></a>一行代码</h3><p>使用一对反引号</p><h3 id="一段代码"><a href="#一段代码" class="headerlink" title="一段代码"></a>一段代码</h3><p>使用三个反引号</p><h2 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h2><ol><li>使用<code>[链接名称](链接地址)</code>（链接名称可省略）</li><li>使用<code>[链接名称][变量]</code>（与脚注类似）</li></ol><h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><ol><li>使用<code>![alt 属性文本](图片地址)</code></li><li>把图片直接拖入文档自动创建</li></ol><h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><ol><li>使用<code>|</code>来分隔单元格</li><li>使用<code>-</code>来分隔表头</li><li>对齐方式<ul><li>左对齐：<code>:---</code></li><li>右对齐：<code>---:</code></li><li>居中对齐：<code>:---:</code></li></ul></li></ol><h2 id="附：快捷键"><a href="#附：快捷键" class="headerlink" title="附：快捷键"></a>附：快捷键</h2><table><thead><tr><th align="center">快捷键</th><th align="center">功能</th><th align="center">快捷键</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">Ctrl+1</td><td align="center">一阶标题</td><td align="center">Ctrl+B</td><td align="center">字体加粗</td></tr><tr><td align="center">Ctrl+2</td><td align="center">二阶标题</td><td align="center">Ctrl+I</td><td align="center">字体倾斜</td></tr><tr><td align="center">Ctrl+3</td><td align="center">三阶标题</td><td align="center">Ctrl+U</td><td align="center">下划线</td></tr><tr><td align="center">Ctrl+4</td><td align="center">四阶标题</td><td align="center">Ctrl+Home</td><td align="center">返回顶部</td></tr><tr><td align="center">Ctrl+5</td><td align="center">五阶标题</td><td align="center">Ctrl+End</td><td align="center">返回底部</td></tr><tr><td align="center">Ctrl+6</td><td align="center">六阶标题</td><td align="center">Ctrl+T</td><td align="center">创建表格</td></tr><tr><td align="center">Ctrl+L</td><td align="center">选中某句话</td><td align="center">Ctrl+K</td><td align="center">创建超链接</td></tr><tr><td align="center">Ctrl+D</td><td align="center">选中某个单词</td><td align="center">Ctrl+F</td><td align="center">搜索</td></tr><tr><td align="center">Ctrl+E</td><td align="center">选中相同格式的文字</td><td align="center">Ctrl+H</td><td align="center">搜索并替换</td></tr><tr><td align="center">Alt+Shift+5</td><td align="center">删除线</td><td align="center">Ctrl+Shift+I</td><td align="center">插入图片</td></tr><tr><td align="center">Ctrl+Shift+M</td><td align="center">公式块</td><td align="center">Ctrl+Shift+Q</td><td align="center">引用</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Markdown-笔记&quot;&gt;&lt;a href=&quot;#Markdown-笔记&quot; class=&quot;headerlink&quot; title=&quot;Markdown 笔记&quot;&gt;&lt;/a&gt;Markdown 笔记&lt;/h1&gt;&lt;p&gt;[toc]&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://mark</summary>
      
    
    
    
    <category term="笔记" scheme="https://actionding.github.io/categories/%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Markdown" scheme="https://actionding.github.io/categories/%E7%AC%94%E8%AE%B0/Markdown/"/>
    
    
    <category term="Markdown" scheme="https://actionding.github.io/tags/Markdown/"/>
    
  </entry>
  
</feed>
